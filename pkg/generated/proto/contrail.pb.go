// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/contrail.proto

/*
	Package contrail is a generated protocol buffer package.

	It is generated from these files:
		proto/contrail.proto

	It has these top-level messages:
		ResourceRequest
		ResourceResponse
		DeleteRequest
		DeleteResponse
		ListRequest
		Resource
		AccessControlList
		AddressGroup
		Alarm
		AliasIPPool
		AliasIP
		AnalyticsNode
		APIAccessList
		ApplicationPolicySet
		BGPAsAService
		BGPRouter
		BGPVPN
		BridgeDomain
		ConfigNode
		ConfigRoot
		CustomerAttachment
		DatabaseNode
		DiscoveryServiceAssignment
		Domain
		DsaRule
		E2ServiceProvider
		FirewallPolicy
		FirewallRule
		FloatingIPPool
		FloatingIP
		ForwardingClass
		GlobalQosConfig
		GlobalSystemConfig
		GlobalVrouterConfig
		InstanceIP
		InterfaceRouteTable
		LoadbalancerHealthmonitor
		LoadbalancerListener
		LoadbalancerMember
		LoadbalancerPool
		Loadbalancer
		LogicalInterface
		LogicalRouter
		Namespace
		NetworkDeviceConfig
		NetworkIpam
		NetworkPolicy
		PeeringPolicy
		PhysicalInterface
		PhysicalRouter
		PolicyManagement
		PortTuple
		Project
		ProviderAttachment
		QosConfig
		QosQueue
		RouteAggregate
		RouteTable
		RouteTarget
		RoutingInstance
		RoutingPolicy
		SecurityGroup
		SecurityLoggingObject
		ServiceAppliance
		ServiceApplianceSet
		ServiceConnectionModule
		ServiceEndpoint
		ServiceGroup
		ServiceHealthCheck
		ServiceInstance
		ServiceObject
		ServiceTemplate
		Subnet
		Tag
		TagType
		User
		VirtualDNSRecord
		VirtualDNS
		VirtualIP
		VirtualMachineInterface
		VirtualMachine
		VirtualNetwork
		VirtualRouter
		AppformixNodeRole
		BaremetalNode
		BaremetalPort
		ContrailAnalyticsDatabaseNodeRole
		ContrailAnalyticsNode
		ContrailCluster
		ContrailControllerNodeRole
		ControllerNodeRole
		Dashboard
		Keypair
		KubernetesCluster
		KubernetesNode
		Location
		Node
		OpenstackCluster
		OpenstackComputeNodeRole
		OpenstackStorageNodeRole
		VPNGroup
		Widget
		PermType
		LoadbalancerHealthmonitorType
		SNMPCredentials
		PolicyBasedForwardingRuleType
		VirtualMachineInterfacePropertiesType
		VirtualNetworkPolicyType
		ShareType
		StaticMirrorNhType
		FirewallRuleMatchTagsTypeIdList
		CommunityAttributes
		IpAddressesType
		ServiceTemplateInterfaceType
		IdPermsType
		RbacPermType
		FlowAgingTimeoutList
		UveKeysType
		DiscoveryServiceAssignmentType
		GracefulRestartParametersType
		ServiceInterfaceTag
		AllocationPoolType
		PolicyRuleType
		VirtualDnsRecordType
		AlarmExpression
		FirewallServiceType
		RoutingPolicyServiceInstanceType
		TimerType
		FirewallRuleEndpointType
		InterfaceMirrorType
		VirtualNetworkType
		PortType
		PortMappings
		ServiceInstanceInterfaceType
		SequenceType
		SecurityLoggingObjectRuleEntryType
		SubnetType
		RouteTargetList
		LinklocalServiceEntryType
		IpamSubnetType
		QuotaType
		KeyValuePairs
		TelemetryStateInfo
		FirewallRuleMatchTagsType
		LinklocalServicesTypes
		RouteTableType
		MacAddressesType
		VrfAssignRuleType
		ActionListType
		AclEntriesType
		VirtualIpType
		RouteType
		LoadbalancerType
		ProtocolType
		ServiceInstanceType
		MatchConditionType
		LoadbalancerMemberType
		UserCredentials
		AllowedAddressPairs
		TelemetryResourceInfo
		ControlTrafficDscpType
		UserDefinedLogStat
		LoadbalancerPoolType
		KeyValuePair
		IpamSubnets
		LoadbalancerListenerType
		BridgeDomainMembershipType
		VnSubnetsType
		ServiceApplianceInterfaceType
		SubnetListType
		BGPaaServiceParametersType
		IpamDnsAddressType
		DhcpOptionsListType
		MACLimitControlType
		UserDefinedLogStatList
		EcmpHashingIncludeFields
		EncapsulationPrioritiesType
		VirtualRouterNetworkIpamType
		VirtualDnsType
		FirewallSequence
		MirrorActionType
		IpamType
		JunosServicePorts
		AlarmOperand2
		RbacRuleType
		DomainLimitsType
		PolicyEntriesType
		ServiceHealthCheckType
		AddressType
		FlowAgingTimeout
		QosIdForwardingClassPair
		RbacRuleEntriesType
		FloatingIpPoolSubnetType
		ServiceTemplateType
		FatFlowProtocols
		MACMoveLimitControlType
		DiscoveryPubSubEndPointType
		AclRuleType
		PluginProperty
		SecurityLoggingObjectRuleListType
		FirewallServiceGroupType
		VrfAssignTableType
		MemberType
		AlarmAndList
		PortMap
		ProviderDetails
		PermType2
		DhcpOptionType
		QosIdForwardingClassPairs
		PluginProperties
		AlarmOrList
		ServiceScaleOutType
		AllowedAddressPair
*/
package contrail

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ResponseType int32

const (
	ResponseType_OK                 ResponseType = 0
	ResponseType_BadRequest         ResponseType = 1
	ResponseType_IntegrityError     ResponseType = 2
	ResponseType_NotFound           ResponseType = 3
	ResponseType_InternalServerEror ResponseType = 4
)

var ResponseType_name = map[int32]string{
	0: "OK",
	1: "BadRequest",
	2: "IntegrityError",
	3: "NotFound",
	4: "InternalServerEror",
}
var ResponseType_value = map[string]int32{
	"OK":                 0,
	"BadRequest":         1,
	"IntegrityError":     2,
	"NotFound":           3,
	"InternalServerEror": 4,
}

func (x ResponseType) String() string {
	return proto.EnumName(ResponseType_name, int32(x))
}
func (ResponseType) EnumDescriptor() ([]byte, []int) { return fileDescriptorContrail, []int{0} }

type ResourceRequest struct {
	Resource []*Resource `protobuf:"bytes,2,rep,name=resource" json:"resource,omitempty"`
}

func (m *ResourceRequest) Reset()                    { *m = ResourceRequest{} }
func (m *ResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*ResourceRequest) ProtoMessage()               {}
func (*ResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{0} }

func (m *ResourceRequest) GetResource() []*Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

type ResourceResponse struct {
	ResponseType ResponseType `protobuf:"varint,1,opt,name=response_type,json=responseType,proto3,enum=ResponseType" json:"response_type,omitempty"`
	Resource     *Resource    `protobuf:"bytes,2,opt,name=resource" json:"resource,omitempty"`
}

func (m *ResourceResponse) Reset()                    { *m = ResourceResponse{} }
func (m *ResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*ResourceResponse) ProtoMessage()               {}
func (*ResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{1} }

func (m *ResourceResponse) GetResponseType() ResponseType {
	if m != nil {
		return m.ResponseType
	}
	return ResponseType_OK
}

func (m *ResourceResponse) GetResource() *Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

type DeleteRequest struct {
	ResourceType string   `protobuf:"bytes,1,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	Uuid         []string `protobuf:"bytes,2,rep,name=uuid" json:"uuid,omitempty"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{2} }

func (m *DeleteRequest) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *DeleteRequest) GetUuid() []string {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type DeleteResponse struct {
	ResponseType ResponseType `protobuf:"varint,1,opt,name=response_type,json=responseType,proto3,enum=ResponseType" json:"response_type,omitempty"`
	Uuid         string       `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{3} }

func (m *DeleteResponse) GetResponseType() ResponseType {
	if m != nil {
		return m.ResponseType
	}
	return ResponseType_OK
}

func (m *DeleteResponse) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

type ListRequest struct {
	ResourceType string   `protobuf:"bytes,1,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	Limit        int64    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset       int64    `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	Detail       bool     `protobuf:"varint,4,opt,name=detail,proto3" json:"detail,omitempty"`
	Count        bool     `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	Shared       bool     `protobuf:"varint,6,opt,name=shared,proto3" json:"shared,omitempty"`
	ExcludeHrefs bool     `protobuf:"varint,7,opt,name=exclude_hrefs,json=excludeHrefs,proto3" json:"exclude_hrefs,omitempty"`
	ParentFqName []string `protobuf:"bytes,8,rep,name=parent_fq_name,json=parentFqName" json:"parent_fq_name,omitempty"`
	ParentType   string   `protobuf:"bytes,9,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	ParentUuids  []string `protobuf:"bytes,10,rep,name=parent_uuids,json=parentUuids" json:"parent_uuids,omitempty"`
	BackrefUuids []string `protobuf:"bytes,11,rep,name=backref_uuids,json=backrefUuids" json:"backref_uuids,omitempty"`
	ObjectUuids  []string `protobuf:"bytes,12,rep,name=object_uuids,json=objectUuids" json:"object_uuids,omitempty"`
	Fields       []string `protobuf:"bytes,13,rep,name=fields" json:"fields,omitempty"`
}

func (m *ListRequest) Reset()                    { *m = ListRequest{} }
func (m *ListRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()               {}
func (*ListRequest) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{4} }

func (m *ListRequest) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *ListRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ListRequest) GetDetail() bool {
	if m != nil {
		return m.Detail
	}
	return false
}

func (m *ListRequest) GetCount() bool {
	if m != nil {
		return m.Count
	}
	return false
}

func (m *ListRequest) GetShared() bool {
	if m != nil {
		return m.Shared
	}
	return false
}

func (m *ListRequest) GetExcludeHrefs() bool {
	if m != nil {
		return m.ExcludeHrefs
	}
	return false
}

func (m *ListRequest) GetParentFqName() []string {
	if m != nil {
		return m.ParentFqName
	}
	return nil
}

func (m *ListRequest) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ListRequest) GetParentUuids() []string {
	if m != nil {
		return m.ParentUuids
	}
	return nil
}

func (m *ListRequest) GetBackrefUuids() []string {
	if m != nil {
		return m.BackrefUuids
	}
	return nil
}

func (m *ListRequest) GetObjectUuids() []string {
	if m != nil {
		return m.ObjectUuids
	}
	return nil
}

func (m *ListRequest) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Resource struct {
	// Types that are valid to be assigned to ResourceOneof:
	//	*Resource_AccessControlList
	//	*Resource_AddressGroup
	//	*Resource_Alarm
	//	*Resource_AliasIpPool
	//	*Resource_AliasIp
	//	*Resource_AnalyticsNode
	//	*Resource_ApiAccessList
	//	*Resource_ApplicationPolicySet
	//	*Resource_BgpAsAService
	//	*Resource_BgpRouter
	//	*Resource_Bgpvpn
	//	*Resource_BridgeDomain
	//	*Resource_ConfigNode
	//	*Resource_ConfigRoot
	//	*Resource_CustomerAttachment
	//	*Resource_DatabaseNode
	//	*Resource_DiscoveryServiceAssignment
	//	*Resource_Domain
	//	*Resource_DsaRule
	//	*Resource_E2ServiceProvider
	//	*Resource_FirewallPolicy
	//	*Resource_FirewallRule
	//	*Resource_FloatingIpPool
	//	*Resource_FloatingIp
	//	*Resource_ForwardingClass
	//	*Resource_GlobalQosConfig
	//	*Resource_GlobalSystemConfig
	//	*Resource_GlobalVrouterConfig
	//	*Resource_InstanceIp
	//	*Resource_InterfaceRouteTable
	//	*Resource_LoadbalancerHealthmonitor
	//	*Resource_LoadbalancerListener
	//	*Resource_LoadbalancerMember
	//	*Resource_LoadbalancerPool
	//	*Resource_Loadbalancer
	//	*Resource_LogicalInterface
	//	*Resource_LogicalRouter
	//	*Resource_Namespace
	//	*Resource_NetworkDeviceConfig
	//	*Resource_NetworkIpam
	//	*Resource_NetworkPolicy
	//	*Resource_PeeringPolicy
	//	*Resource_PhysicalInterface
	//	*Resource_PhysicalRouter
	//	*Resource_PolicyManagement
	//	*Resource_PortTuple
	//	*Resource_Project
	//	*Resource_ProviderAttachment
	//	*Resource_QosConfig
	//	*Resource_QosQueue
	//	*Resource_RouteAggregate
	//	*Resource_RouteTable
	//	*Resource_RouteTarget
	//	*Resource_RoutingInstance
	//	*Resource_RoutingPolicy
	//	*Resource_SecurityGroup
	//	*Resource_SecurityLoggingObject
	//	*Resource_ServiceAppliance
	//	*Resource_ServiceApplianceSet
	//	*Resource_ServiceConnectionModule
	//	*Resource_ServiceEndpoint
	//	*Resource_ServiceGroup
	//	*Resource_ServiceHealthCheck
	//	*Resource_ServiceInstance
	//	*Resource_ServiceObject
	//	*Resource_ServiceTemplate
	//	*Resource_Subnet
	//	*Resource_Tag
	//	*Resource_TagType
	//	*Resource_User
	//	*Resource_Virtual_DNSRecord
	//	*Resource_Virtual_DNS
	//	*Resource_VirtualIp
	//	*Resource_VirtualMachineInterface
	//	*Resource_VirtualMachine
	//	*Resource_VirtualNetwork
	//	*Resource_VirtualRouter
	//	*Resource_AppformixNodeRole
	//	*Resource_BaremetalNode
	//	*Resource_BaremetalPort
	//	*Resource_ContrailAnalyticsDatabaseNodeRole
	//	*Resource_ContrailAnalyticsNode
	//	*Resource_ContrailCluster
	//	*Resource_ContrailControllerNodeRole
	//	*Resource_ControllerNodeRole
	//	*Resource_Dashboard
	//	*Resource_Keypair
	//	*Resource_KubernetesCluster
	//	*Resource_KubernetesNode
	//	*Resource_Location
	//	*Resource_Node
	//	*Resource_OpenstackCluster
	//	*Resource_OpenstackComputeNodeRole
	//	*Resource_OpenstackStorageNodeRole
	//	*Resource_VpnGroup
	//	*Resource_Widget
	ResourceOneof isResource_ResourceOneof `protobuf_oneof:"resource_oneof"`
}

func (m *Resource) Reset()                    { *m = Resource{} }
func (m *Resource) String() string            { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()               {}
func (*Resource) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{5} }

type isResource_ResourceOneof interface {
	isResource_ResourceOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Resource_AccessControlList struct {
	AccessControlList *AccessControlList `protobuf:"bytes,4,opt,name=access_control_list,json=accessControlList,oneof"`
}
type Resource_AddressGroup struct {
	AddressGroup *AddressGroup `protobuf:"bytes,5,opt,name=address_group,json=addressGroup,oneof"`
}
type Resource_Alarm struct {
	Alarm *Alarm `protobuf:"bytes,6,opt,name=alarm,oneof"`
}
type Resource_AliasIpPool struct {
	AliasIpPool *AliasIPPool `protobuf:"bytes,7,opt,name=alias_ip_pool,json=aliasIpPool,oneof"`
}
type Resource_AliasIp struct {
	AliasIp *AliasIP `protobuf:"bytes,8,opt,name=alias_ip,json=aliasIp,oneof"`
}
type Resource_AnalyticsNode struct {
	AnalyticsNode *AnalyticsNode `protobuf:"bytes,9,opt,name=analytics_node,json=analyticsNode,oneof"`
}
type Resource_ApiAccessList struct {
	ApiAccessList *APIAccessList `protobuf:"bytes,10,opt,name=api_access_list,json=apiAccessList,oneof"`
}
type Resource_ApplicationPolicySet struct {
	ApplicationPolicySet *ApplicationPolicySet `protobuf:"bytes,11,opt,name=application_policy_set,json=applicationPolicySet,oneof"`
}
type Resource_BgpAsAService struct {
	BgpAsAService *BGPAsAService `protobuf:"bytes,12,opt,name=bgp_as_a_service,json=bgpAsAService,oneof"`
}
type Resource_BgpRouter struct {
	BgpRouter *BGPRouter `protobuf:"bytes,13,opt,name=bgp_router,json=bgpRouter,oneof"`
}
type Resource_Bgpvpn struct {
	Bgpvpn *BGPVPN `protobuf:"bytes,14,opt,name=bgpvpn,oneof"`
}
type Resource_BridgeDomain struct {
	BridgeDomain *BridgeDomain `protobuf:"bytes,15,opt,name=bridge_domain,json=bridgeDomain,oneof"`
}
type Resource_ConfigNode struct {
	ConfigNode *ConfigNode `protobuf:"bytes,16,opt,name=config_node,json=configNode,oneof"`
}
type Resource_ConfigRoot struct {
	ConfigRoot *ConfigRoot `protobuf:"bytes,17,opt,name=config_root,json=configRoot,oneof"`
}
type Resource_CustomerAttachment struct {
	CustomerAttachment *CustomerAttachment `protobuf:"bytes,18,opt,name=customer_attachment,json=customerAttachment,oneof"`
}
type Resource_DatabaseNode struct {
	DatabaseNode *DatabaseNode `protobuf:"bytes,19,opt,name=database_node,json=databaseNode,oneof"`
}
type Resource_DiscoveryServiceAssignment struct {
	DiscoveryServiceAssignment *DiscoveryServiceAssignment `protobuf:"bytes,20,opt,name=discovery_service_assignment,json=discoveryServiceAssignment,oneof"`
}
type Resource_Domain struct {
	Domain *Domain `protobuf:"bytes,21,opt,name=domain,oneof"`
}
type Resource_DsaRule struct {
	DsaRule *DsaRule `protobuf:"bytes,22,opt,name=dsa_rule,json=dsaRule,oneof"`
}
type Resource_E2ServiceProvider struct {
	E2ServiceProvider *E2ServiceProvider `protobuf:"bytes,23,opt,name=e2_service_provider,json=e2ServiceProvider,oneof"`
}
type Resource_FirewallPolicy struct {
	FirewallPolicy *FirewallPolicy `protobuf:"bytes,24,opt,name=firewall_policy,json=firewallPolicy,oneof"`
}
type Resource_FirewallRule struct {
	FirewallRule *FirewallRule `protobuf:"bytes,25,opt,name=firewall_rule,json=firewallRule,oneof"`
}
type Resource_FloatingIpPool struct {
	FloatingIpPool *FloatingIPPool `protobuf:"bytes,26,opt,name=floating_ip_pool,json=floatingIpPool,oneof"`
}
type Resource_FloatingIp struct {
	FloatingIp *FloatingIP `protobuf:"bytes,27,opt,name=floating_ip,json=floatingIp,oneof"`
}
type Resource_ForwardingClass struct {
	ForwardingClass *ForwardingClass `protobuf:"bytes,28,opt,name=forwarding_class,json=forwardingClass,oneof"`
}
type Resource_GlobalQosConfig struct {
	GlobalQosConfig *GlobalQosConfig `protobuf:"bytes,29,opt,name=global_qos_config,json=globalQosConfig,oneof"`
}
type Resource_GlobalSystemConfig struct {
	GlobalSystemConfig *GlobalSystemConfig `protobuf:"bytes,30,opt,name=global_system_config,json=globalSystemConfig,oneof"`
}
type Resource_GlobalVrouterConfig struct {
	GlobalVrouterConfig *GlobalVrouterConfig `protobuf:"bytes,31,opt,name=global_vrouter_config,json=globalVrouterConfig,oneof"`
}
type Resource_InstanceIp struct {
	InstanceIp *InstanceIP `protobuf:"bytes,32,opt,name=instance_ip,json=instanceIp,oneof"`
}
type Resource_InterfaceRouteTable struct {
	InterfaceRouteTable *InterfaceRouteTable `protobuf:"bytes,33,opt,name=interface_route_table,json=interfaceRouteTable,oneof"`
}
type Resource_LoadbalancerHealthmonitor struct {
	LoadbalancerHealthmonitor *LoadbalancerHealthmonitor `protobuf:"bytes,34,opt,name=loadbalancer_healthmonitor,json=loadbalancerHealthmonitor,oneof"`
}
type Resource_LoadbalancerListener struct {
	LoadbalancerListener *LoadbalancerListener `protobuf:"bytes,35,opt,name=loadbalancer_listener,json=loadbalancerListener,oneof"`
}
type Resource_LoadbalancerMember struct {
	LoadbalancerMember *LoadbalancerMember `protobuf:"bytes,36,opt,name=loadbalancer_member,json=loadbalancerMember,oneof"`
}
type Resource_LoadbalancerPool struct {
	LoadbalancerPool *LoadbalancerPool `protobuf:"bytes,37,opt,name=loadbalancer_pool,json=loadbalancerPool,oneof"`
}
type Resource_Loadbalancer struct {
	Loadbalancer *Loadbalancer `protobuf:"bytes,38,opt,name=loadbalancer,oneof"`
}
type Resource_LogicalInterface struct {
	LogicalInterface *LogicalInterface `protobuf:"bytes,39,opt,name=logical_interface,json=logicalInterface,oneof"`
}
type Resource_LogicalRouter struct {
	LogicalRouter *LogicalRouter `protobuf:"bytes,40,opt,name=logical_router,json=logicalRouter,oneof"`
}
type Resource_Namespace struct {
	Namespace *Namespace `protobuf:"bytes,41,opt,name=namespace,oneof"`
}
type Resource_NetworkDeviceConfig struct {
	NetworkDeviceConfig *NetworkDeviceConfig `protobuf:"bytes,42,opt,name=network_device_config,json=networkDeviceConfig,oneof"`
}
type Resource_NetworkIpam struct {
	NetworkIpam *NetworkIpam `protobuf:"bytes,43,opt,name=network_ipam,json=networkIpam,oneof"`
}
type Resource_NetworkPolicy struct {
	NetworkPolicy *NetworkPolicy `protobuf:"bytes,44,opt,name=network_policy,json=networkPolicy,oneof"`
}
type Resource_PeeringPolicy struct {
	PeeringPolicy *PeeringPolicy `protobuf:"bytes,45,opt,name=peering_policy,json=peeringPolicy,oneof"`
}
type Resource_PhysicalInterface struct {
	PhysicalInterface *PhysicalInterface `protobuf:"bytes,46,opt,name=physical_interface,json=physicalInterface,oneof"`
}
type Resource_PhysicalRouter struct {
	PhysicalRouter *PhysicalRouter `protobuf:"bytes,47,opt,name=physical_router,json=physicalRouter,oneof"`
}
type Resource_PolicyManagement struct {
	PolicyManagement *PolicyManagement `protobuf:"bytes,48,opt,name=policy_management,json=policyManagement,oneof"`
}
type Resource_PortTuple struct {
	PortTuple *PortTuple `protobuf:"bytes,49,opt,name=port_tuple,json=portTuple,oneof"`
}
type Resource_Project struct {
	Project *Project `protobuf:"bytes,50,opt,name=project,oneof"`
}
type Resource_ProviderAttachment struct {
	ProviderAttachment *ProviderAttachment `protobuf:"bytes,51,opt,name=provider_attachment,json=providerAttachment,oneof"`
}
type Resource_QosConfig struct {
	QosConfig *QosConfig `protobuf:"bytes,52,opt,name=qos_config,json=qosConfig,oneof"`
}
type Resource_QosQueue struct {
	QosQueue *QosQueue `protobuf:"bytes,53,opt,name=qos_queue,json=qosQueue,oneof"`
}
type Resource_RouteAggregate struct {
	RouteAggregate *RouteAggregate `protobuf:"bytes,54,opt,name=route_aggregate,json=routeAggregate,oneof"`
}
type Resource_RouteTable struct {
	RouteTable *RouteTable `protobuf:"bytes,55,opt,name=route_table,json=routeTable,oneof"`
}
type Resource_RouteTarget struct {
	RouteTarget *RouteTarget `protobuf:"bytes,56,opt,name=route_target,json=routeTarget,oneof"`
}
type Resource_RoutingInstance struct {
	RoutingInstance *RoutingInstance `protobuf:"bytes,57,opt,name=routing_instance,json=routingInstance,oneof"`
}
type Resource_RoutingPolicy struct {
	RoutingPolicy *RoutingPolicy `protobuf:"bytes,58,opt,name=routing_policy,json=routingPolicy,oneof"`
}
type Resource_SecurityGroup struct {
	SecurityGroup *SecurityGroup `protobuf:"bytes,59,opt,name=security_group,json=securityGroup,oneof"`
}
type Resource_SecurityLoggingObject struct {
	SecurityLoggingObject *SecurityLoggingObject `protobuf:"bytes,60,opt,name=security_logging_object,json=securityLoggingObject,oneof"`
}
type Resource_ServiceAppliance struct {
	ServiceAppliance *ServiceAppliance `protobuf:"bytes,61,opt,name=service_appliance,json=serviceAppliance,oneof"`
}
type Resource_ServiceApplianceSet struct {
	ServiceApplianceSet *ServiceApplianceSet `protobuf:"bytes,62,opt,name=service_appliance_set,json=serviceApplianceSet,oneof"`
}
type Resource_ServiceConnectionModule struct {
	ServiceConnectionModule *ServiceConnectionModule `protobuf:"bytes,63,opt,name=service_connection_module,json=serviceConnectionModule,oneof"`
}
type Resource_ServiceEndpoint struct {
	ServiceEndpoint *ServiceEndpoint `protobuf:"bytes,64,opt,name=service_endpoint,json=serviceEndpoint,oneof"`
}
type Resource_ServiceGroup struct {
	ServiceGroup *ServiceGroup `protobuf:"bytes,65,opt,name=service_group,json=serviceGroup,oneof"`
}
type Resource_ServiceHealthCheck struct {
	ServiceHealthCheck *ServiceHealthCheck `protobuf:"bytes,66,opt,name=service_health_check,json=serviceHealthCheck,oneof"`
}
type Resource_ServiceInstance struct {
	ServiceInstance *ServiceInstance `protobuf:"bytes,67,opt,name=service_instance,json=serviceInstance,oneof"`
}
type Resource_ServiceObject struct {
	ServiceObject *ServiceObject `protobuf:"bytes,68,opt,name=service_object,json=serviceObject,oneof"`
}
type Resource_ServiceTemplate struct {
	ServiceTemplate *ServiceTemplate `protobuf:"bytes,69,opt,name=service_template,json=serviceTemplate,oneof"`
}
type Resource_Subnet struct {
	Subnet *Subnet `protobuf:"bytes,70,opt,name=subnet,oneof"`
}
type Resource_Tag struct {
	Tag *Tag `protobuf:"bytes,71,opt,name=tag,oneof"`
}
type Resource_TagType struct {
	TagType *TagType `protobuf:"bytes,72,opt,name=tag_type,json=tagType,oneof"`
}
type Resource_User struct {
	User *User `protobuf:"bytes,73,opt,name=user,oneof"`
}
type Resource_Virtual_DNSRecord struct {
	Virtual_DNSRecord *VirtualDNSRecord `protobuf:"bytes,74,opt,name=virtual_DNS_record,json=virtualDNSRecord,oneof"`
}
type Resource_Virtual_DNS struct {
	Virtual_DNS *VirtualDNS `protobuf:"bytes,75,opt,name=virtual_DNS,json=virtualDNS,oneof"`
}
type Resource_VirtualIp struct {
	VirtualIp *VirtualIP `protobuf:"bytes,76,opt,name=virtual_ip,json=virtualIp,oneof"`
}
type Resource_VirtualMachineInterface struct {
	VirtualMachineInterface *VirtualMachineInterface `protobuf:"bytes,77,opt,name=virtual_machine_interface,json=virtualMachineInterface,oneof"`
}
type Resource_VirtualMachine struct {
	VirtualMachine *VirtualMachine `protobuf:"bytes,78,opt,name=virtual_machine,json=virtualMachine,oneof"`
}
type Resource_VirtualNetwork struct {
	VirtualNetwork *VirtualNetwork `protobuf:"bytes,79,opt,name=virtual_network,json=virtualNetwork,oneof"`
}
type Resource_VirtualRouter struct {
	VirtualRouter *VirtualRouter `protobuf:"bytes,80,opt,name=virtual_router,json=virtualRouter,oneof"`
}
type Resource_AppformixNodeRole struct {
	AppformixNodeRole *AppformixNodeRole `protobuf:"bytes,81,opt,name=appformix_node_role,json=appformixNodeRole,oneof"`
}
type Resource_BaremetalNode struct {
	BaremetalNode *BaremetalNode `protobuf:"bytes,82,opt,name=baremetal_node,json=baremetalNode,oneof"`
}
type Resource_BaremetalPort struct {
	BaremetalPort *BaremetalPort `protobuf:"bytes,83,opt,name=baremetal_port,json=baremetalPort,oneof"`
}
type Resource_ContrailAnalyticsDatabaseNodeRole struct {
	ContrailAnalyticsDatabaseNodeRole *ContrailAnalyticsDatabaseNodeRole `protobuf:"bytes,84,opt,name=contrail_analytics_database_node_role,json=contrailAnalyticsDatabaseNodeRole,oneof"`
}
type Resource_ContrailAnalyticsNode struct {
	ContrailAnalyticsNode *ContrailAnalyticsNode `protobuf:"bytes,85,opt,name=contrail_analytics_node,json=contrailAnalyticsNode,oneof"`
}
type Resource_ContrailCluster struct {
	ContrailCluster *ContrailCluster `protobuf:"bytes,86,opt,name=contrail_cluster,json=contrailCluster,oneof"`
}
type Resource_ContrailControllerNodeRole struct {
	ContrailControllerNodeRole *ContrailControllerNodeRole `protobuf:"bytes,87,opt,name=contrail_controller_node_role,json=contrailControllerNodeRole,oneof"`
}
type Resource_ControllerNodeRole struct {
	ControllerNodeRole *ControllerNodeRole `protobuf:"bytes,88,opt,name=controller_node_role,json=controllerNodeRole,oneof"`
}
type Resource_Dashboard struct {
	Dashboard *Dashboard `protobuf:"bytes,89,opt,name=dashboard,oneof"`
}
type Resource_Keypair struct {
	Keypair *Keypair `protobuf:"bytes,90,opt,name=keypair,oneof"`
}
type Resource_KubernetesCluster struct {
	KubernetesCluster *KubernetesCluster `protobuf:"bytes,91,opt,name=kubernetes_cluster,json=kubernetesCluster,oneof"`
}
type Resource_KubernetesNode struct {
	KubernetesNode *KubernetesNode `protobuf:"bytes,92,opt,name=kubernetes_node,json=kubernetesNode,oneof"`
}
type Resource_Location struct {
	Location *Location `protobuf:"bytes,93,opt,name=location,oneof"`
}
type Resource_Node struct {
	Node *Node `protobuf:"bytes,94,opt,name=node,oneof"`
}
type Resource_OpenstackCluster struct {
	OpenstackCluster *OpenstackCluster `protobuf:"bytes,95,opt,name=openstack_cluster,json=openstackCluster,oneof"`
}
type Resource_OpenstackComputeNodeRole struct {
	OpenstackComputeNodeRole *OpenstackComputeNodeRole `protobuf:"bytes,96,opt,name=openstack_compute_node_role,json=openstackComputeNodeRole,oneof"`
}
type Resource_OpenstackStorageNodeRole struct {
	OpenstackStorageNodeRole *OpenstackStorageNodeRole `protobuf:"bytes,97,opt,name=openstack_storage_node_role,json=openstackStorageNodeRole,oneof"`
}
type Resource_VpnGroup struct {
	VpnGroup *VPNGroup `protobuf:"bytes,98,opt,name=vpn_group,json=vpnGroup,oneof"`
}
type Resource_Widget struct {
	Widget *Widget `protobuf:"bytes,99,opt,name=widget,oneof"`
}

func (*Resource_AccessControlList) isResource_ResourceOneof()                 {}
func (*Resource_AddressGroup) isResource_ResourceOneof()                      {}
func (*Resource_Alarm) isResource_ResourceOneof()                             {}
func (*Resource_AliasIpPool) isResource_ResourceOneof()                       {}
func (*Resource_AliasIp) isResource_ResourceOneof()                           {}
func (*Resource_AnalyticsNode) isResource_ResourceOneof()                     {}
func (*Resource_ApiAccessList) isResource_ResourceOneof()                     {}
func (*Resource_ApplicationPolicySet) isResource_ResourceOneof()              {}
func (*Resource_BgpAsAService) isResource_ResourceOneof()                     {}
func (*Resource_BgpRouter) isResource_ResourceOneof()                         {}
func (*Resource_Bgpvpn) isResource_ResourceOneof()                            {}
func (*Resource_BridgeDomain) isResource_ResourceOneof()                      {}
func (*Resource_ConfigNode) isResource_ResourceOneof()                        {}
func (*Resource_ConfigRoot) isResource_ResourceOneof()                        {}
func (*Resource_CustomerAttachment) isResource_ResourceOneof()                {}
func (*Resource_DatabaseNode) isResource_ResourceOneof()                      {}
func (*Resource_DiscoveryServiceAssignment) isResource_ResourceOneof()        {}
func (*Resource_Domain) isResource_ResourceOneof()                            {}
func (*Resource_DsaRule) isResource_ResourceOneof()                           {}
func (*Resource_E2ServiceProvider) isResource_ResourceOneof()                 {}
func (*Resource_FirewallPolicy) isResource_ResourceOneof()                    {}
func (*Resource_FirewallRule) isResource_ResourceOneof()                      {}
func (*Resource_FloatingIpPool) isResource_ResourceOneof()                    {}
func (*Resource_FloatingIp) isResource_ResourceOneof()                        {}
func (*Resource_ForwardingClass) isResource_ResourceOneof()                   {}
func (*Resource_GlobalQosConfig) isResource_ResourceOneof()                   {}
func (*Resource_GlobalSystemConfig) isResource_ResourceOneof()                {}
func (*Resource_GlobalVrouterConfig) isResource_ResourceOneof()               {}
func (*Resource_InstanceIp) isResource_ResourceOneof()                        {}
func (*Resource_InterfaceRouteTable) isResource_ResourceOneof()               {}
func (*Resource_LoadbalancerHealthmonitor) isResource_ResourceOneof()         {}
func (*Resource_LoadbalancerListener) isResource_ResourceOneof()              {}
func (*Resource_LoadbalancerMember) isResource_ResourceOneof()                {}
func (*Resource_LoadbalancerPool) isResource_ResourceOneof()                  {}
func (*Resource_Loadbalancer) isResource_ResourceOneof()                      {}
func (*Resource_LogicalInterface) isResource_ResourceOneof()                  {}
func (*Resource_LogicalRouter) isResource_ResourceOneof()                     {}
func (*Resource_Namespace) isResource_ResourceOneof()                         {}
func (*Resource_NetworkDeviceConfig) isResource_ResourceOneof()               {}
func (*Resource_NetworkIpam) isResource_ResourceOneof()                       {}
func (*Resource_NetworkPolicy) isResource_ResourceOneof()                     {}
func (*Resource_PeeringPolicy) isResource_ResourceOneof()                     {}
func (*Resource_PhysicalInterface) isResource_ResourceOneof()                 {}
func (*Resource_PhysicalRouter) isResource_ResourceOneof()                    {}
func (*Resource_PolicyManagement) isResource_ResourceOneof()                  {}
func (*Resource_PortTuple) isResource_ResourceOneof()                         {}
func (*Resource_Project) isResource_ResourceOneof()                           {}
func (*Resource_ProviderAttachment) isResource_ResourceOneof()                {}
func (*Resource_QosConfig) isResource_ResourceOneof()                         {}
func (*Resource_QosQueue) isResource_ResourceOneof()                          {}
func (*Resource_RouteAggregate) isResource_ResourceOneof()                    {}
func (*Resource_RouteTable) isResource_ResourceOneof()                        {}
func (*Resource_RouteTarget) isResource_ResourceOneof()                       {}
func (*Resource_RoutingInstance) isResource_ResourceOneof()                   {}
func (*Resource_RoutingPolicy) isResource_ResourceOneof()                     {}
func (*Resource_SecurityGroup) isResource_ResourceOneof()                     {}
func (*Resource_SecurityLoggingObject) isResource_ResourceOneof()             {}
func (*Resource_ServiceAppliance) isResource_ResourceOneof()                  {}
func (*Resource_ServiceApplianceSet) isResource_ResourceOneof()               {}
func (*Resource_ServiceConnectionModule) isResource_ResourceOneof()           {}
func (*Resource_ServiceEndpoint) isResource_ResourceOneof()                   {}
func (*Resource_ServiceGroup) isResource_ResourceOneof()                      {}
func (*Resource_ServiceHealthCheck) isResource_ResourceOneof()                {}
func (*Resource_ServiceInstance) isResource_ResourceOneof()                   {}
func (*Resource_ServiceObject) isResource_ResourceOneof()                     {}
func (*Resource_ServiceTemplate) isResource_ResourceOneof()                   {}
func (*Resource_Subnet) isResource_ResourceOneof()                            {}
func (*Resource_Tag) isResource_ResourceOneof()                               {}
func (*Resource_TagType) isResource_ResourceOneof()                           {}
func (*Resource_User) isResource_ResourceOneof()                              {}
func (*Resource_Virtual_DNSRecord) isResource_ResourceOneof()                 {}
func (*Resource_Virtual_DNS) isResource_ResourceOneof()                       {}
func (*Resource_VirtualIp) isResource_ResourceOneof()                         {}
func (*Resource_VirtualMachineInterface) isResource_ResourceOneof()           {}
func (*Resource_VirtualMachine) isResource_ResourceOneof()                    {}
func (*Resource_VirtualNetwork) isResource_ResourceOneof()                    {}
func (*Resource_VirtualRouter) isResource_ResourceOneof()                     {}
func (*Resource_AppformixNodeRole) isResource_ResourceOneof()                 {}
func (*Resource_BaremetalNode) isResource_ResourceOneof()                     {}
func (*Resource_BaremetalPort) isResource_ResourceOneof()                     {}
func (*Resource_ContrailAnalyticsDatabaseNodeRole) isResource_ResourceOneof() {}
func (*Resource_ContrailAnalyticsNode) isResource_ResourceOneof()             {}
func (*Resource_ContrailCluster) isResource_ResourceOneof()                   {}
func (*Resource_ContrailControllerNodeRole) isResource_ResourceOneof()        {}
func (*Resource_ControllerNodeRole) isResource_ResourceOneof()                {}
func (*Resource_Dashboard) isResource_ResourceOneof()                         {}
func (*Resource_Keypair) isResource_ResourceOneof()                           {}
func (*Resource_KubernetesCluster) isResource_ResourceOneof()                 {}
func (*Resource_KubernetesNode) isResource_ResourceOneof()                    {}
func (*Resource_Location) isResource_ResourceOneof()                          {}
func (*Resource_Node) isResource_ResourceOneof()                              {}
func (*Resource_OpenstackCluster) isResource_ResourceOneof()                  {}
func (*Resource_OpenstackComputeNodeRole) isResource_ResourceOneof()          {}
func (*Resource_OpenstackStorageNodeRole) isResource_ResourceOneof()          {}
func (*Resource_VpnGroup) isResource_ResourceOneof()                          {}
func (*Resource_Widget) isResource_ResourceOneof()                            {}

func (m *Resource) GetResourceOneof() isResource_ResourceOneof {
	if m != nil {
		return m.ResourceOneof
	}
	return nil
}

func (m *Resource) GetAccessControlList() *AccessControlList {
	if x, ok := m.GetResourceOneof().(*Resource_AccessControlList); ok {
		return x.AccessControlList
	}
	return nil
}

func (m *Resource) GetAddressGroup() *AddressGroup {
	if x, ok := m.GetResourceOneof().(*Resource_AddressGroup); ok {
		return x.AddressGroup
	}
	return nil
}

func (m *Resource) GetAlarm() *Alarm {
	if x, ok := m.GetResourceOneof().(*Resource_Alarm); ok {
		return x.Alarm
	}
	return nil
}

func (m *Resource) GetAliasIpPool() *AliasIPPool {
	if x, ok := m.GetResourceOneof().(*Resource_AliasIpPool); ok {
		return x.AliasIpPool
	}
	return nil
}

func (m *Resource) GetAliasIp() *AliasIP {
	if x, ok := m.GetResourceOneof().(*Resource_AliasIp); ok {
		return x.AliasIp
	}
	return nil
}

func (m *Resource) GetAnalyticsNode() *AnalyticsNode {
	if x, ok := m.GetResourceOneof().(*Resource_AnalyticsNode); ok {
		return x.AnalyticsNode
	}
	return nil
}

func (m *Resource) GetApiAccessList() *APIAccessList {
	if x, ok := m.GetResourceOneof().(*Resource_ApiAccessList); ok {
		return x.ApiAccessList
	}
	return nil
}

func (m *Resource) GetApplicationPolicySet() *ApplicationPolicySet {
	if x, ok := m.GetResourceOneof().(*Resource_ApplicationPolicySet); ok {
		return x.ApplicationPolicySet
	}
	return nil
}

func (m *Resource) GetBgpAsAService() *BGPAsAService {
	if x, ok := m.GetResourceOneof().(*Resource_BgpAsAService); ok {
		return x.BgpAsAService
	}
	return nil
}

func (m *Resource) GetBgpRouter() *BGPRouter {
	if x, ok := m.GetResourceOneof().(*Resource_BgpRouter); ok {
		return x.BgpRouter
	}
	return nil
}

func (m *Resource) GetBgpvpn() *BGPVPN {
	if x, ok := m.GetResourceOneof().(*Resource_Bgpvpn); ok {
		return x.Bgpvpn
	}
	return nil
}

func (m *Resource) GetBridgeDomain() *BridgeDomain {
	if x, ok := m.GetResourceOneof().(*Resource_BridgeDomain); ok {
		return x.BridgeDomain
	}
	return nil
}

func (m *Resource) GetConfigNode() *ConfigNode {
	if x, ok := m.GetResourceOneof().(*Resource_ConfigNode); ok {
		return x.ConfigNode
	}
	return nil
}

func (m *Resource) GetConfigRoot() *ConfigRoot {
	if x, ok := m.GetResourceOneof().(*Resource_ConfigRoot); ok {
		return x.ConfigRoot
	}
	return nil
}

func (m *Resource) GetCustomerAttachment() *CustomerAttachment {
	if x, ok := m.GetResourceOneof().(*Resource_CustomerAttachment); ok {
		return x.CustomerAttachment
	}
	return nil
}

func (m *Resource) GetDatabaseNode() *DatabaseNode {
	if x, ok := m.GetResourceOneof().(*Resource_DatabaseNode); ok {
		return x.DatabaseNode
	}
	return nil
}

func (m *Resource) GetDiscoveryServiceAssignment() *DiscoveryServiceAssignment {
	if x, ok := m.GetResourceOneof().(*Resource_DiscoveryServiceAssignment); ok {
		return x.DiscoveryServiceAssignment
	}
	return nil
}

func (m *Resource) GetDomain() *Domain {
	if x, ok := m.GetResourceOneof().(*Resource_Domain); ok {
		return x.Domain
	}
	return nil
}

func (m *Resource) GetDsaRule() *DsaRule {
	if x, ok := m.GetResourceOneof().(*Resource_DsaRule); ok {
		return x.DsaRule
	}
	return nil
}

func (m *Resource) GetE2ServiceProvider() *E2ServiceProvider {
	if x, ok := m.GetResourceOneof().(*Resource_E2ServiceProvider); ok {
		return x.E2ServiceProvider
	}
	return nil
}

func (m *Resource) GetFirewallPolicy() *FirewallPolicy {
	if x, ok := m.GetResourceOneof().(*Resource_FirewallPolicy); ok {
		return x.FirewallPolicy
	}
	return nil
}

func (m *Resource) GetFirewallRule() *FirewallRule {
	if x, ok := m.GetResourceOneof().(*Resource_FirewallRule); ok {
		return x.FirewallRule
	}
	return nil
}

func (m *Resource) GetFloatingIpPool() *FloatingIPPool {
	if x, ok := m.GetResourceOneof().(*Resource_FloatingIpPool); ok {
		return x.FloatingIpPool
	}
	return nil
}

func (m *Resource) GetFloatingIp() *FloatingIP {
	if x, ok := m.GetResourceOneof().(*Resource_FloatingIp); ok {
		return x.FloatingIp
	}
	return nil
}

func (m *Resource) GetForwardingClass() *ForwardingClass {
	if x, ok := m.GetResourceOneof().(*Resource_ForwardingClass); ok {
		return x.ForwardingClass
	}
	return nil
}

func (m *Resource) GetGlobalQosConfig() *GlobalQosConfig {
	if x, ok := m.GetResourceOneof().(*Resource_GlobalQosConfig); ok {
		return x.GlobalQosConfig
	}
	return nil
}

func (m *Resource) GetGlobalSystemConfig() *GlobalSystemConfig {
	if x, ok := m.GetResourceOneof().(*Resource_GlobalSystemConfig); ok {
		return x.GlobalSystemConfig
	}
	return nil
}

func (m *Resource) GetGlobalVrouterConfig() *GlobalVrouterConfig {
	if x, ok := m.GetResourceOneof().(*Resource_GlobalVrouterConfig); ok {
		return x.GlobalVrouterConfig
	}
	return nil
}

func (m *Resource) GetInstanceIp() *InstanceIP {
	if x, ok := m.GetResourceOneof().(*Resource_InstanceIp); ok {
		return x.InstanceIp
	}
	return nil
}

func (m *Resource) GetInterfaceRouteTable() *InterfaceRouteTable {
	if x, ok := m.GetResourceOneof().(*Resource_InterfaceRouteTable); ok {
		return x.InterfaceRouteTable
	}
	return nil
}

func (m *Resource) GetLoadbalancerHealthmonitor() *LoadbalancerHealthmonitor {
	if x, ok := m.GetResourceOneof().(*Resource_LoadbalancerHealthmonitor); ok {
		return x.LoadbalancerHealthmonitor
	}
	return nil
}

func (m *Resource) GetLoadbalancerListener() *LoadbalancerListener {
	if x, ok := m.GetResourceOneof().(*Resource_LoadbalancerListener); ok {
		return x.LoadbalancerListener
	}
	return nil
}

func (m *Resource) GetLoadbalancerMember() *LoadbalancerMember {
	if x, ok := m.GetResourceOneof().(*Resource_LoadbalancerMember); ok {
		return x.LoadbalancerMember
	}
	return nil
}

func (m *Resource) GetLoadbalancerPool() *LoadbalancerPool {
	if x, ok := m.GetResourceOneof().(*Resource_LoadbalancerPool); ok {
		return x.LoadbalancerPool
	}
	return nil
}

func (m *Resource) GetLoadbalancer() *Loadbalancer {
	if x, ok := m.GetResourceOneof().(*Resource_Loadbalancer); ok {
		return x.Loadbalancer
	}
	return nil
}

func (m *Resource) GetLogicalInterface() *LogicalInterface {
	if x, ok := m.GetResourceOneof().(*Resource_LogicalInterface); ok {
		return x.LogicalInterface
	}
	return nil
}

func (m *Resource) GetLogicalRouter() *LogicalRouter {
	if x, ok := m.GetResourceOneof().(*Resource_LogicalRouter); ok {
		return x.LogicalRouter
	}
	return nil
}

func (m *Resource) GetNamespace() *Namespace {
	if x, ok := m.GetResourceOneof().(*Resource_Namespace); ok {
		return x.Namespace
	}
	return nil
}

func (m *Resource) GetNetworkDeviceConfig() *NetworkDeviceConfig {
	if x, ok := m.GetResourceOneof().(*Resource_NetworkDeviceConfig); ok {
		return x.NetworkDeviceConfig
	}
	return nil
}

func (m *Resource) GetNetworkIpam() *NetworkIpam {
	if x, ok := m.GetResourceOneof().(*Resource_NetworkIpam); ok {
		return x.NetworkIpam
	}
	return nil
}

func (m *Resource) GetNetworkPolicy() *NetworkPolicy {
	if x, ok := m.GetResourceOneof().(*Resource_NetworkPolicy); ok {
		return x.NetworkPolicy
	}
	return nil
}

func (m *Resource) GetPeeringPolicy() *PeeringPolicy {
	if x, ok := m.GetResourceOneof().(*Resource_PeeringPolicy); ok {
		return x.PeeringPolicy
	}
	return nil
}

func (m *Resource) GetPhysicalInterface() *PhysicalInterface {
	if x, ok := m.GetResourceOneof().(*Resource_PhysicalInterface); ok {
		return x.PhysicalInterface
	}
	return nil
}

func (m *Resource) GetPhysicalRouter() *PhysicalRouter {
	if x, ok := m.GetResourceOneof().(*Resource_PhysicalRouter); ok {
		return x.PhysicalRouter
	}
	return nil
}

func (m *Resource) GetPolicyManagement() *PolicyManagement {
	if x, ok := m.GetResourceOneof().(*Resource_PolicyManagement); ok {
		return x.PolicyManagement
	}
	return nil
}

func (m *Resource) GetPortTuple() *PortTuple {
	if x, ok := m.GetResourceOneof().(*Resource_PortTuple); ok {
		return x.PortTuple
	}
	return nil
}

func (m *Resource) GetProject() *Project {
	if x, ok := m.GetResourceOneof().(*Resource_Project); ok {
		return x.Project
	}
	return nil
}

func (m *Resource) GetProviderAttachment() *ProviderAttachment {
	if x, ok := m.GetResourceOneof().(*Resource_ProviderAttachment); ok {
		return x.ProviderAttachment
	}
	return nil
}

func (m *Resource) GetQosConfig() *QosConfig {
	if x, ok := m.GetResourceOneof().(*Resource_QosConfig); ok {
		return x.QosConfig
	}
	return nil
}

func (m *Resource) GetQosQueue() *QosQueue {
	if x, ok := m.GetResourceOneof().(*Resource_QosQueue); ok {
		return x.QosQueue
	}
	return nil
}

func (m *Resource) GetRouteAggregate() *RouteAggregate {
	if x, ok := m.GetResourceOneof().(*Resource_RouteAggregate); ok {
		return x.RouteAggregate
	}
	return nil
}

func (m *Resource) GetRouteTable() *RouteTable {
	if x, ok := m.GetResourceOneof().(*Resource_RouteTable); ok {
		return x.RouteTable
	}
	return nil
}

func (m *Resource) GetRouteTarget() *RouteTarget {
	if x, ok := m.GetResourceOneof().(*Resource_RouteTarget); ok {
		return x.RouteTarget
	}
	return nil
}

func (m *Resource) GetRoutingInstance() *RoutingInstance {
	if x, ok := m.GetResourceOneof().(*Resource_RoutingInstance); ok {
		return x.RoutingInstance
	}
	return nil
}

func (m *Resource) GetRoutingPolicy() *RoutingPolicy {
	if x, ok := m.GetResourceOneof().(*Resource_RoutingPolicy); ok {
		return x.RoutingPolicy
	}
	return nil
}

func (m *Resource) GetSecurityGroup() *SecurityGroup {
	if x, ok := m.GetResourceOneof().(*Resource_SecurityGroup); ok {
		return x.SecurityGroup
	}
	return nil
}

func (m *Resource) GetSecurityLoggingObject() *SecurityLoggingObject {
	if x, ok := m.GetResourceOneof().(*Resource_SecurityLoggingObject); ok {
		return x.SecurityLoggingObject
	}
	return nil
}

func (m *Resource) GetServiceAppliance() *ServiceAppliance {
	if x, ok := m.GetResourceOneof().(*Resource_ServiceAppliance); ok {
		return x.ServiceAppliance
	}
	return nil
}

func (m *Resource) GetServiceApplianceSet() *ServiceApplianceSet {
	if x, ok := m.GetResourceOneof().(*Resource_ServiceApplianceSet); ok {
		return x.ServiceApplianceSet
	}
	return nil
}

func (m *Resource) GetServiceConnectionModule() *ServiceConnectionModule {
	if x, ok := m.GetResourceOneof().(*Resource_ServiceConnectionModule); ok {
		return x.ServiceConnectionModule
	}
	return nil
}

func (m *Resource) GetServiceEndpoint() *ServiceEndpoint {
	if x, ok := m.GetResourceOneof().(*Resource_ServiceEndpoint); ok {
		return x.ServiceEndpoint
	}
	return nil
}

func (m *Resource) GetServiceGroup() *ServiceGroup {
	if x, ok := m.GetResourceOneof().(*Resource_ServiceGroup); ok {
		return x.ServiceGroup
	}
	return nil
}

func (m *Resource) GetServiceHealthCheck() *ServiceHealthCheck {
	if x, ok := m.GetResourceOneof().(*Resource_ServiceHealthCheck); ok {
		return x.ServiceHealthCheck
	}
	return nil
}

func (m *Resource) GetServiceInstance() *ServiceInstance {
	if x, ok := m.GetResourceOneof().(*Resource_ServiceInstance); ok {
		return x.ServiceInstance
	}
	return nil
}

func (m *Resource) GetServiceObject() *ServiceObject {
	if x, ok := m.GetResourceOneof().(*Resource_ServiceObject); ok {
		return x.ServiceObject
	}
	return nil
}

func (m *Resource) GetServiceTemplate() *ServiceTemplate {
	if x, ok := m.GetResourceOneof().(*Resource_ServiceTemplate); ok {
		return x.ServiceTemplate
	}
	return nil
}

func (m *Resource) GetSubnet() *Subnet {
	if x, ok := m.GetResourceOneof().(*Resource_Subnet); ok {
		return x.Subnet
	}
	return nil
}

func (m *Resource) GetTag() *Tag {
	if x, ok := m.GetResourceOneof().(*Resource_Tag); ok {
		return x.Tag
	}
	return nil
}

func (m *Resource) GetTagType() *TagType {
	if x, ok := m.GetResourceOneof().(*Resource_TagType); ok {
		return x.TagType
	}
	return nil
}

func (m *Resource) GetUser() *User {
	if x, ok := m.GetResourceOneof().(*Resource_User); ok {
		return x.User
	}
	return nil
}

func (m *Resource) GetVirtual_DNSRecord() *VirtualDNSRecord {
	if x, ok := m.GetResourceOneof().(*Resource_Virtual_DNSRecord); ok {
		return x.Virtual_DNSRecord
	}
	return nil
}

func (m *Resource) GetVirtual_DNS() *VirtualDNS {
	if x, ok := m.GetResourceOneof().(*Resource_Virtual_DNS); ok {
		return x.Virtual_DNS
	}
	return nil
}

func (m *Resource) GetVirtualIp() *VirtualIP {
	if x, ok := m.GetResourceOneof().(*Resource_VirtualIp); ok {
		return x.VirtualIp
	}
	return nil
}

func (m *Resource) GetVirtualMachineInterface() *VirtualMachineInterface {
	if x, ok := m.GetResourceOneof().(*Resource_VirtualMachineInterface); ok {
		return x.VirtualMachineInterface
	}
	return nil
}

func (m *Resource) GetVirtualMachine() *VirtualMachine {
	if x, ok := m.GetResourceOneof().(*Resource_VirtualMachine); ok {
		return x.VirtualMachine
	}
	return nil
}

func (m *Resource) GetVirtualNetwork() *VirtualNetwork {
	if x, ok := m.GetResourceOneof().(*Resource_VirtualNetwork); ok {
		return x.VirtualNetwork
	}
	return nil
}

func (m *Resource) GetVirtualRouter() *VirtualRouter {
	if x, ok := m.GetResourceOneof().(*Resource_VirtualRouter); ok {
		return x.VirtualRouter
	}
	return nil
}

func (m *Resource) GetAppformixNodeRole() *AppformixNodeRole {
	if x, ok := m.GetResourceOneof().(*Resource_AppformixNodeRole); ok {
		return x.AppformixNodeRole
	}
	return nil
}

func (m *Resource) GetBaremetalNode() *BaremetalNode {
	if x, ok := m.GetResourceOneof().(*Resource_BaremetalNode); ok {
		return x.BaremetalNode
	}
	return nil
}

func (m *Resource) GetBaremetalPort() *BaremetalPort {
	if x, ok := m.GetResourceOneof().(*Resource_BaremetalPort); ok {
		return x.BaremetalPort
	}
	return nil
}

func (m *Resource) GetContrailAnalyticsDatabaseNodeRole() *ContrailAnalyticsDatabaseNodeRole {
	if x, ok := m.GetResourceOneof().(*Resource_ContrailAnalyticsDatabaseNodeRole); ok {
		return x.ContrailAnalyticsDatabaseNodeRole
	}
	return nil
}

func (m *Resource) GetContrailAnalyticsNode() *ContrailAnalyticsNode {
	if x, ok := m.GetResourceOneof().(*Resource_ContrailAnalyticsNode); ok {
		return x.ContrailAnalyticsNode
	}
	return nil
}

func (m *Resource) GetContrailCluster() *ContrailCluster {
	if x, ok := m.GetResourceOneof().(*Resource_ContrailCluster); ok {
		return x.ContrailCluster
	}
	return nil
}

func (m *Resource) GetContrailControllerNodeRole() *ContrailControllerNodeRole {
	if x, ok := m.GetResourceOneof().(*Resource_ContrailControllerNodeRole); ok {
		return x.ContrailControllerNodeRole
	}
	return nil
}

func (m *Resource) GetControllerNodeRole() *ControllerNodeRole {
	if x, ok := m.GetResourceOneof().(*Resource_ControllerNodeRole); ok {
		return x.ControllerNodeRole
	}
	return nil
}

func (m *Resource) GetDashboard() *Dashboard {
	if x, ok := m.GetResourceOneof().(*Resource_Dashboard); ok {
		return x.Dashboard
	}
	return nil
}

func (m *Resource) GetKeypair() *Keypair {
	if x, ok := m.GetResourceOneof().(*Resource_Keypair); ok {
		return x.Keypair
	}
	return nil
}

func (m *Resource) GetKubernetesCluster() *KubernetesCluster {
	if x, ok := m.GetResourceOneof().(*Resource_KubernetesCluster); ok {
		return x.KubernetesCluster
	}
	return nil
}

func (m *Resource) GetKubernetesNode() *KubernetesNode {
	if x, ok := m.GetResourceOneof().(*Resource_KubernetesNode); ok {
		return x.KubernetesNode
	}
	return nil
}

func (m *Resource) GetLocation() *Location {
	if x, ok := m.GetResourceOneof().(*Resource_Location); ok {
		return x.Location
	}
	return nil
}

func (m *Resource) GetNode() *Node {
	if x, ok := m.GetResourceOneof().(*Resource_Node); ok {
		return x.Node
	}
	return nil
}

func (m *Resource) GetOpenstackCluster() *OpenstackCluster {
	if x, ok := m.GetResourceOneof().(*Resource_OpenstackCluster); ok {
		return x.OpenstackCluster
	}
	return nil
}

func (m *Resource) GetOpenstackComputeNodeRole() *OpenstackComputeNodeRole {
	if x, ok := m.GetResourceOneof().(*Resource_OpenstackComputeNodeRole); ok {
		return x.OpenstackComputeNodeRole
	}
	return nil
}

func (m *Resource) GetOpenstackStorageNodeRole() *OpenstackStorageNodeRole {
	if x, ok := m.GetResourceOneof().(*Resource_OpenstackStorageNodeRole); ok {
		return x.OpenstackStorageNodeRole
	}
	return nil
}

func (m *Resource) GetVpnGroup() *VPNGroup {
	if x, ok := m.GetResourceOneof().(*Resource_VpnGroup); ok {
		return x.VpnGroup
	}
	return nil
}

func (m *Resource) GetWidget() *Widget {
	if x, ok := m.GetResourceOneof().(*Resource_Widget); ok {
		return x.Widget
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Resource) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Resource_OneofMarshaler, _Resource_OneofUnmarshaler, _Resource_OneofSizer, []interface{}{
		(*Resource_AccessControlList)(nil),
		(*Resource_AddressGroup)(nil),
		(*Resource_Alarm)(nil),
		(*Resource_AliasIpPool)(nil),
		(*Resource_AliasIp)(nil),
		(*Resource_AnalyticsNode)(nil),
		(*Resource_ApiAccessList)(nil),
		(*Resource_ApplicationPolicySet)(nil),
		(*Resource_BgpAsAService)(nil),
		(*Resource_BgpRouter)(nil),
		(*Resource_Bgpvpn)(nil),
		(*Resource_BridgeDomain)(nil),
		(*Resource_ConfigNode)(nil),
		(*Resource_ConfigRoot)(nil),
		(*Resource_CustomerAttachment)(nil),
		(*Resource_DatabaseNode)(nil),
		(*Resource_DiscoveryServiceAssignment)(nil),
		(*Resource_Domain)(nil),
		(*Resource_DsaRule)(nil),
		(*Resource_E2ServiceProvider)(nil),
		(*Resource_FirewallPolicy)(nil),
		(*Resource_FirewallRule)(nil),
		(*Resource_FloatingIpPool)(nil),
		(*Resource_FloatingIp)(nil),
		(*Resource_ForwardingClass)(nil),
		(*Resource_GlobalQosConfig)(nil),
		(*Resource_GlobalSystemConfig)(nil),
		(*Resource_GlobalVrouterConfig)(nil),
		(*Resource_InstanceIp)(nil),
		(*Resource_InterfaceRouteTable)(nil),
		(*Resource_LoadbalancerHealthmonitor)(nil),
		(*Resource_LoadbalancerListener)(nil),
		(*Resource_LoadbalancerMember)(nil),
		(*Resource_LoadbalancerPool)(nil),
		(*Resource_Loadbalancer)(nil),
		(*Resource_LogicalInterface)(nil),
		(*Resource_LogicalRouter)(nil),
		(*Resource_Namespace)(nil),
		(*Resource_NetworkDeviceConfig)(nil),
		(*Resource_NetworkIpam)(nil),
		(*Resource_NetworkPolicy)(nil),
		(*Resource_PeeringPolicy)(nil),
		(*Resource_PhysicalInterface)(nil),
		(*Resource_PhysicalRouter)(nil),
		(*Resource_PolicyManagement)(nil),
		(*Resource_PortTuple)(nil),
		(*Resource_Project)(nil),
		(*Resource_ProviderAttachment)(nil),
		(*Resource_QosConfig)(nil),
		(*Resource_QosQueue)(nil),
		(*Resource_RouteAggregate)(nil),
		(*Resource_RouteTable)(nil),
		(*Resource_RouteTarget)(nil),
		(*Resource_RoutingInstance)(nil),
		(*Resource_RoutingPolicy)(nil),
		(*Resource_SecurityGroup)(nil),
		(*Resource_SecurityLoggingObject)(nil),
		(*Resource_ServiceAppliance)(nil),
		(*Resource_ServiceApplianceSet)(nil),
		(*Resource_ServiceConnectionModule)(nil),
		(*Resource_ServiceEndpoint)(nil),
		(*Resource_ServiceGroup)(nil),
		(*Resource_ServiceHealthCheck)(nil),
		(*Resource_ServiceInstance)(nil),
		(*Resource_ServiceObject)(nil),
		(*Resource_ServiceTemplate)(nil),
		(*Resource_Subnet)(nil),
		(*Resource_Tag)(nil),
		(*Resource_TagType)(nil),
		(*Resource_User)(nil),
		(*Resource_Virtual_DNSRecord)(nil),
		(*Resource_Virtual_DNS)(nil),
		(*Resource_VirtualIp)(nil),
		(*Resource_VirtualMachineInterface)(nil),
		(*Resource_VirtualMachine)(nil),
		(*Resource_VirtualNetwork)(nil),
		(*Resource_VirtualRouter)(nil),
		(*Resource_AppformixNodeRole)(nil),
		(*Resource_BaremetalNode)(nil),
		(*Resource_BaremetalPort)(nil),
		(*Resource_ContrailAnalyticsDatabaseNodeRole)(nil),
		(*Resource_ContrailAnalyticsNode)(nil),
		(*Resource_ContrailCluster)(nil),
		(*Resource_ContrailControllerNodeRole)(nil),
		(*Resource_ControllerNodeRole)(nil),
		(*Resource_Dashboard)(nil),
		(*Resource_Keypair)(nil),
		(*Resource_KubernetesCluster)(nil),
		(*Resource_KubernetesNode)(nil),
		(*Resource_Location)(nil),
		(*Resource_Node)(nil),
		(*Resource_OpenstackCluster)(nil),
		(*Resource_OpenstackComputeNodeRole)(nil),
		(*Resource_OpenstackStorageNodeRole)(nil),
		(*Resource_VpnGroup)(nil),
		(*Resource_Widget)(nil),
	}
}

func _Resource_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Resource)
	// resource_oneof
	switch x := m.ResourceOneof.(type) {
	case *Resource_AccessControlList:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AccessControlList); err != nil {
			return err
		}
	case *Resource_AddressGroup:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddressGroup); err != nil {
			return err
		}
	case *Resource_Alarm:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Alarm); err != nil {
			return err
		}
	case *Resource_AliasIpPool:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AliasIpPool); err != nil {
			return err
		}
	case *Resource_AliasIp:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AliasIp); err != nil {
			return err
		}
	case *Resource_AnalyticsNode:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnalyticsNode); err != nil {
			return err
		}
	case *Resource_ApiAccessList:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApiAccessList); err != nil {
			return err
		}
	case *Resource_ApplicationPolicySet:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApplicationPolicySet); err != nil {
			return err
		}
	case *Resource_BgpAsAService:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BgpAsAService); err != nil {
			return err
		}
	case *Resource_BgpRouter:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BgpRouter); err != nil {
			return err
		}
	case *Resource_Bgpvpn:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bgpvpn); err != nil {
			return err
		}
	case *Resource_BridgeDomain:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BridgeDomain); err != nil {
			return err
		}
	case *Resource_ConfigNode:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConfigNode); err != nil {
			return err
		}
	case *Resource_ConfigRoot:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConfigRoot); err != nil {
			return err
		}
	case *Resource_CustomerAttachment:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomerAttachment); err != nil {
			return err
		}
	case *Resource_DatabaseNode:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DatabaseNode); err != nil {
			return err
		}
	case *Resource_DiscoveryServiceAssignment:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DiscoveryServiceAssignment); err != nil {
			return err
		}
	case *Resource_Domain:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Domain); err != nil {
			return err
		}
	case *Resource_DsaRule:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DsaRule); err != nil {
			return err
		}
	case *Resource_E2ServiceProvider:
		_ = b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.E2ServiceProvider); err != nil {
			return err
		}
	case *Resource_FirewallPolicy:
		_ = b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FirewallPolicy); err != nil {
			return err
		}
	case *Resource_FirewallRule:
		_ = b.EncodeVarint(25<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FirewallRule); err != nil {
			return err
		}
	case *Resource_FloatingIpPool:
		_ = b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FloatingIpPool); err != nil {
			return err
		}
	case *Resource_FloatingIp:
		_ = b.EncodeVarint(27<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FloatingIp); err != nil {
			return err
		}
	case *Resource_ForwardingClass:
		_ = b.EncodeVarint(28<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ForwardingClass); err != nil {
			return err
		}
	case *Resource_GlobalQosConfig:
		_ = b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GlobalQosConfig); err != nil {
			return err
		}
	case *Resource_GlobalSystemConfig:
		_ = b.EncodeVarint(30<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GlobalSystemConfig); err != nil {
			return err
		}
	case *Resource_GlobalVrouterConfig:
		_ = b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GlobalVrouterConfig); err != nil {
			return err
		}
	case *Resource_InstanceIp:
		_ = b.EncodeVarint(32<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InstanceIp); err != nil {
			return err
		}
	case *Resource_InterfaceRouteTable:
		_ = b.EncodeVarint(33<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InterfaceRouteTable); err != nil {
			return err
		}
	case *Resource_LoadbalancerHealthmonitor:
		_ = b.EncodeVarint(34<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadbalancerHealthmonitor); err != nil {
			return err
		}
	case *Resource_LoadbalancerListener:
		_ = b.EncodeVarint(35<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadbalancerListener); err != nil {
			return err
		}
	case *Resource_LoadbalancerMember:
		_ = b.EncodeVarint(36<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadbalancerMember); err != nil {
			return err
		}
	case *Resource_LoadbalancerPool:
		_ = b.EncodeVarint(37<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadbalancerPool); err != nil {
			return err
		}
	case *Resource_Loadbalancer:
		_ = b.EncodeVarint(38<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Loadbalancer); err != nil {
			return err
		}
	case *Resource_LogicalInterface:
		_ = b.EncodeVarint(39<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogicalInterface); err != nil {
			return err
		}
	case *Resource_LogicalRouter:
		_ = b.EncodeVarint(40<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogicalRouter); err != nil {
			return err
		}
	case *Resource_Namespace:
		_ = b.EncodeVarint(41<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Namespace); err != nil {
			return err
		}
	case *Resource_NetworkDeviceConfig:
		_ = b.EncodeVarint(42<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetworkDeviceConfig); err != nil {
			return err
		}
	case *Resource_NetworkIpam:
		_ = b.EncodeVarint(43<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetworkIpam); err != nil {
			return err
		}
	case *Resource_NetworkPolicy:
		_ = b.EncodeVarint(44<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetworkPolicy); err != nil {
			return err
		}
	case *Resource_PeeringPolicy:
		_ = b.EncodeVarint(45<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PeeringPolicy); err != nil {
			return err
		}
	case *Resource_PhysicalInterface:
		_ = b.EncodeVarint(46<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PhysicalInterface); err != nil {
			return err
		}
	case *Resource_PhysicalRouter:
		_ = b.EncodeVarint(47<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PhysicalRouter); err != nil {
			return err
		}
	case *Resource_PolicyManagement:
		_ = b.EncodeVarint(48<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PolicyManagement); err != nil {
			return err
		}
	case *Resource_PortTuple:
		_ = b.EncodeVarint(49<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PortTuple); err != nil {
			return err
		}
	case *Resource_Project:
		_ = b.EncodeVarint(50<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Project); err != nil {
			return err
		}
	case *Resource_ProviderAttachment:
		_ = b.EncodeVarint(51<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProviderAttachment); err != nil {
			return err
		}
	case *Resource_QosConfig:
		_ = b.EncodeVarint(52<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.QosConfig); err != nil {
			return err
		}
	case *Resource_QosQueue:
		_ = b.EncodeVarint(53<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.QosQueue); err != nil {
			return err
		}
	case *Resource_RouteAggregate:
		_ = b.EncodeVarint(54<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteAggregate); err != nil {
			return err
		}
	case *Resource_RouteTable:
		_ = b.EncodeVarint(55<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteTable); err != nil {
			return err
		}
	case *Resource_RouteTarget:
		_ = b.EncodeVarint(56<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteTarget); err != nil {
			return err
		}
	case *Resource_RoutingInstance:
		_ = b.EncodeVarint(57<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RoutingInstance); err != nil {
			return err
		}
	case *Resource_RoutingPolicy:
		_ = b.EncodeVarint(58<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RoutingPolicy); err != nil {
			return err
		}
	case *Resource_SecurityGroup:
		_ = b.EncodeVarint(59<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SecurityGroup); err != nil {
			return err
		}
	case *Resource_SecurityLoggingObject:
		_ = b.EncodeVarint(60<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SecurityLoggingObject); err != nil {
			return err
		}
	case *Resource_ServiceAppliance:
		_ = b.EncodeVarint(61<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceAppliance); err != nil {
			return err
		}
	case *Resource_ServiceApplianceSet:
		_ = b.EncodeVarint(62<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceApplianceSet); err != nil {
			return err
		}
	case *Resource_ServiceConnectionModule:
		_ = b.EncodeVarint(63<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceConnectionModule); err != nil {
			return err
		}
	case *Resource_ServiceEndpoint:
		_ = b.EncodeVarint(64<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceEndpoint); err != nil {
			return err
		}
	case *Resource_ServiceGroup:
		_ = b.EncodeVarint(65<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceGroup); err != nil {
			return err
		}
	case *Resource_ServiceHealthCheck:
		_ = b.EncodeVarint(66<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceHealthCheck); err != nil {
			return err
		}
	case *Resource_ServiceInstance:
		_ = b.EncodeVarint(67<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceInstance); err != nil {
			return err
		}
	case *Resource_ServiceObject:
		_ = b.EncodeVarint(68<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceObject); err != nil {
			return err
		}
	case *Resource_ServiceTemplate:
		_ = b.EncodeVarint(69<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ServiceTemplate); err != nil {
			return err
		}
	case *Resource_Subnet:
		_ = b.EncodeVarint(70<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subnet); err != nil {
			return err
		}
	case *Resource_Tag:
		_ = b.EncodeVarint(71<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Tag); err != nil {
			return err
		}
	case *Resource_TagType:
		_ = b.EncodeVarint(72<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TagType); err != nil {
			return err
		}
	case *Resource_User:
		_ = b.EncodeVarint(73<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.User); err != nil {
			return err
		}
	case *Resource_Virtual_DNSRecord:
		_ = b.EncodeVarint(74<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Virtual_DNSRecord); err != nil {
			return err
		}
	case *Resource_Virtual_DNS:
		_ = b.EncodeVarint(75<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Virtual_DNS); err != nil {
			return err
		}
	case *Resource_VirtualIp:
		_ = b.EncodeVarint(76<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualIp); err != nil {
			return err
		}
	case *Resource_VirtualMachineInterface:
		_ = b.EncodeVarint(77<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualMachineInterface); err != nil {
			return err
		}
	case *Resource_VirtualMachine:
		_ = b.EncodeVarint(78<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualMachine); err != nil {
			return err
		}
	case *Resource_VirtualNetwork:
		_ = b.EncodeVarint(79<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualNetwork); err != nil {
			return err
		}
	case *Resource_VirtualRouter:
		_ = b.EncodeVarint(80<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VirtualRouter); err != nil {
			return err
		}
	case *Resource_AppformixNodeRole:
		_ = b.EncodeVarint(81<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AppformixNodeRole); err != nil {
			return err
		}
	case *Resource_BaremetalNode:
		_ = b.EncodeVarint(82<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BaremetalNode); err != nil {
			return err
		}
	case *Resource_BaremetalPort:
		_ = b.EncodeVarint(83<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BaremetalPort); err != nil {
			return err
		}
	case *Resource_ContrailAnalyticsDatabaseNodeRole:
		_ = b.EncodeVarint(84<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContrailAnalyticsDatabaseNodeRole); err != nil {
			return err
		}
	case *Resource_ContrailAnalyticsNode:
		_ = b.EncodeVarint(85<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContrailAnalyticsNode); err != nil {
			return err
		}
	case *Resource_ContrailCluster:
		_ = b.EncodeVarint(86<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContrailCluster); err != nil {
			return err
		}
	case *Resource_ContrailControllerNodeRole:
		_ = b.EncodeVarint(87<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContrailControllerNodeRole); err != nil {
			return err
		}
	case *Resource_ControllerNodeRole:
		_ = b.EncodeVarint(88<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ControllerNodeRole); err != nil {
			return err
		}
	case *Resource_Dashboard:
		_ = b.EncodeVarint(89<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dashboard); err != nil {
			return err
		}
	case *Resource_Keypair:
		_ = b.EncodeVarint(90<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Keypair); err != nil {
			return err
		}
	case *Resource_KubernetesCluster:
		_ = b.EncodeVarint(91<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KubernetesCluster); err != nil {
			return err
		}
	case *Resource_KubernetesNode:
		_ = b.EncodeVarint(92<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KubernetesNode); err != nil {
			return err
		}
	case *Resource_Location:
		_ = b.EncodeVarint(93<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Location); err != nil {
			return err
		}
	case *Resource_Node:
		_ = b.EncodeVarint(94<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Node); err != nil {
			return err
		}
	case *Resource_OpenstackCluster:
		_ = b.EncodeVarint(95<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OpenstackCluster); err != nil {
			return err
		}
	case *Resource_OpenstackComputeNodeRole:
		_ = b.EncodeVarint(96<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OpenstackComputeNodeRole); err != nil {
			return err
		}
	case *Resource_OpenstackStorageNodeRole:
		_ = b.EncodeVarint(97<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OpenstackStorageNodeRole); err != nil {
			return err
		}
	case *Resource_VpnGroup:
		_ = b.EncodeVarint(98<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VpnGroup); err != nil {
			return err
		}
	case *Resource_Widget:
		_ = b.EncodeVarint(99<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Widget); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Resource.ResourceOneof has unexpected type %T", x)
	}
	return nil
}

func _Resource_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Resource)
	switch tag {
	case 4: // resource_oneof.access_control_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AccessControlList)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_AccessControlList{msg}
		return true, err
	case 5: // resource_oneof.address_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressGroup)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_AddressGroup{msg}
		return true, err
	case 6: // resource_oneof.alarm
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Alarm)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Alarm{msg}
		return true, err
	case 7: // resource_oneof.alias_ip_pool
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AliasIPPool)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_AliasIpPool{msg}
		return true, err
	case 8: // resource_oneof.alias_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AliasIP)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_AliasIp{msg}
		return true, err
	case 9: // resource_oneof.analytics_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AnalyticsNode)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_AnalyticsNode{msg}
		return true, err
	case 10: // resource_oneof.api_access_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(APIAccessList)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ApiAccessList{msg}
		return true, err
	case 11: // resource_oneof.application_policy_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ApplicationPolicySet)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ApplicationPolicySet{msg}
		return true, err
	case 12: // resource_oneof.bgp_as_a_service
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPAsAService)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_BgpAsAService{msg}
		return true, err
	case 13: // resource_oneof.bgp_router
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPRouter)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_BgpRouter{msg}
		return true, err
	case 14: // resource_oneof.bgpvpn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPVPN)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Bgpvpn{msg}
		return true, err
	case 15: // resource_oneof.bridge_domain
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BridgeDomain)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_BridgeDomain{msg}
		return true, err
	case 16: // resource_oneof.config_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfigNode)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ConfigNode{msg}
		return true, err
	case 17: // resource_oneof.config_root
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfigRoot)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ConfigRoot{msg}
		return true, err
	case 18: // resource_oneof.customer_attachment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CustomerAttachment)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_CustomerAttachment{msg}
		return true, err
	case 19: // resource_oneof.database_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DatabaseNode)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_DatabaseNode{msg}
		return true, err
	case 20: // resource_oneof.discovery_service_assignment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DiscoveryServiceAssignment)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_DiscoveryServiceAssignment{msg}
		return true, err
	case 21: // resource_oneof.domain
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Domain)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Domain{msg}
		return true, err
	case 22: // resource_oneof.dsa_rule
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DsaRule)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_DsaRule{msg}
		return true, err
	case 23: // resource_oneof.e2_service_provider
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(E2ServiceProvider)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_E2ServiceProvider{msg}
		return true, err
	case 24: // resource_oneof.firewall_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FirewallPolicy)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_FirewallPolicy{msg}
		return true, err
	case 25: // resource_oneof.firewall_rule
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FirewallRule)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_FirewallRule{msg}
		return true, err
	case 26: // resource_oneof.floating_ip_pool
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FloatingIPPool)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_FloatingIpPool{msg}
		return true, err
	case 27: // resource_oneof.floating_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FloatingIP)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_FloatingIp{msg}
		return true, err
	case 28: // resource_oneof.forwarding_class
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ForwardingClass)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ForwardingClass{msg}
		return true, err
	case 29: // resource_oneof.global_qos_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GlobalQosConfig)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_GlobalQosConfig{msg}
		return true, err
	case 30: // resource_oneof.global_system_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GlobalSystemConfig)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_GlobalSystemConfig{msg}
		return true, err
	case 31: // resource_oneof.global_vrouter_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GlobalVrouterConfig)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_GlobalVrouterConfig{msg}
		return true, err
	case 32: // resource_oneof.instance_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InstanceIP)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_InstanceIp{msg}
		return true, err
	case 33: // resource_oneof.interface_route_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InterfaceRouteTable)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_InterfaceRouteTable{msg}
		return true, err
	case 34: // resource_oneof.loadbalancer_healthmonitor
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadbalancerHealthmonitor)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_LoadbalancerHealthmonitor{msg}
		return true, err
	case 35: // resource_oneof.loadbalancer_listener
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadbalancerListener)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_LoadbalancerListener{msg}
		return true, err
	case 36: // resource_oneof.loadbalancer_member
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadbalancerMember)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_LoadbalancerMember{msg}
		return true, err
	case 37: // resource_oneof.loadbalancer_pool
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadbalancerPool)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_LoadbalancerPool{msg}
		return true, err
	case 38: // resource_oneof.loadbalancer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Loadbalancer)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Loadbalancer{msg}
		return true, err
	case 39: // resource_oneof.logical_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicalInterface)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_LogicalInterface{msg}
		return true, err
	case 40: // resource_oneof.logical_router
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicalRouter)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_LogicalRouter{msg}
		return true, err
	case 41: // resource_oneof.namespace
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Namespace)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Namespace{msg}
		return true, err
	case 42: // resource_oneof.network_device_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NetworkDeviceConfig)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_NetworkDeviceConfig{msg}
		return true, err
	case 43: // resource_oneof.network_ipam
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NetworkIpam)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_NetworkIpam{msg}
		return true, err
	case 44: // resource_oneof.network_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NetworkPolicy)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_NetworkPolicy{msg}
		return true, err
	case 45: // resource_oneof.peering_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PeeringPolicy)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_PeeringPolicy{msg}
		return true, err
	case 46: // resource_oneof.physical_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PhysicalInterface)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_PhysicalInterface{msg}
		return true, err
	case 47: // resource_oneof.physical_router
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PhysicalRouter)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_PhysicalRouter{msg}
		return true, err
	case 48: // resource_oneof.policy_management
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PolicyManagement)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_PolicyManagement{msg}
		return true, err
	case 49: // resource_oneof.port_tuple
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PortTuple)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_PortTuple{msg}
		return true, err
	case 50: // resource_oneof.project
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Project)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Project{msg}
		return true, err
	case 51: // resource_oneof.provider_attachment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProviderAttachment)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ProviderAttachment{msg}
		return true, err
	case 52: // resource_oneof.qos_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosConfig)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_QosConfig{msg}
		return true, err
	case 53: // resource_oneof.qos_queue
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QosQueue)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_QosQueue{msg}
		return true, err
	case 54: // resource_oneof.route_aggregate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteAggregate)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_RouteAggregate{msg}
		return true, err
	case 55: // resource_oneof.route_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteTable)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_RouteTable{msg}
		return true, err
	case 56: // resource_oneof.route_target
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteTarget)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_RouteTarget{msg}
		return true, err
	case 57: // resource_oneof.routing_instance
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RoutingInstance)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_RoutingInstance{msg}
		return true, err
	case 58: // resource_oneof.routing_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RoutingPolicy)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_RoutingPolicy{msg}
		return true, err
	case 59: // resource_oneof.security_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SecurityGroup)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_SecurityGroup{msg}
		return true, err
	case 60: // resource_oneof.security_logging_object
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SecurityLoggingObject)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_SecurityLoggingObject{msg}
		return true, err
	case 61: // resource_oneof.service_appliance
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceAppliance)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ServiceAppliance{msg}
		return true, err
	case 62: // resource_oneof.service_appliance_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceApplianceSet)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ServiceApplianceSet{msg}
		return true, err
	case 63: // resource_oneof.service_connection_module
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceConnectionModule)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ServiceConnectionModule{msg}
		return true, err
	case 64: // resource_oneof.service_endpoint
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceEndpoint)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ServiceEndpoint{msg}
		return true, err
	case 65: // resource_oneof.service_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceGroup)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ServiceGroup{msg}
		return true, err
	case 66: // resource_oneof.service_health_check
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceHealthCheck)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ServiceHealthCheck{msg}
		return true, err
	case 67: // resource_oneof.service_instance
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceInstance)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ServiceInstance{msg}
		return true, err
	case 68: // resource_oneof.service_object
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceObject)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ServiceObject{msg}
		return true, err
	case 69: // resource_oneof.service_template
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServiceTemplate)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ServiceTemplate{msg}
		return true, err
	case 70: // resource_oneof.subnet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Subnet)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Subnet{msg}
		return true, err
	case 71: // resource_oneof.tag
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Tag)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Tag{msg}
		return true, err
	case 72: // resource_oneof.tag_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TagType)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_TagType{msg}
		return true, err
	case 73: // resource_oneof.user
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(User)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_User{msg}
		return true, err
	case 74: // resource_oneof.virtual_DNS_record
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VirtualDNSRecord)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Virtual_DNSRecord{msg}
		return true, err
	case 75: // resource_oneof.virtual_DNS
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VirtualDNS)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Virtual_DNS{msg}
		return true, err
	case 76: // resource_oneof.virtual_ip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VirtualIP)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_VirtualIp{msg}
		return true, err
	case 77: // resource_oneof.virtual_machine_interface
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VirtualMachineInterface)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_VirtualMachineInterface{msg}
		return true, err
	case 78: // resource_oneof.virtual_machine
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VirtualMachine)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_VirtualMachine{msg}
		return true, err
	case 79: // resource_oneof.virtual_network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VirtualNetwork)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_VirtualNetwork{msg}
		return true, err
	case 80: // resource_oneof.virtual_router
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VirtualRouter)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_VirtualRouter{msg}
		return true, err
	case 81: // resource_oneof.appformix_node_role
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppformixNodeRole)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_AppformixNodeRole{msg}
		return true, err
	case 82: // resource_oneof.baremetal_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BaremetalNode)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_BaremetalNode{msg}
		return true, err
	case 83: // resource_oneof.baremetal_port
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BaremetalPort)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_BaremetalPort{msg}
		return true, err
	case 84: // resource_oneof.contrail_analytics_database_node_role
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContrailAnalyticsDatabaseNodeRole)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ContrailAnalyticsDatabaseNodeRole{msg}
		return true, err
	case 85: // resource_oneof.contrail_analytics_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContrailAnalyticsNode)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ContrailAnalyticsNode{msg}
		return true, err
	case 86: // resource_oneof.contrail_cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContrailCluster)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ContrailCluster{msg}
		return true, err
	case 87: // resource_oneof.contrail_controller_node_role
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContrailControllerNodeRole)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ContrailControllerNodeRole{msg}
		return true, err
	case 88: // resource_oneof.controller_node_role
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ControllerNodeRole)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_ControllerNodeRole{msg}
		return true, err
	case 89: // resource_oneof.dashboard
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Dashboard)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Dashboard{msg}
		return true, err
	case 90: // resource_oneof.keypair
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Keypair)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Keypair{msg}
		return true, err
	case 91: // resource_oneof.kubernetes_cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubernetesCluster)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_KubernetesCluster{msg}
		return true, err
	case 92: // resource_oneof.kubernetes_node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubernetesNode)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_KubernetesNode{msg}
		return true, err
	case 93: // resource_oneof.location
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Location)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Location{msg}
		return true, err
	case 94: // resource_oneof.node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Node)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Node{msg}
		return true, err
	case 95: // resource_oneof.openstack_cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OpenstackCluster)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_OpenstackCluster{msg}
		return true, err
	case 96: // resource_oneof.openstack_compute_node_role
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OpenstackComputeNodeRole)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_OpenstackComputeNodeRole{msg}
		return true, err
	case 97: // resource_oneof.openstack_storage_node_role
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OpenstackStorageNodeRole)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_OpenstackStorageNodeRole{msg}
		return true, err
	case 98: // resource_oneof.vpn_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VPNGroup)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_VpnGroup{msg}
		return true, err
	case 99: // resource_oneof.widget
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Widget)
		err := b.DecodeMessage(msg)
		m.ResourceOneof = &Resource_Widget{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Resource_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Resource)
	// resource_oneof
	switch x := m.ResourceOneof.(type) {
	case *Resource_AccessControlList:
		s := proto.Size(x.AccessControlList)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_AddressGroup:
		s := proto.Size(x.AddressGroup)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Alarm:
		s := proto.Size(x.Alarm)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_AliasIpPool:
		s := proto.Size(x.AliasIpPool)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_AliasIp:
		s := proto.Size(x.AliasIp)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_AnalyticsNode:
		s := proto.Size(x.AnalyticsNode)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ApiAccessList:
		s := proto.Size(x.ApiAccessList)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ApplicationPolicySet:
		s := proto.Size(x.ApplicationPolicySet)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_BgpAsAService:
		s := proto.Size(x.BgpAsAService)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_BgpRouter:
		s := proto.Size(x.BgpRouter)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Bgpvpn:
		s := proto.Size(x.Bgpvpn)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_BridgeDomain:
		s := proto.Size(x.BridgeDomain)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ConfigNode:
		s := proto.Size(x.ConfigNode)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ConfigRoot:
		s := proto.Size(x.ConfigRoot)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_CustomerAttachment:
		s := proto.Size(x.CustomerAttachment)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_DatabaseNode:
		s := proto.Size(x.DatabaseNode)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_DiscoveryServiceAssignment:
		s := proto.Size(x.DiscoveryServiceAssignment)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Domain:
		s := proto.Size(x.Domain)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_DsaRule:
		s := proto.Size(x.DsaRule)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_E2ServiceProvider:
		s := proto.Size(x.E2ServiceProvider)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_FirewallPolicy:
		s := proto.Size(x.FirewallPolicy)
		n += proto.SizeVarint(24<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_FirewallRule:
		s := proto.Size(x.FirewallRule)
		n += proto.SizeVarint(25<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_FloatingIpPool:
		s := proto.Size(x.FloatingIpPool)
		n += proto.SizeVarint(26<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_FloatingIp:
		s := proto.Size(x.FloatingIp)
		n += proto.SizeVarint(27<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ForwardingClass:
		s := proto.Size(x.ForwardingClass)
		n += proto.SizeVarint(28<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_GlobalQosConfig:
		s := proto.Size(x.GlobalQosConfig)
		n += proto.SizeVarint(29<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_GlobalSystemConfig:
		s := proto.Size(x.GlobalSystemConfig)
		n += proto.SizeVarint(30<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_GlobalVrouterConfig:
		s := proto.Size(x.GlobalVrouterConfig)
		n += proto.SizeVarint(31<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_InstanceIp:
		s := proto.Size(x.InstanceIp)
		n += proto.SizeVarint(32<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_InterfaceRouteTable:
		s := proto.Size(x.InterfaceRouteTable)
		n += proto.SizeVarint(33<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_LoadbalancerHealthmonitor:
		s := proto.Size(x.LoadbalancerHealthmonitor)
		n += proto.SizeVarint(34<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_LoadbalancerListener:
		s := proto.Size(x.LoadbalancerListener)
		n += proto.SizeVarint(35<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_LoadbalancerMember:
		s := proto.Size(x.LoadbalancerMember)
		n += proto.SizeVarint(36<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_LoadbalancerPool:
		s := proto.Size(x.LoadbalancerPool)
		n += proto.SizeVarint(37<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Loadbalancer:
		s := proto.Size(x.Loadbalancer)
		n += proto.SizeVarint(38<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_LogicalInterface:
		s := proto.Size(x.LogicalInterface)
		n += proto.SizeVarint(39<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_LogicalRouter:
		s := proto.Size(x.LogicalRouter)
		n += proto.SizeVarint(40<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Namespace:
		s := proto.Size(x.Namespace)
		n += proto.SizeVarint(41<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_NetworkDeviceConfig:
		s := proto.Size(x.NetworkDeviceConfig)
		n += proto.SizeVarint(42<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_NetworkIpam:
		s := proto.Size(x.NetworkIpam)
		n += proto.SizeVarint(43<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_NetworkPolicy:
		s := proto.Size(x.NetworkPolicy)
		n += proto.SizeVarint(44<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_PeeringPolicy:
		s := proto.Size(x.PeeringPolicy)
		n += proto.SizeVarint(45<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_PhysicalInterface:
		s := proto.Size(x.PhysicalInterface)
		n += proto.SizeVarint(46<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_PhysicalRouter:
		s := proto.Size(x.PhysicalRouter)
		n += proto.SizeVarint(47<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_PolicyManagement:
		s := proto.Size(x.PolicyManagement)
		n += proto.SizeVarint(48<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_PortTuple:
		s := proto.Size(x.PortTuple)
		n += proto.SizeVarint(49<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Project:
		s := proto.Size(x.Project)
		n += proto.SizeVarint(50<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ProviderAttachment:
		s := proto.Size(x.ProviderAttachment)
		n += proto.SizeVarint(51<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_QosConfig:
		s := proto.Size(x.QosConfig)
		n += proto.SizeVarint(52<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_QosQueue:
		s := proto.Size(x.QosQueue)
		n += proto.SizeVarint(53<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_RouteAggregate:
		s := proto.Size(x.RouteAggregate)
		n += proto.SizeVarint(54<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_RouteTable:
		s := proto.Size(x.RouteTable)
		n += proto.SizeVarint(55<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_RouteTarget:
		s := proto.Size(x.RouteTarget)
		n += proto.SizeVarint(56<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_RoutingInstance:
		s := proto.Size(x.RoutingInstance)
		n += proto.SizeVarint(57<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_RoutingPolicy:
		s := proto.Size(x.RoutingPolicy)
		n += proto.SizeVarint(58<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_SecurityGroup:
		s := proto.Size(x.SecurityGroup)
		n += proto.SizeVarint(59<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_SecurityLoggingObject:
		s := proto.Size(x.SecurityLoggingObject)
		n += proto.SizeVarint(60<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ServiceAppliance:
		s := proto.Size(x.ServiceAppliance)
		n += proto.SizeVarint(61<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ServiceApplianceSet:
		s := proto.Size(x.ServiceApplianceSet)
		n += proto.SizeVarint(62<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ServiceConnectionModule:
		s := proto.Size(x.ServiceConnectionModule)
		n += proto.SizeVarint(63<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ServiceEndpoint:
		s := proto.Size(x.ServiceEndpoint)
		n += proto.SizeVarint(64<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ServiceGroup:
		s := proto.Size(x.ServiceGroup)
		n += proto.SizeVarint(65<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ServiceHealthCheck:
		s := proto.Size(x.ServiceHealthCheck)
		n += proto.SizeVarint(66<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ServiceInstance:
		s := proto.Size(x.ServiceInstance)
		n += proto.SizeVarint(67<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ServiceObject:
		s := proto.Size(x.ServiceObject)
		n += proto.SizeVarint(68<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ServiceTemplate:
		s := proto.Size(x.ServiceTemplate)
		n += proto.SizeVarint(69<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Subnet:
		s := proto.Size(x.Subnet)
		n += proto.SizeVarint(70<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Tag:
		s := proto.Size(x.Tag)
		n += proto.SizeVarint(71<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_TagType:
		s := proto.Size(x.TagType)
		n += proto.SizeVarint(72<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_User:
		s := proto.Size(x.User)
		n += proto.SizeVarint(73<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Virtual_DNSRecord:
		s := proto.Size(x.Virtual_DNSRecord)
		n += proto.SizeVarint(74<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Virtual_DNS:
		s := proto.Size(x.Virtual_DNS)
		n += proto.SizeVarint(75<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_VirtualIp:
		s := proto.Size(x.VirtualIp)
		n += proto.SizeVarint(76<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_VirtualMachineInterface:
		s := proto.Size(x.VirtualMachineInterface)
		n += proto.SizeVarint(77<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_VirtualMachine:
		s := proto.Size(x.VirtualMachine)
		n += proto.SizeVarint(78<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_VirtualNetwork:
		s := proto.Size(x.VirtualNetwork)
		n += proto.SizeVarint(79<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_VirtualRouter:
		s := proto.Size(x.VirtualRouter)
		n += proto.SizeVarint(80<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_AppformixNodeRole:
		s := proto.Size(x.AppformixNodeRole)
		n += proto.SizeVarint(81<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_BaremetalNode:
		s := proto.Size(x.BaremetalNode)
		n += proto.SizeVarint(82<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_BaremetalPort:
		s := proto.Size(x.BaremetalPort)
		n += proto.SizeVarint(83<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ContrailAnalyticsDatabaseNodeRole:
		s := proto.Size(x.ContrailAnalyticsDatabaseNodeRole)
		n += proto.SizeVarint(84<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ContrailAnalyticsNode:
		s := proto.Size(x.ContrailAnalyticsNode)
		n += proto.SizeVarint(85<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ContrailCluster:
		s := proto.Size(x.ContrailCluster)
		n += proto.SizeVarint(86<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ContrailControllerNodeRole:
		s := proto.Size(x.ContrailControllerNodeRole)
		n += proto.SizeVarint(87<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_ControllerNodeRole:
		s := proto.Size(x.ControllerNodeRole)
		n += proto.SizeVarint(88<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Dashboard:
		s := proto.Size(x.Dashboard)
		n += proto.SizeVarint(89<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Keypair:
		s := proto.Size(x.Keypair)
		n += proto.SizeVarint(90<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_KubernetesCluster:
		s := proto.Size(x.KubernetesCluster)
		n += proto.SizeVarint(91<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_KubernetesNode:
		s := proto.Size(x.KubernetesNode)
		n += proto.SizeVarint(92<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Location:
		s := proto.Size(x.Location)
		n += proto.SizeVarint(93<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Node:
		s := proto.Size(x.Node)
		n += proto.SizeVarint(94<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_OpenstackCluster:
		s := proto.Size(x.OpenstackCluster)
		n += proto.SizeVarint(95<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_OpenstackComputeNodeRole:
		s := proto.Size(x.OpenstackComputeNodeRole)
		n += proto.SizeVarint(96<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_OpenstackStorageNodeRole:
		s := proto.Size(x.OpenstackStorageNodeRole)
		n += proto.SizeVarint(97<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_VpnGroup:
		s := proto.Size(x.VpnGroup)
		n += proto.SizeVarint(98<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Resource_Widget:
		s := proto.Size(x.Widget)
		n += proto.SizeVarint(99<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AccessControlList struct {
	Uuid                     string          `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid               string          `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType               string          `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                   []string        `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                  *IdPermsType    `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName              string          `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations              *KeyValuePairs  `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                   *PermType2      `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	AccessControlListHash    []byte          `protobuf:"bytes,9,opt,name=access_control_list_hash,json=accessControlListHash,proto3" json:"access_control_list_hash,omitempty"`
	AccessControlListEntries *AclEntriesType `protobuf:"bytes,10,opt,name=access_control_list_entries,json=accessControlListEntries" json:"access_control_list_entries,omitempty"`
}

func (m *AccessControlList) Reset()                    { *m = AccessControlList{} }
func (m *AccessControlList) String() string            { return proto.CompactTextString(m) }
func (*AccessControlList) ProtoMessage()               {}
func (*AccessControlList) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{6} }

func (m *AccessControlList) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *AccessControlList) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *AccessControlList) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *AccessControlList) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *AccessControlList) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *AccessControlList) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *AccessControlList) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *AccessControlList) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *AccessControlList) GetAccessControlListHash() []byte {
	if m != nil {
		return m.AccessControlListHash
	}
	return nil
}

func (m *AccessControlList) GetAccessControlListEntries() *AclEntriesType {
	if m != nil {
		return m.AccessControlListEntries
	}
	return nil
}

type AddressGroup struct {
	Uuid               string          `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid         string          `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType         string          `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName             []string        `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms            *IdPermsType    `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName        string          `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations        *KeyValuePairs  `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2             *PermType2      `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	AddressGroupPrefix *SubnetListType `protobuf:"bytes,9,opt,name=address_group_prefix,json=addressGroupPrefix" json:"address_group_prefix,omitempty"`
}

func (m *AddressGroup) Reset()                    { *m = AddressGroup{} }
func (m *AddressGroup) String() string            { return proto.CompactTextString(m) }
func (*AddressGroup) ProtoMessage()               {}
func (*AddressGroup) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{7} }

func (m *AddressGroup) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *AddressGroup) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *AddressGroup) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *AddressGroup) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *AddressGroup) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *AddressGroup) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *AddressGroup) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *AddressGroup) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *AddressGroup) GetAddressGroupPrefix() *SubnetListType {
	if m != nil {
		return m.AddressGroupPrefix
	}
	return nil
}

type Alarm struct {
	Uuid          string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid    string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType    string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName        []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms       *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName   string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations   *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2        *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	AlarmRules    *AlarmOrList   `protobuf:"bytes,9,opt,name=alarm_rules,json=alarmRules" json:"alarm_rules,omitempty"`
	UveKeys       *UveKeysType   `protobuf:"bytes,10,opt,name=uve_keys,json=uveKeys" json:"uve_keys,omitempty"`
	AlarmSeverity int64          `protobuf:"varint,11,opt,name=alarm_severity,json=alarmSeverity,proto3" json:"alarm_severity,omitempty"`
}

func (m *Alarm) Reset()                    { *m = Alarm{} }
func (m *Alarm) String() string            { return proto.CompactTextString(m) }
func (*Alarm) ProtoMessage()               {}
func (*Alarm) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{8} }

func (m *Alarm) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Alarm) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Alarm) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Alarm) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Alarm) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Alarm) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Alarm) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Alarm) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Alarm) GetAlarmRules() *AlarmOrList {
	if m != nil {
		return m.AlarmRules
	}
	return nil
}

func (m *Alarm) GetUveKeys() *UveKeysType {
	if m != nil {
		return m.UveKeys
	}
	return nil
}

func (m *Alarm) GetAlarmSeverity() int64 {
	if m != nil {
		return m.AlarmSeverity
	}
	return 0
}

type AliasIPPool struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *AliasIPPool) Reset()                    { *m = AliasIPPool{} }
func (m *AliasIPPool) String() string            { return proto.CompactTextString(m) }
func (*AliasIPPool) ProtoMessage()               {}
func (*AliasIPPool) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{9} }

func (m *AliasIPPool) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *AliasIPPool) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *AliasIPPool) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *AliasIPPool) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *AliasIPPool) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *AliasIPPool) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *AliasIPPool) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *AliasIPPool) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type AliasIP struct {
	Uuid                 string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid           string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType           string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName               []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms              *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName          string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations          *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2               *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	AliasIpAddress       string         `protobuf:"bytes,9,opt,name=alias_ip_address,json=aliasIpAddress,proto3" json:"alias_ip_address,omitempty"`
	AliasIpAddressFamily string         `protobuf:"bytes,10,opt,name=alias_ip_address_family,json=aliasIpAddressFamily,proto3" json:"alias_ip_address_family,omitempty"`
}

func (m *AliasIP) Reset()                    { *m = AliasIP{} }
func (m *AliasIP) String() string            { return proto.CompactTextString(m) }
func (*AliasIP) ProtoMessage()               {}
func (*AliasIP) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{10} }

func (m *AliasIP) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *AliasIP) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *AliasIP) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *AliasIP) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *AliasIP) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *AliasIP) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *AliasIP) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *AliasIP) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *AliasIP) GetAliasIpAddress() string {
	if m != nil {
		return m.AliasIpAddress
	}
	return ""
}

func (m *AliasIP) GetAliasIpAddressFamily() string {
	if m != nil {
		return m.AliasIpAddressFamily
	}
	return ""
}

type AnalyticsNode struct {
	Uuid                   string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid             string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType             string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                 []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName            string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations            *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                 *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	AnalyticsNodeIpAddress string         `protobuf:"bytes,9,opt,name=analytics_node_ip_address,json=analyticsNodeIpAddress,proto3" json:"analytics_node_ip_address,omitempty"`
}

func (m *AnalyticsNode) Reset()                    { *m = AnalyticsNode{} }
func (m *AnalyticsNode) String() string            { return proto.CompactTextString(m) }
func (*AnalyticsNode) ProtoMessage()               {}
func (*AnalyticsNode) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{11} }

func (m *AnalyticsNode) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *AnalyticsNode) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *AnalyticsNode) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *AnalyticsNode) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *AnalyticsNode) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *AnalyticsNode) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *AnalyticsNode) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *AnalyticsNode) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *AnalyticsNode) GetAnalyticsNodeIpAddress() string {
	if m != nil {
		return m.AnalyticsNodeIpAddress
	}
	return ""
}

type APIAccessList struct {
	Uuid                 string               `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid           string               `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType           string               `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName               []string             `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms              *IdPermsType         `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName          string               `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations          *KeyValuePairs       `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2               *PermType2           `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ApiAccessListEntries *RbacRuleEntriesType `protobuf:"bytes,9,opt,name=api_access_list_entries,json=apiAccessListEntries" json:"api_access_list_entries,omitempty"`
}

func (m *APIAccessList) Reset()                    { *m = APIAccessList{} }
func (m *APIAccessList) String() string            { return proto.CompactTextString(m) }
func (*APIAccessList) ProtoMessage()               {}
func (*APIAccessList) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{12} }

func (m *APIAccessList) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *APIAccessList) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *APIAccessList) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *APIAccessList) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *APIAccessList) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *APIAccessList) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *APIAccessList) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *APIAccessList) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *APIAccessList) GetApiAccessListEntries() *RbacRuleEntriesType {
	if m != nil {
		return m.ApiAccessListEntries
	}
	return nil
}

type ApplicationPolicySet struct {
	Uuid            string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid      string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType      string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName          []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms         *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName     string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations     *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2          *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	AllApplications bool           `protobuf:"varint,9,opt,name=all_applications,json=allApplications,proto3" json:"all_applications,omitempty"`
}

func (m *ApplicationPolicySet) Reset()                    { *m = ApplicationPolicySet{} }
func (m *ApplicationPolicySet) String() string            { return proto.CompactTextString(m) }
func (*ApplicationPolicySet) ProtoMessage()               {}
func (*ApplicationPolicySet) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{13} }

func (m *ApplicationPolicySet) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ApplicationPolicySet) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ApplicationPolicySet) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ApplicationPolicySet) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ApplicationPolicySet) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ApplicationPolicySet) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ApplicationPolicySet) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ApplicationPolicySet) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ApplicationPolicySet) GetAllApplications() bool {
	if m != nil {
		return m.AllApplications
	}
	return false
}

type BGPAsAService struct {
	Uuid                             string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                       string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                       string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                           []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                          *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                      string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                      *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                           *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	BgpaasShared                     bool           `protobuf:"varint,9,opt,name=bgpaas_shared,json=bgpaasShared,proto3" json:"bgpaas_shared,omitempty"`
	BgpaasSessionAttributes          string         `protobuf:"bytes,10,opt,name=bgpaas_session_attributes,json=bgpaasSessionAttributes,proto3" json:"bgpaas_session_attributes,omitempty"`
	BgpaasSuppressRouteAdvertisement bool           `protobuf:"varint,11,opt,name=bgpaas_suppress_route_advertisement,json=bgpaasSuppressRouteAdvertisement,proto3" json:"bgpaas_suppress_route_advertisement,omitempty"`
	BgpaasIpv4MappedIpv6Nexthop      bool           `protobuf:"varint,12,opt,name=bgpaas_ipv4_mapped_ipv6_nexthop,json=bgpaasIpv4MappedIpv6Nexthop,proto3" json:"bgpaas_ipv4_mapped_ipv6_nexthop,omitempty"`
	BgpaasIpAddress                  string         `protobuf:"bytes,13,opt,name=bgpaas_ip_address,json=bgpaasIpAddress,proto3" json:"bgpaas_ip_address,omitempty"`
	AutonomousSystem                 int64          `protobuf:"varint,14,opt,name=autonomous_system,json=autonomousSystem,proto3" json:"autonomous_system,omitempty"`
}

func (m *BGPAsAService) Reset()                    { *m = BGPAsAService{} }
func (m *BGPAsAService) String() string            { return proto.CompactTextString(m) }
func (*BGPAsAService) ProtoMessage()               {}
func (*BGPAsAService) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{14} }

func (m *BGPAsAService) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *BGPAsAService) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *BGPAsAService) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *BGPAsAService) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *BGPAsAService) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *BGPAsAService) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *BGPAsAService) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *BGPAsAService) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *BGPAsAService) GetBgpaasShared() bool {
	if m != nil {
		return m.BgpaasShared
	}
	return false
}

func (m *BGPAsAService) GetBgpaasSessionAttributes() string {
	if m != nil {
		return m.BgpaasSessionAttributes
	}
	return ""
}

func (m *BGPAsAService) GetBgpaasSuppressRouteAdvertisement() bool {
	if m != nil {
		return m.BgpaasSuppressRouteAdvertisement
	}
	return false
}

func (m *BGPAsAService) GetBgpaasIpv4MappedIpv6Nexthop() bool {
	if m != nil {
		return m.BgpaasIpv4MappedIpv6Nexthop
	}
	return false
}

func (m *BGPAsAService) GetBgpaasIpAddress() string {
	if m != nil {
		return m.BgpaasIpAddress
	}
	return ""
}

func (m *BGPAsAService) GetAutonomousSystem() int64 {
	if m != nil {
		return m.AutonomousSystem
	}
	return 0
}

type BGPRouter struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *BGPRouter) Reset()                    { *m = BGPRouter{} }
func (m *BGPRouter) String() string            { return proto.CompactTextString(m) }
func (*BGPRouter) ProtoMessage()               {}
func (*BGPRouter) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{15} }

func (m *BGPRouter) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *BGPRouter) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *BGPRouter) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *BGPRouter) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *BGPRouter) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *BGPRouter) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *BGPRouter) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *BGPRouter) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type BGPVPN struct {
	Uuid                  string           `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid            string           `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType            string           `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                []string         `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms               *IdPermsType     `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName           string           `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations           *KeyValuePairs   `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                *PermType2       `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	RouteTargetList       *RouteTargetList `protobuf:"bytes,9,opt,name=route_target_list,json=routeTargetList" json:"route_target_list,omitempty"`
	ImportRouteTargetList *RouteTargetList `protobuf:"bytes,10,opt,name=import_route_target_list,json=importRouteTargetList" json:"import_route_target_list,omitempty"`
	ExportRouteTargetList *RouteTargetList `protobuf:"bytes,11,opt,name=export_route_target_list,json=exportRouteTargetList" json:"export_route_target_list,omitempty"`
	BgpvpnType            string           `protobuf:"bytes,12,opt,name=bgpvpn_type,json=bgpvpnType,proto3" json:"bgpvpn_type,omitempty"`
}

func (m *BGPVPN) Reset()                    { *m = BGPVPN{} }
func (m *BGPVPN) String() string            { return proto.CompactTextString(m) }
func (*BGPVPN) ProtoMessage()               {}
func (*BGPVPN) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{16} }

func (m *BGPVPN) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *BGPVPN) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *BGPVPN) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *BGPVPN) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *BGPVPN) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *BGPVPN) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *BGPVPN) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *BGPVPN) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *BGPVPN) GetRouteTargetList() *RouteTargetList {
	if m != nil {
		return m.RouteTargetList
	}
	return nil
}

func (m *BGPVPN) GetImportRouteTargetList() *RouteTargetList {
	if m != nil {
		return m.ImportRouteTargetList
	}
	return nil
}

func (m *BGPVPN) GetExportRouteTargetList() *RouteTargetList {
	if m != nil {
		return m.ExportRouteTargetList
	}
	return nil
}

func (m *BGPVPN) GetBgpvpnType() string {
	if m != nil {
		return m.BgpvpnType
	}
	return ""
}

type BridgeDomain struct {
	Uuid               string                   `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid         string                   `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType         string                   `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName             []string                 `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms            *IdPermsType             `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName        string                   `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations        *KeyValuePairs           `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2             *PermType2               `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	MacAgingTime       int64                    `protobuf:"varint,9,opt,name=mac_aging_time,json=macAgingTime,proto3" json:"mac_aging_time,omitempty"`
	Isid               int64                    `protobuf:"varint,10,opt,name=isid,proto3" json:"isid,omitempty"`
	MacLearningEnabled bool                     `protobuf:"varint,11,opt,name=mac_learning_enabled,json=macLearningEnabled,proto3" json:"mac_learning_enabled,omitempty"`
	MacMoveControl     *MACMoveLimitControlType `protobuf:"bytes,12,opt,name=mac_move_control,json=macMoveControl" json:"mac_move_control,omitempty"`
	MacLimitControl    *MACLimitControlType     `protobuf:"bytes,13,opt,name=mac_limit_control,json=macLimitControl" json:"mac_limit_control,omitempty"`
}

func (m *BridgeDomain) Reset()                    { *m = BridgeDomain{} }
func (m *BridgeDomain) String() string            { return proto.CompactTextString(m) }
func (*BridgeDomain) ProtoMessage()               {}
func (*BridgeDomain) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{17} }

func (m *BridgeDomain) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *BridgeDomain) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *BridgeDomain) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *BridgeDomain) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *BridgeDomain) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *BridgeDomain) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *BridgeDomain) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *BridgeDomain) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *BridgeDomain) GetMacAgingTime() int64 {
	if m != nil {
		return m.MacAgingTime
	}
	return 0
}

func (m *BridgeDomain) GetIsid() int64 {
	if m != nil {
		return m.Isid
	}
	return 0
}

func (m *BridgeDomain) GetMacLearningEnabled() bool {
	if m != nil {
		return m.MacLearningEnabled
	}
	return false
}

func (m *BridgeDomain) GetMacMoveControl() *MACMoveLimitControlType {
	if m != nil {
		return m.MacMoveControl
	}
	return nil
}

func (m *BridgeDomain) GetMacLimitControl() *MACLimitControlType {
	if m != nil {
		return m.MacLimitControl
	}
	return nil
}

type ConfigNode struct {
	Uuid                string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid          string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType          string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName              []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms             *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName         string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations         *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2              *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ConfigNodeIpAddress string         `protobuf:"bytes,9,opt,name=config_node_ip_address,json=configNodeIpAddress,proto3" json:"config_node_ip_address,omitempty"`
}

func (m *ConfigNode) Reset()                    { *m = ConfigNode{} }
func (m *ConfigNode) String() string            { return proto.CompactTextString(m) }
func (*ConfigNode) ProtoMessage()               {}
func (*ConfigNode) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{18} }

func (m *ConfigNode) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ConfigNode) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ConfigNode) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ConfigNode) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ConfigNode) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ConfigNode) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ConfigNode) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ConfigNode) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ConfigNode) GetConfigNodeIpAddress() string {
	if m != nil {
		return m.ConfigNodeIpAddress
	}
	return ""
}

type ConfigRoot struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *ConfigRoot) Reset()                    { *m = ConfigRoot{} }
func (m *ConfigRoot) String() string            { return proto.CompactTextString(m) }
func (*ConfigRoot) ProtoMessage()               {}
func (*ConfigRoot) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{19} }

func (m *ConfigRoot) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ConfigRoot) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ConfigRoot) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ConfigRoot) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ConfigRoot) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ConfigRoot) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ConfigRoot) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ConfigRoot) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type CustomerAttachment struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *CustomerAttachment) Reset()                    { *m = CustomerAttachment{} }
func (m *CustomerAttachment) String() string            { return proto.CompactTextString(m) }
func (*CustomerAttachment) ProtoMessage()               {}
func (*CustomerAttachment) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{20} }

func (m *CustomerAttachment) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *CustomerAttachment) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *CustomerAttachment) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *CustomerAttachment) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *CustomerAttachment) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *CustomerAttachment) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *CustomerAttachment) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *CustomerAttachment) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type DatabaseNode struct {
	Uuid                  string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid            string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType            string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms               *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName           string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations           *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	DatabaseNodeIpAddress string         `protobuf:"bytes,9,opt,name=database_node_ip_address,json=databaseNodeIpAddress,proto3" json:"database_node_ip_address,omitempty"`
}

func (m *DatabaseNode) Reset()                    { *m = DatabaseNode{} }
func (m *DatabaseNode) String() string            { return proto.CompactTextString(m) }
func (*DatabaseNode) ProtoMessage()               {}
func (*DatabaseNode) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{21} }

func (m *DatabaseNode) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *DatabaseNode) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *DatabaseNode) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *DatabaseNode) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *DatabaseNode) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *DatabaseNode) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *DatabaseNode) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *DatabaseNode) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *DatabaseNode) GetDatabaseNodeIpAddress() string {
	if m != nil {
		return m.DatabaseNodeIpAddress
	}
	return ""
}

type DiscoveryServiceAssignment struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *DiscoveryServiceAssignment) Reset()         { *m = DiscoveryServiceAssignment{} }
func (m *DiscoveryServiceAssignment) String() string { return proto.CompactTextString(m) }
func (*DiscoveryServiceAssignment) ProtoMessage()    {}
func (*DiscoveryServiceAssignment) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{22}
}

func (m *DiscoveryServiceAssignment) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *DiscoveryServiceAssignment) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *DiscoveryServiceAssignment) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *DiscoveryServiceAssignment) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *DiscoveryServiceAssignment) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *DiscoveryServiceAssignment) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *DiscoveryServiceAssignment) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *DiscoveryServiceAssignment) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type Domain struct {
	Uuid         string            `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid   string            `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType   string            `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName       []string          `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms      *IdPermsType      `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName  string            `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations  *KeyValuePairs    `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2       *PermType2        `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	DomainLimits *DomainLimitsType `protobuf:"bytes,9,opt,name=domain_limits,json=domainLimits" json:"domain_limits,omitempty"`
}

func (m *Domain) Reset()                    { *m = Domain{} }
func (m *Domain) String() string            { return proto.CompactTextString(m) }
func (*Domain) ProtoMessage()               {}
func (*Domain) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{23} }

func (m *Domain) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Domain) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Domain) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Domain) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Domain) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Domain) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Domain) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Domain) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Domain) GetDomainLimits() *DomainLimitsType {
	if m != nil {
		return m.DomainLimits
	}
	return nil
}

type DsaRule struct {
	Uuid         string                          `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid   string                          `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType   string                          `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName       []string                        `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms      *IdPermsType                    `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName  string                          `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations  *KeyValuePairs                  `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2       *PermType2                      `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	DsaRuleEntry *DiscoveryServiceAssignmentType `protobuf:"bytes,9,opt,name=dsa_rule_entry,json=dsaRuleEntry" json:"dsa_rule_entry,omitempty"`
}

func (m *DsaRule) Reset()                    { *m = DsaRule{} }
func (m *DsaRule) String() string            { return proto.CompactTextString(m) }
func (*DsaRule) ProtoMessage()               {}
func (*DsaRule) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{24} }

func (m *DsaRule) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *DsaRule) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *DsaRule) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *DsaRule) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *DsaRule) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *DsaRule) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *DsaRule) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *DsaRule) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *DsaRule) GetDsaRuleEntry() *DiscoveryServiceAssignmentType {
	if m != nil {
		return m.DsaRuleEntry
	}
	return nil
}

type E2ServiceProvider struct {
	Uuid                         string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                   string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                   string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                       []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                      *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                  string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                  *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                       *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	E2ServiceProviderPromiscuous bool           `protobuf:"varint,9,opt,name=e2_service_provider_promiscuous,json=e2ServiceProviderPromiscuous,proto3" json:"e2_service_provider_promiscuous,omitempty"`
}

func (m *E2ServiceProvider) Reset()                    { *m = E2ServiceProvider{} }
func (m *E2ServiceProvider) String() string            { return proto.CompactTextString(m) }
func (*E2ServiceProvider) ProtoMessage()               {}
func (*E2ServiceProvider) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{25} }

func (m *E2ServiceProvider) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *E2ServiceProvider) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *E2ServiceProvider) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *E2ServiceProvider) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *E2ServiceProvider) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *E2ServiceProvider) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *E2ServiceProvider) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *E2ServiceProvider) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *E2ServiceProvider) GetE2ServiceProviderPromiscuous() bool {
	if m != nil {
		return m.E2ServiceProviderPromiscuous
	}
	return false
}

type FirewallPolicy struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *FirewallPolicy) Reset()                    { *m = FirewallPolicy{} }
func (m *FirewallPolicy) String() string            { return proto.CompactTextString(m) }
func (*FirewallPolicy) ProtoMessage()               {}
func (*FirewallPolicy) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{26} }

func (m *FirewallPolicy) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *FirewallPolicy) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *FirewallPolicy) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *FirewallPolicy) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *FirewallPolicy) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *FirewallPolicy) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *FirewallPolicy) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *FirewallPolicy) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type FirewallRule struct {
	Uuid          string                           `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid    string                           `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType    string                           `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName        []string                         `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms       *IdPermsType                     `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName   string                           `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations   *KeyValuePairs                   `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2        *PermType2                       `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	Endpoint_1    *FirewallRuleEndpointType        `protobuf:"bytes,9,opt,name=endpoint_1,json=endpoint1" json:"endpoint_1,omitempty"`
	Endpoint_2    *FirewallRuleEndpointType        `protobuf:"bytes,10,opt,name=endpoint_2,json=endpoint2" json:"endpoint_2,omitempty"`
	ActionList    *ActionListType                  `protobuf:"bytes,11,opt,name=action_list,json=actionList" json:"action_list,omitempty"`
	Service       *FirewallServiceType             `protobuf:"bytes,12,opt,name=service" json:"service,omitempty"`
	Direction     string                           `protobuf:"bytes,13,opt,name=direction,proto3" json:"direction,omitempty"`
	MatchTagTypes *FirewallRuleMatchTagsTypeIdList `protobuf:"bytes,14,opt,name=match_tag_types,json=matchTagTypes" json:"match_tag_types,omitempty"`
	MatchTags     *FirewallRuleMatchTagsType       `protobuf:"bytes,15,opt,name=match_tags,json=matchTags" json:"match_tags,omitempty"`
}

func (m *FirewallRule) Reset()                    { *m = FirewallRule{} }
func (m *FirewallRule) String() string            { return proto.CompactTextString(m) }
func (*FirewallRule) ProtoMessage()               {}
func (*FirewallRule) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{27} }

func (m *FirewallRule) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *FirewallRule) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *FirewallRule) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *FirewallRule) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *FirewallRule) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *FirewallRule) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *FirewallRule) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *FirewallRule) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *FirewallRule) GetEndpoint_1() *FirewallRuleEndpointType {
	if m != nil {
		return m.Endpoint_1
	}
	return nil
}

func (m *FirewallRule) GetEndpoint_2() *FirewallRuleEndpointType {
	if m != nil {
		return m.Endpoint_2
	}
	return nil
}

func (m *FirewallRule) GetActionList() *ActionListType {
	if m != nil {
		return m.ActionList
	}
	return nil
}

func (m *FirewallRule) GetService() *FirewallServiceType {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *FirewallRule) GetDirection() string {
	if m != nil {
		return m.Direction
	}
	return ""
}

func (m *FirewallRule) GetMatchTagTypes() *FirewallRuleMatchTagsTypeIdList {
	if m != nil {
		return m.MatchTagTypes
	}
	return nil
}

func (m *FirewallRule) GetMatchTags() *FirewallRuleMatchTagsType {
	if m != nil {
		return m.MatchTags
	}
	return nil
}

type FloatingIPPool struct {
	Uuid                  string                    `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid            string                    `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType            string                    `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                []string                  `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms               *IdPermsType              `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName           string                    `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations           *KeyValuePairs            `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                *PermType2                `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	FloatingIpPoolSubnets *FloatingIpPoolSubnetType `protobuf:"bytes,9,opt,name=floating_ip_pool_subnets,json=floatingIpPoolSubnets" json:"floating_ip_pool_subnets,omitempty"`
}

func (m *FloatingIPPool) Reset()                    { *m = FloatingIPPool{} }
func (m *FloatingIPPool) String() string            { return proto.CompactTextString(m) }
func (*FloatingIPPool) ProtoMessage()               {}
func (*FloatingIPPool) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{28} }

func (m *FloatingIPPool) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *FloatingIPPool) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *FloatingIPPool) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *FloatingIPPool) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *FloatingIPPool) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *FloatingIPPool) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *FloatingIPPool) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *FloatingIPPool) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *FloatingIPPool) GetFloatingIpPoolSubnets() *FloatingIpPoolSubnetType {
	if m != nil {
		return m.FloatingIpPoolSubnets
	}
	return nil
}

type FloatingIP struct {
	Uuid                         string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                   string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                   string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                       []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                      *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                  string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                  *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                       *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	FloatingIpAddressFamily      string         `protobuf:"bytes,9,opt,name=floating_ip_address_family,json=floatingIpAddressFamily,proto3" json:"floating_ip_address_family,omitempty"`
	FloatingIpPortMappings       *PortMappings  `protobuf:"bytes,10,opt,name=floating_ip_port_mappings,json=floatingIpPortMappings" json:"floating_ip_port_mappings,omitempty"`
	FloatingIpIsVirtualIp        bool           `protobuf:"varint,11,opt,name=floating_ip_is_virtual_ip,json=floatingIpIsVirtualIp,proto3" json:"floating_ip_is_virtual_ip,omitempty"`
	FloatingIpAddress            string         `protobuf:"bytes,12,opt,name=floating_ip_address,json=floatingIpAddress,proto3" json:"floating_ip_address,omitempty"`
	FloatingIpPortMappingsEnable bool           `protobuf:"varint,13,opt,name=floating_ip_port_mappings_enable,json=floatingIpPortMappingsEnable,proto3" json:"floating_ip_port_mappings_enable,omitempty"`
	FloatingIpFixedIpAddress     string         `protobuf:"bytes,14,opt,name=floating_ip_fixed_ip_address,json=floatingIpFixedIpAddress,proto3" json:"floating_ip_fixed_ip_address,omitempty"`
	FloatingIpTrafficDirection   string         `protobuf:"bytes,15,opt,name=floating_ip_traffic_direction,json=floatingIpTrafficDirection,proto3" json:"floating_ip_traffic_direction,omitempty"`
}

func (m *FloatingIP) Reset()                    { *m = FloatingIP{} }
func (m *FloatingIP) String() string            { return proto.CompactTextString(m) }
func (*FloatingIP) ProtoMessage()               {}
func (*FloatingIP) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{29} }

func (m *FloatingIP) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *FloatingIP) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *FloatingIP) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *FloatingIP) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *FloatingIP) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *FloatingIP) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *FloatingIP) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *FloatingIP) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *FloatingIP) GetFloatingIpAddressFamily() string {
	if m != nil {
		return m.FloatingIpAddressFamily
	}
	return ""
}

func (m *FloatingIP) GetFloatingIpPortMappings() *PortMappings {
	if m != nil {
		return m.FloatingIpPortMappings
	}
	return nil
}

func (m *FloatingIP) GetFloatingIpIsVirtualIp() bool {
	if m != nil {
		return m.FloatingIpIsVirtualIp
	}
	return false
}

func (m *FloatingIP) GetFloatingIpAddress() string {
	if m != nil {
		return m.FloatingIpAddress
	}
	return ""
}

func (m *FloatingIP) GetFloatingIpPortMappingsEnable() bool {
	if m != nil {
		return m.FloatingIpPortMappingsEnable
	}
	return false
}

func (m *FloatingIP) GetFloatingIpFixedIpAddress() string {
	if m != nil {
		return m.FloatingIpFixedIpAddress
	}
	return ""
}

func (m *FloatingIP) GetFloatingIpTrafficDirection() string {
	if m != nil {
		return m.FloatingIpTrafficDirection
	}
	return ""
}

type ForwardingClass struct {
	Uuid                        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                 string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                 *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ForwardingClassDscp         int64          `protobuf:"varint,9,opt,name=forwarding_class_dscp,json=forwardingClassDscp,proto3" json:"forwarding_class_dscp,omitempty"`
	ForwardingClassVlanPriority int64          `protobuf:"varint,10,opt,name=forwarding_class_vlan_priority,json=forwardingClassVlanPriority,proto3" json:"forwarding_class_vlan_priority,omitempty"`
	ForwardingClassMplsExp      int64          `protobuf:"varint,11,opt,name=forwarding_class_mpls_exp,json=forwardingClassMplsExp,proto3" json:"forwarding_class_mpls_exp,omitempty"`
	ForwardingClassId           int64          `protobuf:"varint,12,opt,name=forwarding_class_id,json=forwardingClassId,proto3" json:"forwarding_class_id,omitempty"`
}

func (m *ForwardingClass) Reset()                    { *m = ForwardingClass{} }
func (m *ForwardingClass) String() string            { return proto.CompactTextString(m) }
func (*ForwardingClass) ProtoMessage()               {}
func (*ForwardingClass) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{30} }

func (m *ForwardingClass) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ForwardingClass) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ForwardingClass) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ForwardingClass) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ForwardingClass) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ForwardingClass) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ForwardingClass) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ForwardingClass) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ForwardingClass) GetForwardingClassDscp() int64 {
	if m != nil {
		return m.ForwardingClassDscp
	}
	return 0
}

func (m *ForwardingClass) GetForwardingClassVlanPriority() int64 {
	if m != nil {
		return m.ForwardingClassVlanPriority
	}
	return 0
}

func (m *ForwardingClass) GetForwardingClassMplsExp() int64 {
	if m != nil {
		return m.ForwardingClassMplsExp
	}
	return 0
}

func (m *ForwardingClass) GetForwardingClassId() int64 {
	if m != nil {
		return m.ForwardingClassId
	}
	return 0
}

type GlobalQosConfig struct {
	Uuid               string                  `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid         string                  `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType         string                  `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName             []string                `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms            *IdPermsType            `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName        string                  `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations        *KeyValuePairs          `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2             *PermType2              `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ControlTrafficDscp *ControlTrafficDscpType `protobuf:"bytes,9,opt,name=control_traffic_dscp,json=controlTrafficDscp" json:"control_traffic_dscp,omitempty"`
}

func (m *GlobalQosConfig) Reset()                    { *m = GlobalQosConfig{} }
func (m *GlobalQosConfig) String() string            { return proto.CompactTextString(m) }
func (*GlobalQosConfig) ProtoMessage()               {}
func (*GlobalQosConfig) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{31} }

func (m *GlobalQosConfig) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *GlobalQosConfig) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *GlobalQosConfig) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *GlobalQosConfig) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *GlobalQosConfig) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *GlobalQosConfig) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *GlobalQosConfig) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *GlobalQosConfig) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *GlobalQosConfig) GetControlTrafficDscp() *ControlTrafficDscpType {
	if m != nil {
		return m.ControlTrafficDscp
	}
	return nil
}

type GlobalSystemConfig struct {
	Uuid                      string                         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string                         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string                         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string                       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType                   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string                         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs                 `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2                     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ConfigVersion             string                         `protobuf:"bytes,9,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	BgpaasParameters          *BGPaaServiceParametersType    `protobuf:"bytes,10,opt,name=bgpaas_parameters,json=bgpaasParameters" json:"bgpaas_parameters,omitempty"`
	AlarmEnable               bool                           `protobuf:"varint,11,opt,name=alarm_enable,json=alarmEnable,proto3" json:"alarm_enable,omitempty"`
	MacMoveControl            *MACMoveLimitControlType       `protobuf:"bytes,12,opt,name=mac_move_control,json=macMoveControl" json:"mac_move_control,omitempty"`
	PluginTuning              *PluginProperties              `protobuf:"bytes,13,opt,name=plugin_tuning,json=pluginTuning" json:"plugin_tuning,omitempty"`
	IbgpAutoMesh              bool                           `protobuf:"varint,14,opt,name=ibgp_auto_mesh,json=ibgpAutoMesh,proto3" json:"ibgp_auto_mesh,omitempty"`
	MacAgingTime              int64                          `protobuf:"varint,15,opt,name=mac_aging_time,json=macAgingTime,proto3" json:"mac_aging_time,omitempty"`
	BgpAlwaysCompareMed       bool                           `protobuf:"varint,16,opt,name=bgp_always_compare_med,json=bgpAlwaysCompareMed,proto3" json:"bgp_always_compare_med,omitempty"`
	UserDefinedLogStatistics  *UserDefinedLogStatList        `protobuf:"bytes,17,opt,name=user_defined_log_statistics,json=userDefinedLogStatistics" json:"user_defined_log_statistics,omitempty"`
	GracefulRestartParameters *GracefulRestartParametersType `protobuf:"bytes,18,opt,name=graceful_restart_parameters,json=gracefulRestartParameters" json:"graceful_restart_parameters,omitempty"`
	IpFabricSubnets           *SubnetListType                `protobuf:"bytes,19,opt,name=ip_fabric_subnets,json=ipFabricSubnets" json:"ip_fabric_subnets,omitempty"`
	AutonomousSystem          int64                          `protobuf:"varint,20,opt,name=autonomous_system,json=autonomousSystem,proto3" json:"autonomous_system,omitempty"`
	MacLimitControl           *MACLimitControlType           `protobuf:"bytes,21,opt,name=mac_limit_control,json=macLimitControl" json:"mac_limit_control,omitempty"`
}

func (m *GlobalSystemConfig) Reset()                    { *m = GlobalSystemConfig{} }
func (m *GlobalSystemConfig) String() string            { return proto.CompactTextString(m) }
func (*GlobalSystemConfig) ProtoMessage()               {}
func (*GlobalSystemConfig) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{32} }

func (m *GlobalSystemConfig) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *GlobalSystemConfig) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *GlobalSystemConfig) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *GlobalSystemConfig) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *GlobalSystemConfig) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *GlobalSystemConfig) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *GlobalSystemConfig) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *GlobalSystemConfig) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *GlobalSystemConfig) GetConfigVersion() string {
	if m != nil {
		return m.ConfigVersion
	}
	return ""
}

func (m *GlobalSystemConfig) GetBgpaasParameters() *BGPaaServiceParametersType {
	if m != nil {
		return m.BgpaasParameters
	}
	return nil
}

func (m *GlobalSystemConfig) GetAlarmEnable() bool {
	if m != nil {
		return m.AlarmEnable
	}
	return false
}

func (m *GlobalSystemConfig) GetMacMoveControl() *MACMoveLimitControlType {
	if m != nil {
		return m.MacMoveControl
	}
	return nil
}

func (m *GlobalSystemConfig) GetPluginTuning() *PluginProperties {
	if m != nil {
		return m.PluginTuning
	}
	return nil
}

func (m *GlobalSystemConfig) GetIbgpAutoMesh() bool {
	if m != nil {
		return m.IbgpAutoMesh
	}
	return false
}

func (m *GlobalSystemConfig) GetMacAgingTime() int64 {
	if m != nil {
		return m.MacAgingTime
	}
	return 0
}

func (m *GlobalSystemConfig) GetBgpAlwaysCompareMed() bool {
	if m != nil {
		return m.BgpAlwaysCompareMed
	}
	return false
}

func (m *GlobalSystemConfig) GetUserDefinedLogStatistics() *UserDefinedLogStatList {
	if m != nil {
		return m.UserDefinedLogStatistics
	}
	return nil
}

func (m *GlobalSystemConfig) GetGracefulRestartParameters() *GracefulRestartParametersType {
	if m != nil {
		return m.GracefulRestartParameters
	}
	return nil
}

func (m *GlobalSystemConfig) GetIpFabricSubnets() *SubnetListType {
	if m != nil {
		return m.IpFabricSubnets
	}
	return nil
}

func (m *GlobalSystemConfig) GetAutonomousSystem() int64 {
	if m != nil {
		return m.AutonomousSystem
	}
	return 0
}

func (m *GlobalSystemConfig) GetMacLimitControl() *MACLimitControlType {
	if m != nil {
		return m.MacLimitControl
	}
	return nil
}

type GlobalVrouterConfig struct {
	Uuid                       string                       `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                 string                       `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                 string                       `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                     []string                     `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                    *IdPermsType                 `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                string                       `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                *KeyValuePairs               `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                     *PermType2                   `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	EcmpHashingIncludeFields   *EcmpHashingIncludeFields    `protobuf:"bytes,9,opt,name=ecmp_hashing_include_fields,json=ecmpHashingIncludeFields" json:"ecmp_hashing_include_fields,omitempty"`
	FlowAgingTimeoutList       *FlowAgingTimeoutList        `protobuf:"bytes,10,opt,name=flow_aging_timeout_list,json=flowAgingTimeoutList" json:"flow_aging_timeout_list,omitempty"`
	ForwardingMode             string                       `protobuf:"bytes,11,opt,name=forwarding_mode,json=forwardingMode,proto3" json:"forwarding_mode,omitempty"`
	FlowExportRate             int64                        `protobuf:"varint,12,opt,name=flow_export_rate,json=flowExportRate,proto3" json:"flow_export_rate,omitempty"`
	LinklocalServices          *LinklocalServicesTypes      `protobuf:"bytes,13,opt,name=linklocal_services,json=linklocalServices" json:"linklocal_services,omitempty"`
	EncapsulationPriorities    *EncapsulationPrioritiesType `protobuf:"bytes,14,opt,name=encapsulation_priorities,json=encapsulationPriorities" json:"encapsulation_priorities,omitempty"`
	VxlanNetworkIdentifierMode string                       `protobuf:"bytes,15,opt,name=vxlan_network_identifier_mode,json=vxlanNetworkIdentifierMode,proto3" json:"vxlan_network_identifier_mode,omitempty"`
	EnableSecurityLogging      bool                         `protobuf:"varint,16,opt,name=enable_security_logging,json=enableSecurityLogging,proto3" json:"enable_security_logging,omitempty"`
}

func (m *GlobalVrouterConfig) Reset()                    { *m = GlobalVrouterConfig{} }
func (m *GlobalVrouterConfig) String() string            { return proto.CompactTextString(m) }
func (*GlobalVrouterConfig) ProtoMessage()               {}
func (*GlobalVrouterConfig) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{33} }

func (m *GlobalVrouterConfig) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *GlobalVrouterConfig) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *GlobalVrouterConfig) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *GlobalVrouterConfig) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *GlobalVrouterConfig) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *GlobalVrouterConfig) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *GlobalVrouterConfig) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *GlobalVrouterConfig) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *GlobalVrouterConfig) GetEcmpHashingIncludeFields() *EcmpHashingIncludeFields {
	if m != nil {
		return m.EcmpHashingIncludeFields
	}
	return nil
}

func (m *GlobalVrouterConfig) GetFlowAgingTimeoutList() *FlowAgingTimeoutList {
	if m != nil {
		return m.FlowAgingTimeoutList
	}
	return nil
}

func (m *GlobalVrouterConfig) GetForwardingMode() string {
	if m != nil {
		return m.ForwardingMode
	}
	return ""
}

func (m *GlobalVrouterConfig) GetFlowExportRate() int64 {
	if m != nil {
		return m.FlowExportRate
	}
	return 0
}

func (m *GlobalVrouterConfig) GetLinklocalServices() *LinklocalServicesTypes {
	if m != nil {
		return m.LinklocalServices
	}
	return nil
}

func (m *GlobalVrouterConfig) GetEncapsulationPriorities() *EncapsulationPrioritiesType {
	if m != nil {
		return m.EncapsulationPriorities
	}
	return nil
}

func (m *GlobalVrouterConfig) GetVxlanNetworkIdentifierMode() string {
	if m != nil {
		return m.VxlanNetworkIdentifierMode
	}
	return ""
}

func (m *GlobalVrouterConfig) GetEnableSecurityLogging() bool {
	if m != nil {
		return m.EnableSecurityLogging
	}
	return false
}

type InstanceIP struct {
	Uuid                  string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid            string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType            string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms               *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName           string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations           *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ServiceHealthCheckIp  bool           `protobuf:"varint,9,opt,name=service_health_check_ip,json=serviceHealthCheckIp,proto3" json:"service_health_check_ip,omitempty"`
	SecondaryIpTrackingIp *SubnetType    `protobuf:"bytes,10,opt,name=secondary_ip_tracking_ip,json=secondaryIpTrackingIp" json:"secondary_ip_tracking_ip,omitempty"`
	InstanceIpAddress     string         `protobuf:"bytes,11,opt,name=instance_ip_address,json=instanceIpAddress,proto3" json:"instance_ip_address,omitempty"`
	InstanceIpMode        string         `protobuf:"bytes,12,opt,name=instance_ip_mode,json=instanceIpMode,proto3" json:"instance_ip_mode,omitempty"`
	SubnetUuid            string         `protobuf:"bytes,13,opt,name=subnet_uuid,json=subnetUuid,proto3" json:"subnet_uuid,omitempty"`
	InstanceIpFamily      string         `protobuf:"bytes,14,opt,name=instance_ip_family,json=instanceIpFamily,proto3" json:"instance_ip_family,omitempty"`
	ServiceInstanceIp     bool           `protobuf:"varint,15,opt,name=service_instance_ip,json=serviceInstanceIp,proto3" json:"service_instance_ip,omitempty"`
	InstanceIpLocalIp     bool           `protobuf:"varint,16,opt,name=instance_ip_local_ip,json=instanceIpLocalIp,proto3" json:"instance_ip_local_ip,omitempty"`
	InstanceIpSecondary   bool           `protobuf:"varint,17,opt,name=instance_ip_secondary,json=instanceIpSecondary,proto3" json:"instance_ip_secondary,omitempty"`
}

func (m *InstanceIP) Reset()                    { *m = InstanceIP{} }
func (m *InstanceIP) String() string            { return proto.CompactTextString(m) }
func (*InstanceIP) ProtoMessage()               {}
func (*InstanceIP) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{34} }

func (m *InstanceIP) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *InstanceIP) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *InstanceIP) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *InstanceIP) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *InstanceIP) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *InstanceIP) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *InstanceIP) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *InstanceIP) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *InstanceIP) GetServiceHealthCheckIp() bool {
	if m != nil {
		return m.ServiceHealthCheckIp
	}
	return false
}

func (m *InstanceIP) GetSecondaryIpTrackingIp() *SubnetType {
	if m != nil {
		return m.SecondaryIpTrackingIp
	}
	return nil
}

func (m *InstanceIP) GetInstanceIpAddress() string {
	if m != nil {
		return m.InstanceIpAddress
	}
	return ""
}

func (m *InstanceIP) GetInstanceIpMode() string {
	if m != nil {
		return m.InstanceIpMode
	}
	return ""
}

func (m *InstanceIP) GetSubnetUuid() string {
	if m != nil {
		return m.SubnetUuid
	}
	return ""
}

func (m *InstanceIP) GetInstanceIpFamily() string {
	if m != nil {
		return m.InstanceIpFamily
	}
	return ""
}

func (m *InstanceIP) GetServiceInstanceIp() bool {
	if m != nil {
		return m.ServiceInstanceIp
	}
	return false
}

func (m *InstanceIP) GetInstanceIpLocalIp() bool {
	if m != nil {
		return m.InstanceIpLocalIp
	}
	return false
}

func (m *InstanceIP) GetInstanceIpSecondary() bool {
	if m != nil {
		return m.InstanceIpSecondary
	}
	return false
}

type InterfaceRouteTable struct {
	Uuid                      string          `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string          `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string          `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string        `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType    `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string          `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs  `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2      `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	InterfaceRouteTableRoutes *RouteTableType `protobuf:"bytes,9,opt,name=interface_route_table_routes,json=interfaceRouteTableRoutes" json:"interface_route_table_routes,omitempty"`
}

func (m *InterfaceRouteTable) Reset()                    { *m = InterfaceRouteTable{} }
func (m *InterfaceRouteTable) String() string            { return proto.CompactTextString(m) }
func (*InterfaceRouteTable) ProtoMessage()               {}
func (*InterfaceRouteTable) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{35} }

func (m *InterfaceRouteTable) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *InterfaceRouteTable) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *InterfaceRouteTable) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *InterfaceRouteTable) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *InterfaceRouteTable) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *InterfaceRouteTable) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *InterfaceRouteTable) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *InterfaceRouteTable) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *InterfaceRouteTable) GetInterfaceRouteTableRoutes() *RouteTableType {
	if m != nil {
		return m.InterfaceRouteTableRoutes
	}
	return nil
}

type LoadbalancerHealthmonitor struct {
	Uuid                                string                         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                          string                         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                          string                         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                              []string                       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                             *IdPermsType                   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                         string                         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                         *KeyValuePairs                 `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                              *PermType2                     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	LoadbalancerHealthmonitorProperties *LoadbalancerHealthmonitorType `protobuf:"bytes,9,opt,name=loadbalancer_healthmonitor_properties,json=loadbalancerHealthmonitorProperties" json:"loadbalancer_healthmonitor_properties,omitempty"`
}

func (m *LoadbalancerHealthmonitor) Reset()         { *m = LoadbalancerHealthmonitor{} }
func (m *LoadbalancerHealthmonitor) String() string { return proto.CompactTextString(m) }
func (*LoadbalancerHealthmonitor) ProtoMessage()    {}
func (*LoadbalancerHealthmonitor) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{36}
}

func (m *LoadbalancerHealthmonitor) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *LoadbalancerHealthmonitor) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *LoadbalancerHealthmonitor) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *LoadbalancerHealthmonitor) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *LoadbalancerHealthmonitor) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *LoadbalancerHealthmonitor) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *LoadbalancerHealthmonitor) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *LoadbalancerHealthmonitor) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *LoadbalancerHealthmonitor) GetLoadbalancerHealthmonitorProperties() *LoadbalancerHealthmonitorType {
	if m != nil {
		return m.LoadbalancerHealthmonitorProperties
	}
	return nil
}

type LoadbalancerListener struct {
	Uuid                           string                    `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                     string                    `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                     string                    `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                         []string                  `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                        *IdPermsType              `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                    string                    `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                    *KeyValuePairs            `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                         *PermType2                `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	LoadbalancerListenerProperties *LoadbalancerListenerType `protobuf:"bytes,9,opt,name=loadbalancer_listener_properties,json=loadbalancerListenerProperties" json:"loadbalancer_listener_properties,omitempty"`
}

func (m *LoadbalancerListener) Reset()                    { *m = LoadbalancerListener{} }
func (m *LoadbalancerListener) String() string            { return proto.CompactTextString(m) }
func (*LoadbalancerListener) ProtoMessage()               {}
func (*LoadbalancerListener) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{37} }

func (m *LoadbalancerListener) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *LoadbalancerListener) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *LoadbalancerListener) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *LoadbalancerListener) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *LoadbalancerListener) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *LoadbalancerListener) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *LoadbalancerListener) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *LoadbalancerListener) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *LoadbalancerListener) GetLoadbalancerListenerProperties() *LoadbalancerListenerType {
	if m != nil {
		return m.LoadbalancerListenerProperties
	}
	return nil
}

type LoadbalancerMember struct {
	Uuid                         string                  `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                   string                  `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                   string                  `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                       []string                `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                      *IdPermsType            `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                  string                  `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                  *KeyValuePairs          `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                       *PermType2              `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	LoadbalancerMemberProperties *LoadbalancerMemberType `protobuf:"bytes,9,opt,name=loadbalancer_member_properties,json=loadbalancerMemberProperties" json:"loadbalancer_member_properties,omitempty"`
}

func (m *LoadbalancerMember) Reset()                    { *m = LoadbalancerMember{} }
func (m *LoadbalancerMember) String() string            { return proto.CompactTextString(m) }
func (*LoadbalancerMember) ProtoMessage()               {}
func (*LoadbalancerMember) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{38} }

func (m *LoadbalancerMember) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *LoadbalancerMember) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *LoadbalancerMember) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *LoadbalancerMember) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *LoadbalancerMember) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *LoadbalancerMember) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *LoadbalancerMember) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *LoadbalancerMember) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *LoadbalancerMember) GetLoadbalancerMemberProperties() *LoadbalancerMemberType {
	if m != nil {
		return m.LoadbalancerMemberProperties
	}
	return nil
}

type LoadbalancerPool struct {
	Uuid                             string                `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                       string                `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                       string                `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                           []string              `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                          *IdPermsType          `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                      string                `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                      *KeyValuePairs        `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                           *PermType2            `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	LoadbalancerPoolProperties       *LoadbalancerPoolType `protobuf:"bytes,9,opt,name=loadbalancer_pool_properties,json=loadbalancerPoolProperties" json:"loadbalancer_pool_properties,omitempty"`
	LoadbalancerPoolCustomAttributes *KeyValuePairs        `protobuf:"bytes,10,opt,name=loadbalancer_pool_custom_attributes,json=loadbalancerPoolCustomAttributes" json:"loadbalancer_pool_custom_attributes,omitempty"`
	LoadbalancerPoolProvider         string                `protobuf:"bytes,11,opt,name=loadbalancer_pool_provider,json=loadbalancerPoolProvider,proto3" json:"loadbalancer_pool_provider,omitempty"`
}

func (m *LoadbalancerPool) Reset()                    { *m = LoadbalancerPool{} }
func (m *LoadbalancerPool) String() string            { return proto.CompactTextString(m) }
func (*LoadbalancerPool) ProtoMessage()               {}
func (*LoadbalancerPool) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{39} }

func (m *LoadbalancerPool) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *LoadbalancerPool) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *LoadbalancerPool) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *LoadbalancerPool) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *LoadbalancerPool) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *LoadbalancerPool) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *LoadbalancerPool) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *LoadbalancerPool) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *LoadbalancerPool) GetLoadbalancerPoolProperties() *LoadbalancerPoolType {
	if m != nil {
		return m.LoadbalancerPoolProperties
	}
	return nil
}

func (m *LoadbalancerPool) GetLoadbalancerPoolCustomAttributes() *KeyValuePairs {
	if m != nil {
		return m.LoadbalancerPoolCustomAttributes
	}
	return nil
}

func (m *LoadbalancerPool) GetLoadbalancerPoolProvider() string {
	if m != nil {
		return m.LoadbalancerPoolProvider
	}
	return ""
}

type Loadbalancer struct {
	Uuid                   string            `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid             string            `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType             string            `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                 []string          `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                *IdPermsType      `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName            string            `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations            *KeyValuePairs    `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                 *PermType2        `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	LoadbalancerProperties *LoadbalancerType `protobuf:"bytes,9,opt,name=loadbalancer_properties,json=loadbalancerProperties" json:"loadbalancer_properties,omitempty"`
	LoadbalancerProvider   string            `protobuf:"bytes,10,opt,name=loadbalancer_provider,json=loadbalancerProvider,proto3" json:"loadbalancer_provider,omitempty"`
}

func (m *Loadbalancer) Reset()                    { *m = Loadbalancer{} }
func (m *Loadbalancer) String() string            { return proto.CompactTextString(m) }
func (*Loadbalancer) ProtoMessage()               {}
func (*Loadbalancer) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{40} }

func (m *Loadbalancer) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Loadbalancer) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Loadbalancer) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Loadbalancer) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Loadbalancer) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Loadbalancer) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Loadbalancer) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Loadbalancer) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Loadbalancer) GetLoadbalancerProperties() *LoadbalancerType {
	if m != nil {
		return m.LoadbalancerProperties
	}
	return nil
}

func (m *Loadbalancer) GetLoadbalancerProvider() string {
	if m != nil {
		return m.LoadbalancerProvider
	}
	return ""
}

type LogicalInterface struct {
	Uuid                    string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid              string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType              string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                  []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                 *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName             string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations             *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                  *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	LogicalInterfaceVlanTag int64          `protobuf:"varint,9,opt,name=logical_interface_vlan_tag,json=logicalInterfaceVlanTag,proto3" json:"logical_interface_vlan_tag,omitempty"`
	LogicalInterfaceType    string         `protobuf:"bytes,10,opt,name=logical_interface_type,json=logicalInterfaceType,proto3" json:"logical_interface_type,omitempty"`
}

func (m *LogicalInterface) Reset()                    { *m = LogicalInterface{} }
func (m *LogicalInterface) String() string            { return proto.CompactTextString(m) }
func (*LogicalInterface) ProtoMessage()               {}
func (*LogicalInterface) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{41} }

func (m *LogicalInterface) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *LogicalInterface) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *LogicalInterface) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *LogicalInterface) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *LogicalInterface) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *LogicalInterface) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *LogicalInterface) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *LogicalInterface) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *LogicalInterface) GetLogicalInterfaceVlanTag() int64 {
	if m != nil {
		return m.LogicalInterfaceVlanTag
	}
	return 0
}

func (m *LogicalInterface) GetLogicalInterfaceType() string {
	if m != nil {
		return m.LogicalInterfaceType
	}
	return ""
}

type LogicalRouter struct {
	Uuid                      string           `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string           `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string           `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string         `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType     `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string           `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs   `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2       `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	VxlanNetworkIdentifier    string           `protobuf:"bytes,9,opt,name=vxlan_network_identifier,json=vxlanNetworkIdentifier,proto3" json:"vxlan_network_identifier,omitempty"`
	ConfiguredRouteTargetList *RouteTargetList `protobuf:"bytes,10,opt,name=configured_route_target_list,json=configuredRouteTargetList" json:"configured_route_target_list,omitempty"`
}

func (m *LogicalRouter) Reset()                    { *m = LogicalRouter{} }
func (m *LogicalRouter) String() string            { return proto.CompactTextString(m) }
func (*LogicalRouter) ProtoMessage()               {}
func (*LogicalRouter) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{42} }

func (m *LogicalRouter) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *LogicalRouter) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *LogicalRouter) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *LogicalRouter) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *LogicalRouter) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *LogicalRouter) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *LogicalRouter) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *LogicalRouter) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *LogicalRouter) GetVxlanNetworkIdentifier() string {
	if m != nil {
		return m.VxlanNetworkIdentifier
	}
	return ""
}

func (m *LogicalRouter) GetConfiguredRouteTargetList() *RouteTargetList {
	if m != nil {
		return m.ConfiguredRouteTargetList
	}
	return nil
}

type Namespace struct {
	Uuid          string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid    string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType    string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName        []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms       *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName   string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations   *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2        *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	NamespaceCidr *SubnetType    `protobuf:"bytes,9,opt,name=namespace_cidr,json=namespaceCidr" json:"namespace_cidr,omitempty"`
}

func (m *Namespace) Reset()                    { *m = Namespace{} }
func (m *Namespace) String() string            { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()               {}
func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{43} }

func (m *Namespace) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Namespace) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Namespace) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Namespace) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Namespace) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Namespace) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Namespace) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Namespace) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Namespace) GetNamespaceCidr() *SubnetType {
	if m != nil {
		return m.NamespaceCidr
	}
	return nil
}

type NetworkDeviceConfig struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *NetworkDeviceConfig) Reset()                    { *m = NetworkDeviceConfig{} }
func (m *NetworkDeviceConfig) String() string            { return proto.CompactTextString(m) }
func (*NetworkDeviceConfig) ProtoMessage()               {}
func (*NetworkDeviceConfig) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{44} }

func (m *NetworkDeviceConfig) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *NetworkDeviceConfig) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *NetworkDeviceConfig) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *NetworkDeviceConfig) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *NetworkDeviceConfig) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *NetworkDeviceConfig) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *NetworkDeviceConfig) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *NetworkDeviceConfig) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type NetworkIpam struct {
	Uuid             string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid       string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType       string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName           []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms          *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName      string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations      *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2           *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	NetworkIpamMgmt  *IpamType      `protobuf:"bytes,9,opt,name=network_ipam_mgmt,json=networkIpamMgmt" json:"network_ipam_mgmt,omitempty"`
	IpamSubnets      *IpamSubnets   `protobuf:"bytes,10,opt,name=ipam_subnets,json=ipamSubnets" json:"ipam_subnets,omitempty"`
	IpamSubnetMethod string         `protobuf:"bytes,11,opt,name=ipam_subnet_method,json=ipamSubnetMethod,proto3" json:"ipam_subnet_method,omitempty"`
}

func (m *NetworkIpam) Reset()                    { *m = NetworkIpam{} }
func (m *NetworkIpam) String() string            { return proto.CompactTextString(m) }
func (*NetworkIpam) ProtoMessage()               {}
func (*NetworkIpam) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{45} }

func (m *NetworkIpam) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *NetworkIpam) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *NetworkIpam) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *NetworkIpam) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *NetworkIpam) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *NetworkIpam) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *NetworkIpam) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *NetworkIpam) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *NetworkIpam) GetNetworkIpamMgmt() *IpamType {
	if m != nil {
		return m.NetworkIpamMgmt
	}
	return nil
}

func (m *NetworkIpam) GetIpamSubnets() *IpamSubnets {
	if m != nil {
		return m.IpamSubnets
	}
	return nil
}

func (m *NetworkIpam) GetIpamSubnetMethod() string {
	if m != nil {
		return m.IpamSubnetMethod
	}
	return ""
}

type NetworkPolicy struct {
	Uuid                 string             `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid           string             `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType           string             `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName               []string           `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms              *IdPermsType       `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName          string             `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations          *KeyValuePairs     `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2               *PermType2         `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	NetworkPolicyEntries *PolicyEntriesType `protobuf:"bytes,9,opt,name=network_policy_entries,json=networkPolicyEntries" json:"network_policy_entries,omitempty"`
}

func (m *NetworkPolicy) Reset()                    { *m = NetworkPolicy{} }
func (m *NetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*NetworkPolicy) ProtoMessage()               {}
func (*NetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{46} }

func (m *NetworkPolicy) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *NetworkPolicy) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *NetworkPolicy) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *NetworkPolicy) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *NetworkPolicy) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *NetworkPolicy) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *NetworkPolicy) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *NetworkPolicy) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *NetworkPolicy) GetNetworkPolicyEntries() *PolicyEntriesType {
	if m != nil {
		return m.NetworkPolicyEntries
	}
	return nil
}

type PeeringPolicy struct {
	Uuid           string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid     string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType     string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName         []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms        *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName    string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations    *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2         *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	PeeringService string         `protobuf:"bytes,9,opt,name=peering_service,json=peeringService,proto3" json:"peering_service,omitempty"`
}

func (m *PeeringPolicy) Reset()                    { *m = PeeringPolicy{} }
func (m *PeeringPolicy) String() string            { return proto.CompactTextString(m) }
func (*PeeringPolicy) ProtoMessage()               {}
func (*PeeringPolicy) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{47} }

func (m *PeeringPolicy) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *PeeringPolicy) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *PeeringPolicy) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *PeeringPolicy) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *PeeringPolicy) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *PeeringPolicy) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *PeeringPolicy) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *PeeringPolicy) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *PeeringPolicy) GetPeeringService() string {
	if m != nil {
		return m.PeeringService
	}
	return ""
}

type PhysicalInterface struct {
	Uuid                      string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	EthernetSegmentIdentifier string         `protobuf:"bytes,9,opt,name=ethernet_segment_identifier,json=ethernetSegmentIdentifier,proto3" json:"ethernet_segment_identifier,omitempty"`
}

func (m *PhysicalInterface) Reset()                    { *m = PhysicalInterface{} }
func (m *PhysicalInterface) String() string            { return proto.CompactTextString(m) }
func (*PhysicalInterface) ProtoMessage()               {}
func (*PhysicalInterface) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{48} }

func (m *PhysicalInterface) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *PhysicalInterface) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *PhysicalInterface) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *PhysicalInterface) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *PhysicalInterface) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *PhysicalInterface) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *PhysicalInterface) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *PhysicalInterface) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *PhysicalInterface) GetEthernetSegmentIdentifier() string {
	if m != nil {
		return m.EthernetSegmentIdentifier
	}
	return ""
}

type PhysicalRouter struct {
	Uuid                            string              `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                      string              `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                      string              `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                          []string            `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                         *IdPermsType        `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                     string              `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                     *KeyValuePairs      `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                          *PermType2          `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	PhysicalRouterManagementIp      string              `protobuf:"bytes,9,opt,name=physical_router_management_ip,json=physicalRouterManagementIp,proto3" json:"physical_router_management_ip,omitempty"`
	PhysicalRouterSnmpCredentials   *SNMPCredentials    `protobuf:"bytes,10,opt,name=physical_router_snmp_credentials,json=physicalRouterSnmpCredentials" json:"physical_router_snmp_credentials,omitempty"`
	PhysicalRouterRole              string              `protobuf:"bytes,11,opt,name=physical_router_role,json=physicalRouterRole,proto3" json:"physical_router_role,omitempty"`
	PhysicalRouterUserCredentials   *UserCredentials    `protobuf:"bytes,12,opt,name=physical_router_user_credentials,json=physicalRouterUserCredentials" json:"physical_router_user_credentials,omitempty"`
	PhysicalRouterVendorName        string              `protobuf:"bytes,13,opt,name=physical_router_vendor_name,json=physicalRouterVendorName,proto3" json:"physical_router_vendor_name,omitempty"`
	PhysicalRouterVncManaged        bool                `protobuf:"varint,14,opt,name=physical_router_vnc_managed,json=physicalRouterVncManaged,proto3" json:"physical_router_vnc_managed,omitempty"`
	PhysicalRouterProductName       string              `protobuf:"bytes,15,opt,name=physical_router_product_name,json=physicalRouterProductName,proto3" json:"physical_router_product_name,omitempty"`
	PhysicalRouterLldp              bool                `protobuf:"varint,16,opt,name=physical_router_lldp,json=physicalRouterLldp,proto3" json:"physical_router_lldp,omitempty"`
	PhysicalRouterLoopbackIp        string              `protobuf:"bytes,17,opt,name=physical_router_loopback_ip,json=physicalRouterLoopbackIp,proto3" json:"physical_router_loopback_ip,omitempty"`
	PhysicalRouterImageUri          string              `protobuf:"bytes,18,opt,name=physical_router_image_uri,json=physicalRouterImageUri,proto3" json:"physical_router_image_uri,omitempty"`
	TelemetryInfo                   *TelemetryStateInfo `protobuf:"bytes,19,opt,name=telemetry_info,json=telemetryInfo" json:"telemetry_info,omitempty"`
	PhysicalRouterSnmp              bool                `protobuf:"varint,20,opt,name=physical_router_snmp,json=physicalRouterSnmp,proto3" json:"physical_router_snmp,omitempty"`
	PhysicalRouterDataplaneIp       string              `protobuf:"bytes,21,opt,name=physical_router_dataplane_ip,json=physicalRouterDataplaneIp,proto3" json:"physical_router_dataplane_ip,omitempty"`
	PhysicalRouterJunosServicePorts *JunosServicePorts  `protobuf:"bytes,22,opt,name=physical_router_junos_service_ports,json=physicalRouterJunosServicePorts" json:"physical_router_junos_service_ports,omitempty"`
}

func (m *PhysicalRouter) Reset()                    { *m = PhysicalRouter{} }
func (m *PhysicalRouter) String() string            { return proto.CompactTextString(m) }
func (*PhysicalRouter) ProtoMessage()               {}
func (*PhysicalRouter) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{49} }

func (m *PhysicalRouter) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *PhysicalRouter) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *PhysicalRouter) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *PhysicalRouter) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *PhysicalRouter) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *PhysicalRouter) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *PhysicalRouter) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *PhysicalRouter) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *PhysicalRouter) GetPhysicalRouterManagementIp() string {
	if m != nil {
		return m.PhysicalRouterManagementIp
	}
	return ""
}

func (m *PhysicalRouter) GetPhysicalRouterSnmpCredentials() *SNMPCredentials {
	if m != nil {
		return m.PhysicalRouterSnmpCredentials
	}
	return nil
}

func (m *PhysicalRouter) GetPhysicalRouterRole() string {
	if m != nil {
		return m.PhysicalRouterRole
	}
	return ""
}

func (m *PhysicalRouter) GetPhysicalRouterUserCredentials() *UserCredentials {
	if m != nil {
		return m.PhysicalRouterUserCredentials
	}
	return nil
}

func (m *PhysicalRouter) GetPhysicalRouterVendorName() string {
	if m != nil {
		return m.PhysicalRouterVendorName
	}
	return ""
}

func (m *PhysicalRouter) GetPhysicalRouterVncManaged() bool {
	if m != nil {
		return m.PhysicalRouterVncManaged
	}
	return false
}

func (m *PhysicalRouter) GetPhysicalRouterProductName() string {
	if m != nil {
		return m.PhysicalRouterProductName
	}
	return ""
}

func (m *PhysicalRouter) GetPhysicalRouterLldp() bool {
	if m != nil {
		return m.PhysicalRouterLldp
	}
	return false
}

func (m *PhysicalRouter) GetPhysicalRouterLoopbackIp() string {
	if m != nil {
		return m.PhysicalRouterLoopbackIp
	}
	return ""
}

func (m *PhysicalRouter) GetPhysicalRouterImageUri() string {
	if m != nil {
		return m.PhysicalRouterImageUri
	}
	return ""
}

func (m *PhysicalRouter) GetTelemetryInfo() *TelemetryStateInfo {
	if m != nil {
		return m.TelemetryInfo
	}
	return nil
}

func (m *PhysicalRouter) GetPhysicalRouterSnmp() bool {
	if m != nil {
		return m.PhysicalRouterSnmp
	}
	return false
}

func (m *PhysicalRouter) GetPhysicalRouterDataplaneIp() string {
	if m != nil {
		return m.PhysicalRouterDataplaneIp
	}
	return ""
}

func (m *PhysicalRouter) GetPhysicalRouterJunosServicePorts() *JunosServicePorts {
	if m != nil {
		return m.PhysicalRouterJunosServicePorts
	}
	return nil
}

type PolicyManagement struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *PolicyManagement) Reset()                    { *m = PolicyManagement{} }
func (m *PolicyManagement) String() string            { return proto.CompactTextString(m) }
func (*PolicyManagement) ProtoMessage()               {}
func (*PolicyManagement) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{50} }

func (m *PolicyManagement) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *PolicyManagement) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *PolicyManagement) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *PolicyManagement) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *PolicyManagement) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *PolicyManagement) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *PolicyManagement) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *PolicyManagement) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type PortTuple struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *PortTuple) Reset()                    { *m = PortTuple{} }
func (m *PortTuple) String() string            { return proto.CompactTextString(m) }
func (*PortTuple) ProtoMessage()               {}
func (*PortTuple) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{51} }

func (m *PortTuple) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *PortTuple) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *PortTuple) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *PortTuple) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *PortTuple) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *PortTuple) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *PortTuple) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *PortTuple) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type Project struct {
	Uuid         string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid   string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType   string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName       []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms      *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName  string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations  *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2       *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	VxlanRouting bool           `protobuf:"varint,9,opt,name=vxlan_routing,json=vxlanRouting,proto3" json:"vxlan_routing,omitempty"`
	AlarmEnable  bool           `protobuf:"varint,10,opt,name=alarm_enable,json=alarmEnable,proto3" json:"alarm_enable,omitempty"`
	Quota        *QuotaType     `protobuf:"bytes,11,opt,name=quota" json:"quota,omitempty"`
}

func (m *Project) Reset()                    { *m = Project{} }
func (m *Project) String() string            { return proto.CompactTextString(m) }
func (*Project) ProtoMessage()               {}
func (*Project) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{52} }

func (m *Project) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Project) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Project) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Project) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Project) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Project) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Project) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Project) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Project) GetVxlanRouting() bool {
	if m != nil {
		return m.VxlanRouting
	}
	return false
}

func (m *Project) GetAlarmEnable() bool {
	if m != nil {
		return m.AlarmEnable
	}
	return false
}

func (m *Project) GetQuota() *QuotaType {
	if m != nil {
		return m.Quota
	}
	return nil
}

type ProviderAttachment struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *ProviderAttachment) Reset()                    { *m = ProviderAttachment{} }
func (m *ProviderAttachment) String() string            { return proto.CompactTextString(m) }
func (*ProviderAttachment) ProtoMessage()               {}
func (*ProviderAttachment) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{53} }

func (m *ProviderAttachment) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ProviderAttachment) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ProviderAttachment) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ProviderAttachment) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ProviderAttachment) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ProviderAttachment) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ProviderAttachment) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ProviderAttachment) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type QosConfig struct {
	Uuid                     string                     `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid               string                     `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType               string                     `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                   []string                   `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                  *IdPermsType               `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName              string                     `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations              *KeyValuePairs             `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                   *PermType2                 `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	QosConfigType            string                     `protobuf:"bytes,9,opt,name=qos_config_type,json=qosConfigType,proto3" json:"qos_config_type,omitempty"`
	MplsExpEntries           *QosIdForwardingClassPairs `protobuf:"bytes,10,opt,name=mpls_exp_entries,json=mplsExpEntries" json:"mpls_exp_entries,omitempty"`
	VlanPriorityEntries      *QosIdForwardingClassPairs `protobuf:"bytes,11,opt,name=vlan_priority_entries,json=vlanPriorityEntries" json:"vlan_priority_entries,omitempty"`
	DefaultForwardingClassId int64                      `protobuf:"varint,12,opt,name=default_forwarding_class_id,json=defaultForwardingClassId,proto3" json:"default_forwarding_class_id,omitempty"`
	DscpEntries              *QosIdForwardingClassPairs `protobuf:"bytes,13,opt,name=dscp_entries,json=dscpEntries" json:"dscp_entries,omitempty"`
}

func (m *QosConfig) Reset()                    { *m = QosConfig{} }
func (m *QosConfig) String() string            { return proto.CompactTextString(m) }
func (*QosConfig) ProtoMessage()               {}
func (*QosConfig) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{54} }

func (m *QosConfig) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *QosConfig) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *QosConfig) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *QosConfig) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *QosConfig) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *QosConfig) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *QosConfig) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *QosConfig) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *QosConfig) GetQosConfigType() string {
	if m != nil {
		return m.QosConfigType
	}
	return ""
}

func (m *QosConfig) GetMplsExpEntries() *QosIdForwardingClassPairs {
	if m != nil {
		return m.MplsExpEntries
	}
	return nil
}

func (m *QosConfig) GetVlanPriorityEntries() *QosIdForwardingClassPairs {
	if m != nil {
		return m.VlanPriorityEntries
	}
	return nil
}

func (m *QosConfig) GetDefaultForwardingClassId() int64 {
	if m != nil {
		return m.DefaultForwardingClassId
	}
	return 0
}

func (m *QosConfig) GetDscpEntries() *QosIdForwardingClassPairs {
	if m != nil {
		return m.DscpEntries
	}
	return nil
}

type QosQueue struct {
	Uuid               string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid         string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType         string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName             []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms            *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName        string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations        *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2             *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	QosQueueIdentifier int64          `protobuf:"varint,9,opt,name=qos_queue_identifier,json=qosQueueIdentifier,proto3" json:"qos_queue_identifier,omitempty"`
	MaxBandwidth       int64          `protobuf:"varint,10,opt,name=max_bandwidth,json=maxBandwidth,proto3" json:"max_bandwidth,omitempty"`
	MinBandwidth       int64          `protobuf:"varint,11,opt,name=min_bandwidth,json=minBandwidth,proto3" json:"min_bandwidth,omitempty"`
}

func (m *QosQueue) Reset()                    { *m = QosQueue{} }
func (m *QosQueue) String() string            { return proto.CompactTextString(m) }
func (*QosQueue) ProtoMessage()               {}
func (*QosQueue) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{55} }

func (m *QosQueue) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *QosQueue) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *QosQueue) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *QosQueue) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *QosQueue) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *QosQueue) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *QosQueue) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *QosQueue) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *QosQueue) GetQosQueueIdentifier() int64 {
	if m != nil {
		return m.QosQueueIdentifier
	}
	return 0
}

func (m *QosQueue) GetMaxBandwidth() int64 {
	if m != nil {
		return m.MaxBandwidth
	}
	return 0
}

func (m *QosQueue) GetMinBandwidth() int64 {
	if m != nil {
		return m.MinBandwidth
	}
	return 0
}

type RouteAggregate struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *RouteAggregate) Reset()                    { *m = RouteAggregate{} }
func (m *RouteAggregate) String() string            { return proto.CompactTextString(m) }
func (*RouteAggregate) ProtoMessage()               {}
func (*RouteAggregate) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{56} }

func (m *RouteAggregate) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *RouteAggregate) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *RouteAggregate) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *RouteAggregate) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *RouteAggregate) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *RouteAggregate) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *RouteAggregate) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *RouteAggregate) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type RouteTable struct {
	Uuid        string          `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string          `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string          `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string        `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType    `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string          `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs  `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2      `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	Routes      *RouteTableType `protobuf:"bytes,9,opt,name=routes" json:"routes,omitempty"`
}

func (m *RouteTable) Reset()                    { *m = RouteTable{} }
func (m *RouteTable) String() string            { return proto.CompactTextString(m) }
func (*RouteTable) ProtoMessage()               {}
func (*RouteTable) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{57} }

func (m *RouteTable) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *RouteTable) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *RouteTable) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *RouteTable) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *RouteTable) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *RouteTable) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *RouteTable) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *RouteTable) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *RouteTable) GetRoutes() *RouteTableType {
	if m != nil {
		return m.Routes
	}
	return nil
}

type RouteTarget struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *RouteTarget) Reset()                    { *m = RouteTarget{} }
func (m *RouteTarget) String() string            { return proto.CompactTextString(m) }
func (*RouteTarget) ProtoMessage()               {}
func (*RouteTarget) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{58} }

func (m *RouteTarget) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *RouteTarget) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *RouteTarget) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *RouteTarget) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *RouteTarget) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *RouteTarget) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *RouteTarget) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *RouteTarget) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type RoutingInstance struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *RoutingInstance) Reset()                    { *m = RoutingInstance{} }
func (m *RoutingInstance) String() string            { return proto.CompactTextString(m) }
func (*RoutingInstance) ProtoMessage()               {}
func (*RoutingInstance) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{59} }

func (m *RoutingInstance) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *RoutingInstance) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *RoutingInstance) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *RoutingInstance) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *RoutingInstance) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *RoutingInstance) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *RoutingInstance) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *RoutingInstance) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type RoutingPolicy struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *RoutingPolicy) Reset()                    { *m = RoutingPolicy{} }
func (m *RoutingPolicy) String() string            { return proto.CompactTextString(m) }
func (*RoutingPolicy) ProtoMessage()               {}
func (*RoutingPolicy) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{60} }

func (m *RoutingPolicy) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *RoutingPolicy) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *RoutingPolicy) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *RoutingPolicy) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *RoutingPolicy) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *RoutingPolicy) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *RoutingPolicy) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *RoutingPolicy) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type SecurityGroup struct {
	Uuid                      string             `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string             `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string             `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string           `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType       `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string             `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs     `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2         `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	SecurityGroupEntries      *PolicyEntriesType `protobuf:"bytes,9,opt,name=security_group_entries,json=securityGroupEntries" json:"security_group_entries,omitempty"`
	ConfiguredSecurityGroupId int64              `protobuf:"varint,10,opt,name=configured_security_group_id,json=configuredSecurityGroupId,proto3" json:"configured_security_group_id,omitempty"`
	SecurityGroupId           int64              `protobuf:"varint,11,opt,name=security_group_id,json=securityGroupId,proto3" json:"security_group_id,omitempty"`
}

func (m *SecurityGroup) Reset()                    { *m = SecurityGroup{} }
func (m *SecurityGroup) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroup) ProtoMessage()               {}
func (*SecurityGroup) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{61} }

func (m *SecurityGroup) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *SecurityGroup) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *SecurityGroup) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *SecurityGroup) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *SecurityGroup) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *SecurityGroup) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *SecurityGroup) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *SecurityGroup) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *SecurityGroup) GetSecurityGroupEntries() *PolicyEntriesType {
	if m != nil {
		return m.SecurityGroupEntries
	}
	return nil
}

func (m *SecurityGroup) GetConfiguredSecurityGroupId() int64 {
	if m != nil {
		return m.ConfiguredSecurityGroupId
	}
	return 0
}

func (m *SecurityGroup) GetSecurityGroupId() int64 {
	if m != nil {
		return m.SecurityGroupId
	}
	return 0
}

type SecurityLoggingObject struct {
	Uuid                       string                             `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                 string                             `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                 string                             `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                     []string                           `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                    *IdPermsType                       `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                string                             `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                *KeyValuePairs                     `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                     *PermType2                         `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	SecurityLoggingObjectRules *SecurityLoggingObjectRuleListType `protobuf:"bytes,9,opt,name=security_logging_object_rules,json=securityLoggingObjectRules" json:"security_logging_object_rules,omitempty"`
	SecurityLoggingObjectRate  int64                              `protobuf:"varint,10,opt,name=security_logging_object_rate,json=securityLoggingObjectRate,proto3" json:"security_logging_object_rate,omitempty"`
}

func (m *SecurityLoggingObject) Reset()                    { *m = SecurityLoggingObject{} }
func (m *SecurityLoggingObject) String() string            { return proto.CompactTextString(m) }
func (*SecurityLoggingObject) ProtoMessage()               {}
func (*SecurityLoggingObject) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{62} }

func (m *SecurityLoggingObject) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *SecurityLoggingObject) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *SecurityLoggingObject) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *SecurityLoggingObject) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *SecurityLoggingObject) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *SecurityLoggingObject) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *SecurityLoggingObject) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *SecurityLoggingObject) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *SecurityLoggingObject) GetSecurityLoggingObjectRules() *SecurityLoggingObjectRuleListType {
	if m != nil {
		return m.SecurityLoggingObjectRules
	}
	return nil
}

func (m *SecurityLoggingObject) GetSecurityLoggingObjectRate() int64 {
	if m != nil {
		return m.SecurityLoggingObjectRate
	}
	return 0
}

type ServiceAppliance struct {
	Uuid                            string           `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                      string           `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                      string           `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                          []string         `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                         *IdPermsType     `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                     string           `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                     *KeyValuePairs   `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                          *PermType2       `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ServiceApplianceUserCredentials *UserCredentials `protobuf:"bytes,9,opt,name=service_appliance_user_credentials,json=serviceApplianceUserCredentials" json:"service_appliance_user_credentials,omitempty"`
	ServiceApplianceIpAddress       string           `protobuf:"bytes,10,opt,name=service_appliance_ip_address,json=serviceApplianceIpAddress,proto3" json:"service_appliance_ip_address,omitempty"`
	ServiceApplianceProperties      *KeyValuePairs   `protobuf:"bytes,11,opt,name=service_appliance_properties,json=serviceApplianceProperties" json:"service_appliance_properties,omitempty"`
}

func (m *ServiceAppliance) Reset()                    { *m = ServiceAppliance{} }
func (m *ServiceAppliance) String() string            { return proto.CompactTextString(m) }
func (*ServiceAppliance) ProtoMessage()               {}
func (*ServiceAppliance) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{63} }

func (m *ServiceAppliance) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ServiceAppliance) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ServiceAppliance) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ServiceAppliance) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ServiceAppliance) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ServiceAppliance) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ServiceAppliance) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceAppliance) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ServiceAppliance) GetServiceApplianceUserCredentials() *UserCredentials {
	if m != nil {
		return m.ServiceApplianceUserCredentials
	}
	return nil
}

func (m *ServiceAppliance) GetServiceApplianceIpAddress() string {
	if m != nil {
		return m.ServiceApplianceIpAddress
	}
	return ""
}

func (m *ServiceAppliance) GetServiceApplianceProperties() *KeyValuePairs {
	if m != nil {
		return m.ServiceApplianceProperties
	}
	return nil
}

type ServiceApplianceSet struct {
	Uuid                          string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                    string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                    string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                        []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                       *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                   string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                   *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                        *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ServiceApplianceSetProperties *KeyValuePairs `protobuf:"bytes,9,opt,name=service_appliance_set_properties,json=serviceApplianceSetProperties" json:"service_appliance_set_properties,omitempty"`
	ServiceApplianceHaMode        string         `protobuf:"bytes,10,opt,name=service_appliance_ha_mode,json=serviceApplianceHaMode,proto3" json:"service_appliance_ha_mode,omitempty"`
	ServiceApplianceDriver        string         `protobuf:"bytes,11,opt,name=service_appliance_driver,json=serviceApplianceDriver,proto3" json:"service_appliance_driver,omitempty"`
}

func (m *ServiceApplianceSet) Reset()                    { *m = ServiceApplianceSet{} }
func (m *ServiceApplianceSet) String() string            { return proto.CompactTextString(m) }
func (*ServiceApplianceSet) ProtoMessage()               {}
func (*ServiceApplianceSet) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{64} }

func (m *ServiceApplianceSet) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ServiceApplianceSet) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ServiceApplianceSet) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ServiceApplianceSet) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ServiceApplianceSet) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ServiceApplianceSet) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ServiceApplianceSet) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceApplianceSet) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ServiceApplianceSet) GetServiceApplianceSetProperties() *KeyValuePairs {
	if m != nil {
		return m.ServiceApplianceSetProperties
	}
	return nil
}

func (m *ServiceApplianceSet) GetServiceApplianceHaMode() string {
	if m != nil {
		return m.ServiceApplianceHaMode
	}
	return ""
}

func (m *ServiceApplianceSet) GetServiceApplianceDriver() string {
	if m != nil {
		return m.ServiceApplianceDriver
	}
	return ""
}

type ServiceConnectionModule struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ServiceType string         `protobuf:"bytes,9,opt,name=service_type,json=serviceType,proto3" json:"service_type,omitempty"`
	E2Service   string         `protobuf:"bytes,10,opt,name=e2_service,json=e2Service,proto3" json:"e2_service,omitempty"`
}

func (m *ServiceConnectionModule) Reset()                    { *m = ServiceConnectionModule{} }
func (m *ServiceConnectionModule) String() string            { return proto.CompactTextString(m) }
func (*ServiceConnectionModule) ProtoMessage()               {}
func (*ServiceConnectionModule) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{65} }

func (m *ServiceConnectionModule) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ServiceConnectionModule) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ServiceConnectionModule) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ServiceConnectionModule) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ServiceConnectionModule) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ServiceConnectionModule) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ServiceConnectionModule) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceConnectionModule) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ServiceConnectionModule) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

func (m *ServiceConnectionModule) GetE2Service() string {
	if m != nil {
		return m.E2Service
	}
	return ""
}

type ServiceEndpoint struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *ServiceEndpoint) Reset()                    { *m = ServiceEndpoint{} }
func (m *ServiceEndpoint) String() string            { return proto.CompactTextString(m) }
func (*ServiceEndpoint) ProtoMessage()               {}
func (*ServiceEndpoint) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{66} }

func (m *ServiceEndpoint) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ServiceEndpoint) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ServiceEndpoint) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ServiceEndpoint) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ServiceEndpoint) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ServiceEndpoint) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ServiceEndpoint) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceEndpoint) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type ServiceGroup struct {
	Uuid                            string                    `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                      string                    `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                      string                    `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                          []string                  `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                         *IdPermsType              `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                     string                    `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                     *KeyValuePairs            `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                          *PermType2                `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ServiceGroupFirewallServiceList *FirewallServiceGroupType `protobuf:"bytes,9,opt,name=service_group_firewall_service_list,json=serviceGroupFirewallServiceList" json:"service_group_firewall_service_list,omitempty"`
}

func (m *ServiceGroup) Reset()                    { *m = ServiceGroup{} }
func (m *ServiceGroup) String() string            { return proto.CompactTextString(m) }
func (*ServiceGroup) ProtoMessage()               {}
func (*ServiceGroup) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{67} }

func (m *ServiceGroup) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ServiceGroup) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ServiceGroup) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ServiceGroup) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ServiceGroup) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ServiceGroup) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ServiceGroup) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceGroup) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ServiceGroup) GetServiceGroupFirewallServiceList() *FirewallServiceGroupType {
	if m != nil {
		return m.ServiceGroupFirewallServiceList
	}
	return nil
}

type ServiceHealthCheck struct {
	Uuid                         string                  `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                   string                  `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                   string                  `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                       []string                `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                      *IdPermsType            `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                  string                  `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                  *KeyValuePairs          `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                       *PermType2              `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ServiceHealthCheckProperties *ServiceHealthCheckType `protobuf:"bytes,9,opt,name=service_health_check_properties,json=serviceHealthCheckProperties" json:"service_health_check_properties,omitempty"`
}

func (m *ServiceHealthCheck) Reset()                    { *m = ServiceHealthCheck{} }
func (m *ServiceHealthCheck) String() string            { return proto.CompactTextString(m) }
func (*ServiceHealthCheck) ProtoMessage()               {}
func (*ServiceHealthCheck) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{68} }

func (m *ServiceHealthCheck) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ServiceHealthCheck) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ServiceHealthCheck) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ServiceHealthCheck) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ServiceHealthCheck) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ServiceHealthCheck) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ServiceHealthCheck) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceHealthCheck) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ServiceHealthCheck) GetServiceHealthCheckProperties() *ServiceHealthCheckType {
	if m != nil {
		return m.ServiceHealthCheckProperties
	}
	return nil
}

type ServiceInstance struct {
	Uuid                      string               `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string               `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string               `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string             `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType         `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string               `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs       `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2           `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ServiceInstanceBindings   *KeyValuePairs       `protobuf:"bytes,9,opt,name=service_instance_bindings,json=serviceInstanceBindings" json:"service_instance_bindings,omitempty"`
	ServiceInstanceProperties *ServiceInstanceType `protobuf:"bytes,10,opt,name=service_instance_properties,json=serviceInstanceProperties" json:"service_instance_properties,omitempty"`
}

func (m *ServiceInstance) Reset()                    { *m = ServiceInstance{} }
func (m *ServiceInstance) String() string            { return proto.CompactTextString(m) }
func (*ServiceInstance) ProtoMessage()               {}
func (*ServiceInstance) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{69} }

func (m *ServiceInstance) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ServiceInstance) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ServiceInstance) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ServiceInstance) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ServiceInstance) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ServiceInstance) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ServiceInstance) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceInstance) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ServiceInstance) GetServiceInstanceBindings() *KeyValuePairs {
	if m != nil {
		return m.ServiceInstanceBindings
	}
	return nil
}

func (m *ServiceInstance) GetServiceInstanceProperties() *ServiceInstanceType {
	if m != nil {
		return m.ServiceInstanceProperties
	}
	return nil
}

type ServiceObject struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *ServiceObject) Reset()                    { *m = ServiceObject{} }
func (m *ServiceObject) String() string            { return proto.CompactTextString(m) }
func (*ServiceObject) ProtoMessage()               {}
func (*ServiceObject) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{70} }

func (m *ServiceObject) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ServiceObject) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ServiceObject) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ServiceObject) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ServiceObject) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ServiceObject) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ServiceObject) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceObject) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type ServiceTemplate struct {
	Uuid                      string               `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string               `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string               `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string             `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType         `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string               `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs       `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2           `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ServiceTemplateProperties *ServiceTemplateType `protobuf:"bytes,9,opt,name=service_template_properties,json=serviceTemplateProperties" json:"service_template_properties,omitempty"`
}

func (m *ServiceTemplate) Reset()                    { *m = ServiceTemplate{} }
func (m *ServiceTemplate) String() string            { return proto.CompactTextString(m) }
func (*ServiceTemplate) ProtoMessage()               {}
func (*ServiceTemplate) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{71} }

func (m *ServiceTemplate) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ServiceTemplate) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ServiceTemplate) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ServiceTemplate) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ServiceTemplate) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ServiceTemplate) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ServiceTemplate) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceTemplate) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ServiceTemplate) GetServiceTemplateProperties() *ServiceTemplateType {
	if m != nil {
		return m.ServiceTemplateProperties
	}
	return nil
}

type Subnet struct {
	Uuid           string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid     string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType     string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName         []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms        *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName    string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations    *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2         *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	SubnetIpPrefix *SubnetType    `protobuf:"bytes,9,opt,name=subnet_ip_prefix,json=subnetIpPrefix" json:"subnet_ip_prefix,omitempty"`
}

func (m *Subnet) Reset()                    { *m = Subnet{} }
func (m *Subnet) String() string            { return proto.CompactTextString(m) }
func (*Subnet) ProtoMessage()               {}
func (*Subnet) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{72} }

func (m *Subnet) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Subnet) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Subnet) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Subnet) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Subnet) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Subnet) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Subnet) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Subnet) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Subnet) GetSubnetIpPrefix() *SubnetType {
	if m != nil {
		return m.SubnetIpPrefix
	}
	return nil
}

type Tag struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	TagTypeName string         `protobuf:"bytes,9,opt,name=tag_type_name,json=tagTypeName,proto3" json:"tag_type_name,omitempty"`
	TagId       string         `protobuf:"bytes,10,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
	TagValue    string         `protobuf:"bytes,11,opt,name=tag_value,json=tagValue,proto3" json:"tag_value,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{73} }

func (m *Tag) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Tag) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Tag) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Tag) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Tag) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Tag) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Tag) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Tag) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Tag) GetTagTypeName() string {
	if m != nil {
		return m.TagTypeName
	}
	return ""
}

func (m *Tag) GetTagId() string {
	if m != nil {
		return m.TagId
	}
	return ""
}

func (m *Tag) GetTagValue() string {
	if m != nil {
		return m.TagValue
	}
	return ""
}

type TagType struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	TagTypeId   string         `protobuf:"bytes,9,opt,name=tag_type_id,json=tagTypeId,proto3" json:"tag_type_id,omitempty"`
}

func (m *TagType) Reset()                    { *m = TagType{} }
func (m *TagType) String() string            { return proto.CompactTextString(m) }
func (*TagType) ProtoMessage()               {}
func (*TagType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{74} }

func (m *TagType) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *TagType) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *TagType) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *TagType) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *TagType) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *TagType) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *TagType) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *TagType) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *TagType) GetTagTypeId() string {
	if m != nil {
		return m.TagTypeId
	}
	return ""
}

type User struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	Password    string         `protobuf:"bytes,9,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{75} }

func (m *User) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *User) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *User) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *User) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *User) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *User) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *User) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *User) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *User) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type VirtualDNSRecord struct {
	Uuid                  string                `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid            string                `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType            string                `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                []string              `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms               *IdPermsType          `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName           string                `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations           *KeyValuePairs        `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                *PermType2            `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	Virtual_DNSRecordData *VirtualDnsRecordType `protobuf:"bytes,9,opt,name=virtual_DNS_record_data,json=virtualDNSRecordData" json:"virtual_DNS_record_data,omitempty"`
}

func (m *VirtualDNSRecord) Reset()                    { *m = VirtualDNSRecord{} }
func (m *VirtualDNSRecord) String() string            { return proto.CompactTextString(m) }
func (*VirtualDNSRecord) ProtoMessage()               {}
func (*VirtualDNSRecord) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{76} }

func (m *VirtualDNSRecord) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VirtualDNSRecord) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *VirtualDNSRecord) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *VirtualDNSRecord) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *VirtualDNSRecord) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *VirtualDNSRecord) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *VirtualDNSRecord) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *VirtualDNSRecord) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *VirtualDNSRecord) GetVirtual_DNSRecordData() *VirtualDnsRecordType {
	if m != nil {
		return m.Virtual_DNSRecordData
	}
	return nil
}

type VirtualDNS struct {
	Uuid            string          `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid      string          `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType      string          `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName          []string        `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms         *IdPermsType    `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName     string          `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations     *KeyValuePairs  `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2          *PermType2      `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	Virtual_DNSData *VirtualDnsType `protobuf:"bytes,9,opt,name=virtual_DNS_data,json=virtualDNSData" json:"virtual_DNS_data,omitempty"`
}

func (m *VirtualDNS) Reset()                    { *m = VirtualDNS{} }
func (m *VirtualDNS) String() string            { return proto.CompactTextString(m) }
func (*VirtualDNS) ProtoMessage()               {}
func (*VirtualDNS) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{77} }

func (m *VirtualDNS) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VirtualDNS) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *VirtualDNS) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *VirtualDNS) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *VirtualDNS) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *VirtualDNS) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *VirtualDNS) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *VirtualDNS) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *VirtualDNS) GetVirtual_DNSData() *VirtualDnsType {
	if m != nil {
		return m.Virtual_DNSData
	}
	return nil
}

type VirtualIP struct {
	Uuid                string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid          string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType          string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName              []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms             *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName         string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations         *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2              *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	VirtualIpProperties *VirtualIpType `protobuf:"bytes,9,opt,name=virtual_ip_properties,json=virtualIpProperties" json:"virtual_ip_properties,omitempty"`
}

func (m *VirtualIP) Reset()                    { *m = VirtualIP{} }
func (m *VirtualIP) String() string            { return proto.CompactTextString(m) }
func (*VirtualIP) ProtoMessage()               {}
func (*VirtualIP) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{78} }

func (m *VirtualIP) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VirtualIP) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *VirtualIP) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *VirtualIP) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *VirtualIP) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *VirtualIP) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *VirtualIP) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *VirtualIP) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *VirtualIP) GetVirtualIpProperties() *VirtualIpType {
	if m != nil {
		return m.VirtualIpProperties
	}
	return nil
}

type VirtualMachineInterface struct {
	Uuid                                       string                                 `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                                 string                                 `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                                 string                                 `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                                     []string                               `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                                    *IdPermsType                           `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                                string                                 `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                                *KeyValuePairs                         `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                                     *PermType2                             `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	EcmpHashingIncludeFields                   *EcmpHashingIncludeFields              `protobuf:"bytes,9,opt,name=ecmp_hashing_include_fields,json=ecmpHashingIncludeFields" json:"ecmp_hashing_include_fields,omitempty"`
	VirtualMachineInterfaceHostRoutes          *RouteTableType                        `protobuf:"bytes,10,opt,name=virtual_machine_interface_host_routes,json=virtualMachineInterfaceHostRoutes" json:"virtual_machine_interface_host_routes,omitempty"`
	VirtualMachineInterfaceMacAddresses        *MacAddressesType                      `protobuf:"bytes,11,opt,name=virtual_machine_interface_mac_addresses,json=virtualMachineInterfaceMacAddresses" json:"virtual_machine_interface_mac_addresses,omitempty"`
	VirtualMachineInterfaceDhcpOptionList      *DhcpOptionsListType                   `protobuf:"bytes,12,opt,name=virtual_machine_interface_dhcp_option_list,json=virtualMachineInterfaceDhcpOptionList" json:"virtual_machine_interface_dhcp_option_list,omitempty"`
	VirtualMachineInterfaceBindings            *KeyValuePairs                         `protobuf:"bytes,13,opt,name=virtual_machine_interface_bindings,json=virtualMachineInterfaceBindings" json:"virtual_machine_interface_bindings,omitempty"`
	VirtualMachineInterfaceDisablePolicy       bool                                   `protobuf:"varint,14,opt,name=virtual_machine_interface_disable_policy,json=virtualMachineInterfaceDisablePolicy,proto3" json:"virtual_machine_interface_disable_policy,omitempty"`
	VirtualMachineInterfaceAllowedAddressPairs *AllowedAddressPairs                   `protobuf:"bytes,15,opt,name=virtual_machine_interface_allowed_address_pairs,json=virtualMachineInterfaceAllowedAddressPairs" json:"virtual_machine_interface_allowed_address_pairs,omitempty"`
	VirtualMachineInterfaceFatFlowProtocols    *FatFlowProtocols                      `protobuf:"bytes,16,opt,name=virtual_machine_interface_fat_flow_protocols,json=virtualMachineInterfaceFatFlowProtocols" json:"virtual_machine_interface_fat_flow_protocols,omitempty"`
	VlanTagBasedBridgeDomain                   bool                                   `protobuf:"varint,17,opt,name=vlan_tag_based_bridge_domain,json=vlanTagBasedBridgeDomain,proto3" json:"vlan_tag_based_bridge_domain,omitempty"`
	VirtualMachineInterfaceDeviceOwner         string                                 `protobuf:"bytes,18,opt,name=virtual_machine_interface_device_owner,json=virtualMachineInterfaceDeviceOwner,proto3" json:"virtual_machine_interface_device_owner,omitempty"`
	VrfAssignTable                             *VrfAssignTableType                    `protobuf:"bytes,19,opt,name=vrf_assign_table,json=vrfAssignTable" json:"vrf_assign_table,omitempty"`
	PortSecurityEnabled                        bool                                   `protobuf:"varint,20,opt,name=port_security_enabled,json=portSecurityEnabled,proto3" json:"port_security_enabled,omitempty"`
	VirtualMachineInterfaceProperties          *VirtualMachineInterfacePropertiesType `protobuf:"bytes,21,opt,name=virtual_machine_interface_properties,json=virtualMachineInterfaceProperties" json:"virtual_machine_interface_properties,omitempty"`
}

func (m *VirtualMachineInterface) Reset()                    { *m = VirtualMachineInterface{} }
func (m *VirtualMachineInterface) String() string            { return proto.CompactTextString(m) }
func (*VirtualMachineInterface) ProtoMessage()               {}
func (*VirtualMachineInterface) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{79} }

func (m *VirtualMachineInterface) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VirtualMachineInterface) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *VirtualMachineInterface) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *VirtualMachineInterface) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *VirtualMachineInterface) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *VirtualMachineInterface) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *VirtualMachineInterface) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *VirtualMachineInterface) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *VirtualMachineInterface) GetEcmpHashingIncludeFields() *EcmpHashingIncludeFields {
	if m != nil {
		return m.EcmpHashingIncludeFields
	}
	return nil
}

func (m *VirtualMachineInterface) GetVirtualMachineInterfaceHostRoutes() *RouteTableType {
	if m != nil {
		return m.VirtualMachineInterfaceHostRoutes
	}
	return nil
}

func (m *VirtualMachineInterface) GetVirtualMachineInterfaceMacAddresses() *MacAddressesType {
	if m != nil {
		return m.VirtualMachineInterfaceMacAddresses
	}
	return nil
}

func (m *VirtualMachineInterface) GetVirtualMachineInterfaceDhcpOptionList() *DhcpOptionsListType {
	if m != nil {
		return m.VirtualMachineInterfaceDhcpOptionList
	}
	return nil
}

func (m *VirtualMachineInterface) GetVirtualMachineInterfaceBindings() *KeyValuePairs {
	if m != nil {
		return m.VirtualMachineInterfaceBindings
	}
	return nil
}

func (m *VirtualMachineInterface) GetVirtualMachineInterfaceDisablePolicy() bool {
	if m != nil {
		return m.VirtualMachineInterfaceDisablePolicy
	}
	return false
}

func (m *VirtualMachineInterface) GetVirtualMachineInterfaceAllowedAddressPairs() *AllowedAddressPairs {
	if m != nil {
		return m.VirtualMachineInterfaceAllowedAddressPairs
	}
	return nil
}

func (m *VirtualMachineInterface) GetVirtualMachineInterfaceFatFlowProtocols() *FatFlowProtocols {
	if m != nil {
		return m.VirtualMachineInterfaceFatFlowProtocols
	}
	return nil
}

func (m *VirtualMachineInterface) GetVlanTagBasedBridgeDomain() bool {
	if m != nil {
		return m.VlanTagBasedBridgeDomain
	}
	return false
}

func (m *VirtualMachineInterface) GetVirtualMachineInterfaceDeviceOwner() string {
	if m != nil {
		return m.VirtualMachineInterfaceDeviceOwner
	}
	return ""
}

func (m *VirtualMachineInterface) GetVrfAssignTable() *VrfAssignTableType {
	if m != nil {
		return m.VrfAssignTable
	}
	return nil
}

func (m *VirtualMachineInterface) GetPortSecurityEnabled() bool {
	if m != nil {
		return m.PortSecurityEnabled
	}
	return false
}

func (m *VirtualMachineInterface) GetVirtualMachineInterfaceProperties() *VirtualMachineInterfacePropertiesType {
	if m != nil {
		return m.VirtualMachineInterfaceProperties
	}
	return nil
}

type VirtualMachine struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *VirtualMachine) Reset()                    { *m = VirtualMachine{} }
func (m *VirtualMachine) String() string            { return proto.CompactTextString(m) }
func (*VirtualMachine) ProtoMessage()               {}
func (*VirtualMachine) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{80} }

func (m *VirtualMachine) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VirtualMachine) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *VirtualMachine) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *VirtualMachine) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *VirtualMachine) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *VirtualMachine) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *VirtualMachine) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *VirtualMachine) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type VirtualNetwork struct {
	Uuid                            string                    `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                      string                    `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                      string                    `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                          []string                  `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                         *IdPermsType              `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                     string                    `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                     *KeyValuePairs            `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                          *PermType2                `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	VirtualNetworkProperties        *VirtualNetworkType       `protobuf:"bytes,9,opt,name=virtual_network_properties,json=virtualNetworkProperties" json:"virtual_network_properties,omitempty"`
	EcmpHashingIncludeFields        *EcmpHashingIncludeFields `protobuf:"bytes,10,opt,name=ecmp_hashing_include_fields,json=ecmpHashingIncludeFields" json:"ecmp_hashing_include_fields,omitempty"`
	VirtualNetworkNetworkId         int64                     `protobuf:"varint,11,opt,name=virtual_network_network_id,json=virtualNetworkNetworkId,proto3" json:"virtual_network_network_id,omitempty"`
	AddressAllocationMode           string                    `protobuf:"bytes,12,opt,name=address_allocation_mode,json=addressAllocationMode,proto3" json:"address_allocation_mode,omitempty"`
	PbbEvpnEnable                   bool                      `protobuf:"varint,13,opt,name=pbb_evpn_enable,json=pbbEvpnEnable,proto3" json:"pbb_evpn_enable,omitempty"`
	RouterExternal                  bool                      `protobuf:"varint,14,opt,name=router_external,json=routerExternal,proto3" json:"router_external,omitempty"`
	ImportRouteTargetList           *RouteTargetList          `protobuf:"bytes,15,opt,name=import_route_target_list,json=importRouteTargetList" json:"import_route_target_list,omitempty"`
	MacAgingTime                    int64                     `protobuf:"varint,16,opt,name=mac_aging_time,json=macAgingTime,proto3" json:"mac_aging_time,omitempty"`
	ProviderProperties              *ProviderDetails          `protobuf:"bytes,17,opt,name=provider_properties,json=providerProperties" json:"provider_properties,omitempty"`
	RouteTargetList                 *RouteTargetList          `protobuf:"bytes,18,opt,name=route_target_list,json=routeTargetList" json:"route_target_list,omitempty"`
	MacLearningEnabled              bool                      `protobuf:"varint,19,opt,name=mac_learning_enabled,json=macLearningEnabled,proto3" json:"mac_learning_enabled,omitempty"`
	ExportRouteTargetList           *RouteTargetList          `protobuf:"bytes,20,opt,name=export_route_target_list,json=exportRouteTargetList" json:"export_route_target_list,omitempty"`
	FloodUnknownUnicast             bool                      `protobuf:"varint,21,opt,name=flood_unknown_unicast,json=floodUnknownUnicast,proto3" json:"flood_unknown_unicast,omitempty"`
	PbbEtreeEnable                  bool                      `protobuf:"varint,22,opt,name=pbb_etree_enable,json=pbbEtreeEnable,proto3" json:"pbb_etree_enable,omitempty"`
	Layer2ControlWord               bool                      `protobuf:"varint,23,opt,name=layer2_control_word,json=layer2ControlWord,proto3" json:"layer2_control_word,omitempty"`
	ExternalIpam                    bool                      `protobuf:"varint,24,opt,name=external_ipam,json=externalIpam,proto3" json:"external_ipam,omitempty"`
	PortSecurityEnabled             bool                      `protobuf:"varint,25,opt,name=port_security_enabled,json=portSecurityEnabled,proto3" json:"port_security_enabled,omitempty"`
	MacMoveControl                  *MACMoveLimitControlType  `protobuf:"bytes,26,opt,name=mac_move_control,json=macMoveControl" json:"mac_move_control,omitempty"`
	MultiPolicyServiceChainsEnabled bool                      `protobuf:"varint,27,opt,name=multi_policy_service_chains_enabled,json=multiPolicyServiceChainsEnabled,proto3" json:"multi_policy_service_chains_enabled,omitempty"`
	MacLimitControl                 *MACLimitControlType      `protobuf:"bytes,28,opt,name=mac_limit_control,json=macLimitControl" json:"mac_limit_control,omitempty"`
	IsShared                        bool                      `protobuf:"varint,29,opt,name=is_shared,json=isShared,proto3" json:"is_shared,omitempty"`
}

func (m *VirtualNetwork) Reset()                    { *m = VirtualNetwork{} }
func (m *VirtualNetwork) String() string            { return proto.CompactTextString(m) }
func (*VirtualNetwork) ProtoMessage()               {}
func (*VirtualNetwork) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{81} }

func (m *VirtualNetwork) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VirtualNetwork) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *VirtualNetwork) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *VirtualNetwork) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *VirtualNetwork) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *VirtualNetwork) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *VirtualNetwork) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *VirtualNetwork) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *VirtualNetwork) GetVirtualNetworkProperties() *VirtualNetworkType {
	if m != nil {
		return m.VirtualNetworkProperties
	}
	return nil
}

func (m *VirtualNetwork) GetEcmpHashingIncludeFields() *EcmpHashingIncludeFields {
	if m != nil {
		return m.EcmpHashingIncludeFields
	}
	return nil
}

func (m *VirtualNetwork) GetVirtualNetworkNetworkId() int64 {
	if m != nil {
		return m.VirtualNetworkNetworkId
	}
	return 0
}

func (m *VirtualNetwork) GetAddressAllocationMode() string {
	if m != nil {
		return m.AddressAllocationMode
	}
	return ""
}

func (m *VirtualNetwork) GetPbbEvpnEnable() bool {
	if m != nil {
		return m.PbbEvpnEnable
	}
	return false
}

func (m *VirtualNetwork) GetRouterExternal() bool {
	if m != nil {
		return m.RouterExternal
	}
	return false
}

func (m *VirtualNetwork) GetImportRouteTargetList() *RouteTargetList {
	if m != nil {
		return m.ImportRouteTargetList
	}
	return nil
}

func (m *VirtualNetwork) GetMacAgingTime() int64 {
	if m != nil {
		return m.MacAgingTime
	}
	return 0
}

func (m *VirtualNetwork) GetProviderProperties() *ProviderDetails {
	if m != nil {
		return m.ProviderProperties
	}
	return nil
}

func (m *VirtualNetwork) GetRouteTargetList() *RouteTargetList {
	if m != nil {
		return m.RouteTargetList
	}
	return nil
}

func (m *VirtualNetwork) GetMacLearningEnabled() bool {
	if m != nil {
		return m.MacLearningEnabled
	}
	return false
}

func (m *VirtualNetwork) GetExportRouteTargetList() *RouteTargetList {
	if m != nil {
		return m.ExportRouteTargetList
	}
	return nil
}

func (m *VirtualNetwork) GetFloodUnknownUnicast() bool {
	if m != nil {
		return m.FloodUnknownUnicast
	}
	return false
}

func (m *VirtualNetwork) GetPbbEtreeEnable() bool {
	if m != nil {
		return m.PbbEtreeEnable
	}
	return false
}

func (m *VirtualNetwork) GetLayer2ControlWord() bool {
	if m != nil {
		return m.Layer2ControlWord
	}
	return false
}

func (m *VirtualNetwork) GetExternalIpam() bool {
	if m != nil {
		return m.ExternalIpam
	}
	return false
}

func (m *VirtualNetwork) GetPortSecurityEnabled() bool {
	if m != nil {
		return m.PortSecurityEnabled
	}
	return false
}

func (m *VirtualNetwork) GetMacMoveControl() *MACMoveLimitControlType {
	if m != nil {
		return m.MacMoveControl
	}
	return nil
}

func (m *VirtualNetwork) GetMultiPolicyServiceChainsEnabled() bool {
	if m != nil {
		return m.MultiPolicyServiceChainsEnabled
	}
	return false
}

func (m *VirtualNetwork) GetMacLimitControl() *MACLimitControlType {
	if m != nil {
		return m.MacLimitControl
	}
	return nil
}

func (m *VirtualNetwork) GetIsShared() bool {
	if m != nil {
		return m.IsShared
	}
	return false
}

type VirtualRouter struct {
	Uuid                     string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid               string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType               string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                   []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                  *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName              string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations              *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                   *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	VirtualRouterDpdkEnabled bool           `protobuf:"varint,9,opt,name=virtual_router_dpdk_enabled,json=virtualRouterDpdkEnabled,proto3" json:"virtual_router_dpdk_enabled,omitempty"`
	VirtualRouterType        string         `protobuf:"bytes,10,opt,name=virtual_router_type,json=virtualRouterType,proto3" json:"virtual_router_type,omitempty"`
	VirtualRouterIpAddress   string         `protobuf:"bytes,11,opt,name=virtual_router_ip_address,json=virtualRouterIpAddress,proto3" json:"virtual_router_ip_address,omitempty"`
}

func (m *VirtualRouter) Reset()                    { *m = VirtualRouter{} }
func (m *VirtualRouter) String() string            { return proto.CompactTextString(m) }
func (*VirtualRouter) ProtoMessage()               {}
func (*VirtualRouter) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{82} }

func (m *VirtualRouter) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VirtualRouter) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *VirtualRouter) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *VirtualRouter) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *VirtualRouter) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *VirtualRouter) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *VirtualRouter) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *VirtualRouter) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *VirtualRouter) GetVirtualRouterDpdkEnabled() bool {
	if m != nil {
		return m.VirtualRouterDpdkEnabled
	}
	return false
}

func (m *VirtualRouter) GetVirtualRouterType() string {
	if m != nil {
		return m.VirtualRouterType
	}
	return ""
}

func (m *VirtualRouter) GetVirtualRouterIpAddress() string {
	if m != nil {
		return m.VirtualRouterIpAddress
	}
	return ""
}

type AppformixNodeRole struct {
	ProvisioningLog           string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress      int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime     string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState         string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                      string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *AppformixNodeRole) Reset()                    { *m = AppformixNodeRole{} }
func (m *AppformixNodeRole) String() string            { return proto.CompactTextString(m) }
func (*AppformixNodeRole) ProtoMessage()               {}
func (*AppformixNodeRole) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{83} }

func (m *AppformixNodeRole) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *AppformixNodeRole) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *AppformixNodeRole) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *AppformixNodeRole) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *AppformixNodeRole) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *AppformixNodeRole) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *AppformixNodeRole) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *AppformixNodeRole) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *AppformixNodeRole) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *AppformixNodeRole) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *AppformixNodeRole) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *AppformixNodeRole) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *AppformixNodeRole) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type BaremetalNode struct {
	Uuid          string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid    string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType    string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName        []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms       *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName   string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations   *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2        *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	Name          string         `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
	IpmiAddress   string         `protobuf:"bytes,10,opt,name=ipmi_address,json=ipmiAddress,proto3" json:"ipmi_address,omitempty"`
	IpmiUsername  string         `protobuf:"bytes,11,opt,name=ipmi_username,json=ipmiUsername,proto3" json:"ipmi_username,omitempty"`
	IpmiPassword  string         `protobuf:"bytes,12,opt,name=ipmi_password,json=ipmiPassword,proto3" json:"ipmi_password,omitempty"`
	CpuCount      int64          `protobuf:"varint,13,opt,name=cpu_count,json=cpuCount,proto3" json:"cpu_count,omitempty"`
	CpuArch       string         `protobuf:"bytes,14,opt,name=cpu_arch,json=cpuArch,proto3" json:"cpu_arch,omitempty"`
	DiskGb        int64          `protobuf:"varint,15,opt,name=disk_gb,json=diskGb,proto3" json:"disk_gb,omitempty"`
	MemoryMb      int64          `protobuf:"varint,16,opt,name=memory_mb,json=memoryMb,proto3" json:"memory_mb,omitempty"`
	DeployKernel  string         `protobuf:"bytes,17,opt,name=deploy_kernel,json=deployKernel,proto3" json:"deploy_kernel,omitempty"`
	DeployRamdisk string         `protobuf:"bytes,18,opt,name=deploy_ramdisk,json=deployRamdisk,proto3" json:"deploy_ramdisk,omitempty"`
}

func (m *BaremetalNode) Reset()                    { *m = BaremetalNode{} }
func (m *BaremetalNode) String() string            { return proto.CompactTextString(m) }
func (*BaremetalNode) ProtoMessage()               {}
func (*BaremetalNode) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{84} }

func (m *BaremetalNode) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *BaremetalNode) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *BaremetalNode) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *BaremetalNode) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *BaremetalNode) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *BaremetalNode) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *BaremetalNode) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *BaremetalNode) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *BaremetalNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BaremetalNode) GetIpmiAddress() string {
	if m != nil {
		return m.IpmiAddress
	}
	return ""
}

func (m *BaremetalNode) GetIpmiUsername() string {
	if m != nil {
		return m.IpmiUsername
	}
	return ""
}

func (m *BaremetalNode) GetIpmiPassword() string {
	if m != nil {
		return m.IpmiPassword
	}
	return ""
}

func (m *BaremetalNode) GetCpuCount() int64 {
	if m != nil {
		return m.CpuCount
	}
	return 0
}

func (m *BaremetalNode) GetCpuArch() string {
	if m != nil {
		return m.CpuArch
	}
	return ""
}

func (m *BaremetalNode) GetDiskGb() int64 {
	if m != nil {
		return m.DiskGb
	}
	return 0
}

func (m *BaremetalNode) GetMemoryMb() int64 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}

func (m *BaremetalNode) GetDeployKernel() string {
	if m != nil {
		return m.DeployKernel
	}
	return ""
}

func (m *BaremetalNode) GetDeployRamdisk() string {
	if m != nil {
		return m.DeployRamdisk
	}
	return ""
}

type BaremetalPort struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	MacAddress  string         `protobuf:"bytes,9,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	Node        string         `protobuf:"bytes,10,opt,name=node,proto3" json:"node,omitempty"`
	SwitchId    string         `protobuf:"bytes,11,opt,name=switch_id,json=switchId,proto3" json:"switch_id,omitempty"`
	PortId      string         `protobuf:"bytes,12,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	SwitchInfo  string         `protobuf:"bytes,13,opt,name=switch_info,json=switchInfo,proto3" json:"switch_info,omitempty"`
	PxeEnabled  bool           `protobuf:"varint,14,opt,name=pxe_enabled,json=pxeEnabled,proto3" json:"pxe_enabled,omitempty"`
}

func (m *BaremetalPort) Reset()                    { *m = BaremetalPort{} }
func (m *BaremetalPort) String() string            { return proto.CompactTextString(m) }
func (*BaremetalPort) ProtoMessage()               {}
func (*BaremetalPort) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{85} }

func (m *BaremetalPort) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *BaremetalPort) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *BaremetalPort) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *BaremetalPort) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *BaremetalPort) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *BaremetalPort) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *BaremetalPort) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *BaremetalPort) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *BaremetalPort) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *BaremetalPort) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *BaremetalPort) GetSwitchId() string {
	if m != nil {
		return m.SwitchId
	}
	return ""
}

func (m *BaremetalPort) GetPortId() string {
	if m != nil {
		return m.PortId
	}
	return ""
}

func (m *BaremetalPort) GetSwitchInfo() string {
	if m != nil {
		return m.SwitchInfo
	}
	return ""
}

func (m *BaremetalPort) GetPxeEnabled() bool {
	if m != nil {
		return m.PxeEnabled
	}
	return false
}

type ContrailAnalyticsDatabaseNodeRole struct {
	ProvisioningLog           string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress      int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime     string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState         string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                      string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *ContrailAnalyticsDatabaseNodeRole) Reset()         { *m = ContrailAnalyticsDatabaseNodeRole{} }
func (m *ContrailAnalyticsDatabaseNodeRole) String() string { return proto.CompactTextString(m) }
func (*ContrailAnalyticsDatabaseNodeRole) ProtoMessage()    {}
func (*ContrailAnalyticsDatabaseNodeRole) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{86}
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ContrailAnalyticsDatabaseNodeRole) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type ContrailAnalyticsNode struct {
	ProvisioningLog           string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress      int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime     string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState         string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                      string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *ContrailAnalyticsNode) Reset()                    { *m = ContrailAnalyticsNode{} }
func (m *ContrailAnalyticsNode) String() string            { return proto.CompactTextString(m) }
func (*ContrailAnalyticsNode) ProtoMessage()               {}
func (*ContrailAnalyticsNode) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{87} }

func (m *ContrailAnalyticsNode) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *ContrailAnalyticsNode) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *ContrailAnalyticsNode) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *ContrailAnalyticsNode) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *ContrailAnalyticsNode) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *ContrailAnalyticsNode) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ContrailAnalyticsNode) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ContrailAnalyticsNode) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ContrailAnalyticsNode) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ContrailAnalyticsNode) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ContrailAnalyticsNode) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ContrailAnalyticsNode) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ContrailAnalyticsNode) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type ContrailCluster struct {
	Uuid                               string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                         string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                         string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                             []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                            *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                        string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                        *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                             *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ConfigAuditTtl                     string         `protobuf:"bytes,9,opt,name=config_audit_ttl,json=configAuditTtl,proto3" json:"config_audit_ttl,omitempty"`
	ContrailWebui                      string         `protobuf:"bytes,10,opt,name=contrail_webui,json=contrailWebui,proto3" json:"contrail_webui,omitempty"`
	DataTtl                            string         `protobuf:"bytes,11,opt,name=data_ttl,json=dataTtl,proto3" json:"data_ttl,omitempty"`
	DefaultGateway                     string         `protobuf:"bytes,12,opt,name=default_gateway,json=defaultGateway,proto3" json:"default_gateway,omitempty"`
	DefaultVrouterBondInterface        string         `protobuf:"bytes,13,opt,name=default_vrouter_bond_interface,json=defaultVrouterBondInterface,proto3" json:"default_vrouter_bond_interface,omitempty"`
	DefaultVrouterBondInterfaceMembers string         `protobuf:"bytes,14,opt,name=default_vrouter_bond_interface_members,json=defaultVrouterBondInterfaceMembers,proto3" json:"default_vrouter_bond_interface_members,omitempty"`
	FlowTtl                            string         `protobuf:"bytes,15,opt,name=flow_ttl,json=flowTtl,proto3" json:"flow_ttl,omitempty"`
	StatisticsTtl                      string         `protobuf:"bytes,16,opt,name=statistics_ttl,json=statisticsTtl,proto3" json:"statistics_ttl,omitempty"`
}

func (m *ContrailCluster) Reset()                    { *m = ContrailCluster{} }
func (m *ContrailCluster) String() string            { return proto.CompactTextString(m) }
func (*ContrailCluster) ProtoMessage()               {}
func (*ContrailCluster) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{88} }

func (m *ContrailCluster) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ContrailCluster) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ContrailCluster) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ContrailCluster) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ContrailCluster) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ContrailCluster) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ContrailCluster) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ContrailCluster) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ContrailCluster) GetConfigAuditTtl() string {
	if m != nil {
		return m.ConfigAuditTtl
	}
	return ""
}

func (m *ContrailCluster) GetContrailWebui() string {
	if m != nil {
		return m.ContrailWebui
	}
	return ""
}

func (m *ContrailCluster) GetDataTtl() string {
	if m != nil {
		return m.DataTtl
	}
	return ""
}

func (m *ContrailCluster) GetDefaultGateway() string {
	if m != nil {
		return m.DefaultGateway
	}
	return ""
}

func (m *ContrailCluster) GetDefaultVrouterBondInterface() string {
	if m != nil {
		return m.DefaultVrouterBondInterface
	}
	return ""
}

func (m *ContrailCluster) GetDefaultVrouterBondInterfaceMembers() string {
	if m != nil {
		return m.DefaultVrouterBondInterfaceMembers
	}
	return ""
}

func (m *ContrailCluster) GetFlowTtl() string {
	if m != nil {
		return m.FlowTtl
	}
	return ""
}

func (m *ContrailCluster) GetStatisticsTtl() string {
	if m != nil {
		return m.StatisticsTtl
	}
	return ""
}

type ContrailControllerNodeRole struct {
	ProvisioningLog           string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress      int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime     string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState         string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                      string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *ContrailControllerNodeRole) Reset()         { *m = ContrailControllerNodeRole{} }
func (m *ContrailControllerNodeRole) String() string { return proto.CompactTextString(m) }
func (*ContrailControllerNodeRole) ProtoMessage()    {}
func (*ContrailControllerNodeRole) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{89}
}

func (m *ContrailControllerNodeRole) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *ContrailControllerNodeRole) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *ContrailControllerNodeRole) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *ContrailControllerNodeRole) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *ContrailControllerNodeRole) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *ContrailControllerNodeRole) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ContrailControllerNodeRole) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ContrailControllerNodeRole) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ContrailControllerNodeRole) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ContrailControllerNodeRole) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ContrailControllerNodeRole) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ContrailControllerNodeRole) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ContrailControllerNodeRole) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type ControllerNodeRole struct {
	ProvisioningLog                       string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress                  int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage             string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime                 string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState                     string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                                  string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                            string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                            string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                                []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                               *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                           string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                           *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                                *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
	CapacityDrives                        string         `protobuf:"bytes,14,opt,name=capacity_drives,json=capacityDrives,proto3" json:"capacity_drives,omitempty"`
	InternalapiBondInterfaceMembers       string         `protobuf:"bytes,15,opt,name=internalapi_bond_interface_members,json=internalapiBondInterfaceMembers,proto3" json:"internalapi_bond_interface_members,omitempty"`
	PerformanceDrives                     string         `protobuf:"bytes,16,opt,name=performance_drives,json=performanceDrives,proto3" json:"performance_drives,omitempty"`
	StorageManagementBondInterfaceMembers string         `protobuf:"bytes,17,opt,name=storage_management_bond_interface_members,json=storageManagementBondInterfaceMembers,proto3" json:"storage_management_bond_interface_members,omitempty"`
}

func (m *ControllerNodeRole) Reset()                    { *m = ControllerNodeRole{} }
func (m *ControllerNodeRole) String() string            { return proto.CompactTextString(m) }
func (*ControllerNodeRole) ProtoMessage()               {}
func (*ControllerNodeRole) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{90} }

func (m *ControllerNodeRole) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *ControllerNodeRole) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *ControllerNodeRole) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *ControllerNodeRole) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *ControllerNodeRole) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *ControllerNodeRole) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ControllerNodeRole) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *ControllerNodeRole) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *ControllerNodeRole) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *ControllerNodeRole) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *ControllerNodeRole) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ControllerNodeRole) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ControllerNodeRole) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *ControllerNodeRole) GetCapacityDrives() string {
	if m != nil {
		return m.CapacityDrives
	}
	return ""
}

func (m *ControllerNodeRole) GetInternalapiBondInterfaceMembers() string {
	if m != nil {
		return m.InternalapiBondInterfaceMembers
	}
	return ""
}

func (m *ControllerNodeRole) GetPerformanceDrives() string {
	if m != nil {
		return m.PerformanceDrives
	}
	return ""
}

func (m *ControllerNodeRole) GetStorageManagementBondInterfaceMembers() string {
	if m != nil {
		return m.StorageManagementBondInterfaceMembers
	}
	return ""
}

type Dashboard struct {
	Uuid            string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid      string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType      string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName          []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms         *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName     string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations     *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2          *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ContainerConfig string         `protobuf:"bytes,9,opt,name=container_config,json=containerConfig,proto3" json:"container_config,omitempty"`
}

func (m *Dashboard) Reset()                    { *m = Dashboard{} }
func (m *Dashboard) String() string            { return proto.CompactTextString(m) }
func (*Dashboard) ProtoMessage()               {}
func (*Dashboard) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{91} }

func (m *Dashboard) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Dashboard) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Dashboard) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Dashboard) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Dashboard) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Dashboard) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Dashboard) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Dashboard) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Dashboard) GetContainerConfig() string {
	if m != nil {
		return m.ContainerConfig
	}
	return ""
}

type Keypair struct {
	Uuid        string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid  string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType  string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName      []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms     *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2      *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	Name        string         `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
	PublicKey   string         `protobuf:"bytes,10,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (m *Keypair) Reset()                    { *m = Keypair{} }
func (m *Keypair) String() string            { return proto.CompactTextString(m) }
func (*Keypair) ProtoMessage()               {}
func (*Keypair) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{92} }

func (m *Keypair) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Keypair) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Keypair) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Keypair) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Keypair) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Keypair) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Keypair) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Keypair) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Keypair) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Keypair) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

type KubernetesCluster struct {
	Uuid                 string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid           string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType           string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName               []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms              *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName          string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations          *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2               *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ContrailClusterId    string         `protobuf:"bytes,9,opt,name=contrail_cluster_id,json=contrailClusterId,proto3" json:"contrail_cluster_id,omitempty"`
	KuberunetesDashboard string         `protobuf:"bytes,10,opt,name=kuberunetes_dashboard,json=kuberunetesDashboard,proto3" json:"kuberunetes_dashboard,omitempty"`
}

func (m *KubernetesCluster) Reset()                    { *m = KubernetesCluster{} }
func (m *KubernetesCluster) String() string            { return proto.CompactTextString(m) }
func (*KubernetesCluster) ProtoMessage()               {}
func (*KubernetesCluster) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{93} }

func (m *KubernetesCluster) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *KubernetesCluster) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *KubernetesCluster) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *KubernetesCluster) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *KubernetesCluster) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *KubernetesCluster) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *KubernetesCluster) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *KubernetesCluster) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *KubernetesCluster) GetContrailClusterId() string {
	if m != nil {
		return m.ContrailClusterId
	}
	return ""
}

func (m *KubernetesCluster) GetKuberunetesDashboard() string {
	if m != nil {
		return m.KuberunetesDashboard
	}
	return ""
}

type KubernetesNode struct {
	ProvisioningLog           string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress      int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime     string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState         string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                      string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
}

func (m *KubernetesNode) Reset()                    { *m = KubernetesNode{} }
func (m *KubernetesNode) String() string            { return proto.CompactTextString(m) }
func (*KubernetesNode) ProtoMessage()               {}
func (*KubernetesNode) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{94} }

func (m *KubernetesNode) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *KubernetesNode) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *KubernetesNode) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *KubernetesNode) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *KubernetesNode) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *KubernetesNode) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *KubernetesNode) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *KubernetesNode) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *KubernetesNode) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *KubernetesNode) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *KubernetesNode) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *KubernetesNode) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *KubernetesNode) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

type Location struct {
	ProvisioningLog                  string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress             int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage        string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime            string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState                string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                             string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                       string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                       string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                           []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                          *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                      string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                      *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                           *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
	Type                             string         `protobuf:"bytes,14,opt,name=type,proto3" json:"type,omitempty"`
	PrivateDnsServers                string         `protobuf:"bytes,15,opt,name=private_dns_servers,json=privateDnsServers,proto3" json:"private_dns_servers,omitempty"`
	PrivateNtpHosts                  string         `protobuf:"bytes,16,opt,name=private_ntp_hosts,json=privateNtpHosts,proto3" json:"private_ntp_hosts,omitempty"`
	PrivateOspdPackageUrl            string         `protobuf:"bytes,17,opt,name=private_ospd_package_url,json=privateOspdPackageUrl,proto3" json:"private_ospd_package_url,omitempty"`
	PrivateOspdUserName              string         `protobuf:"bytes,18,opt,name=private_ospd_user_name,json=privateOspdUserName,proto3" json:"private_ospd_user_name,omitempty"`
	PrivateOspdUserPassword          string         `protobuf:"bytes,19,opt,name=private_ospd_user_password,json=privateOspdUserPassword,proto3" json:"private_ospd_user_password,omitempty"`
	PrivateOspdVmDiskGb              string         `protobuf:"bytes,20,opt,name=private_ospd_vm_disk_gb,json=privateOspdVmDiskGb,proto3" json:"private_ospd_vm_disk_gb,omitempty"`
	PrivateOspdVmName                string         `protobuf:"bytes,21,opt,name=private_ospd_vm_name,json=privateOspdVmName,proto3" json:"private_ospd_vm_name,omitempty"`
	PrivateOspdVmRamMb               string         `protobuf:"bytes,22,opt,name=private_ospd_vm_ram_mb,json=privateOspdVmRamMb,proto3" json:"private_ospd_vm_ram_mb,omitempty"`
	PrivateOspdVmVcpus               string         `protobuf:"bytes,23,opt,name=private_ospd_vm_vcpus,json=privateOspdVmVcpus,proto3" json:"private_ospd_vm_vcpus,omitempty"`
	PrivateRedhatPoolId              string         `protobuf:"bytes,24,opt,name=private_redhat_pool_id,json=privateRedhatPoolId,proto3" json:"private_redhat_pool_id,omitempty"`
	PrivateRedhatSubscriptionKey     string         `protobuf:"bytes,25,opt,name=private_redhat_subscription_key,json=privateRedhatSubscriptionKey,proto3" json:"private_redhat_subscription_key,omitempty"`
	PrivateRedhatSubscriptionPasword string         `protobuf:"bytes,26,opt,name=private_redhat_subscription_pasword,json=privateRedhatSubscriptionPasword,proto3" json:"private_redhat_subscription_pasword,omitempty"`
	PrivateRedhatSubscriptionUser    string         `protobuf:"bytes,27,opt,name=private_redhat_subscription_user,json=privateRedhatSubscriptionUser,proto3" json:"private_redhat_subscription_user,omitempty"`
	GcpAccountInfo                   string         `protobuf:"bytes,28,opt,name=gcp_account_info,json=gcpAccountInfo,proto3" json:"gcp_account_info,omitempty"`
	GcpAsn                           int64          `protobuf:"varint,29,opt,name=gcp_asn,json=gcpAsn,proto3" json:"gcp_asn,omitempty"`
	GcpRegion                        string         `protobuf:"bytes,30,opt,name=gcp_region,json=gcpRegion,proto3" json:"gcp_region,omitempty"`
	GcpSubnet                        string         `protobuf:"bytes,31,opt,name=gcp_subnet,json=gcpSubnet,proto3" json:"gcp_subnet,omitempty"`
	AwsAccessKey                     string         `protobuf:"bytes,32,opt,name=aws_access_key,json=awsAccessKey,proto3" json:"aws_access_key,omitempty"`
	AwsRegion                        string         `protobuf:"bytes,33,opt,name=aws_region,json=awsRegion,proto3" json:"aws_region,omitempty"`
	AwsSecretKey                     string         `protobuf:"bytes,34,opt,name=aws_secret_key,json=awsSecretKey,proto3" json:"aws_secret_key,omitempty"`
	AwsSubnet                        string         `protobuf:"bytes,35,opt,name=aws_subnet,json=awsSubnet,proto3" json:"aws_subnet,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{95} }

func (m *Location) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *Location) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *Location) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *Location) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *Location) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *Location) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Location) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Location) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Location) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Location) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Location) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Location) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Location) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Location) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Location) GetPrivateDnsServers() string {
	if m != nil {
		return m.PrivateDnsServers
	}
	return ""
}

func (m *Location) GetPrivateNtpHosts() string {
	if m != nil {
		return m.PrivateNtpHosts
	}
	return ""
}

func (m *Location) GetPrivateOspdPackageUrl() string {
	if m != nil {
		return m.PrivateOspdPackageUrl
	}
	return ""
}

func (m *Location) GetPrivateOspdUserName() string {
	if m != nil {
		return m.PrivateOspdUserName
	}
	return ""
}

func (m *Location) GetPrivateOspdUserPassword() string {
	if m != nil {
		return m.PrivateOspdUserPassword
	}
	return ""
}

func (m *Location) GetPrivateOspdVmDiskGb() string {
	if m != nil {
		return m.PrivateOspdVmDiskGb
	}
	return ""
}

func (m *Location) GetPrivateOspdVmName() string {
	if m != nil {
		return m.PrivateOspdVmName
	}
	return ""
}

func (m *Location) GetPrivateOspdVmRamMb() string {
	if m != nil {
		return m.PrivateOspdVmRamMb
	}
	return ""
}

func (m *Location) GetPrivateOspdVmVcpus() string {
	if m != nil {
		return m.PrivateOspdVmVcpus
	}
	return ""
}

func (m *Location) GetPrivateRedhatPoolId() string {
	if m != nil {
		return m.PrivateRedhatPoolId
	}
	return ""
}

func (m *Location) GetPrivateRedhatSubscriptionKey() string {
	if m != nil {
		return m.PrivateRedhatSubscriptionKey
	}
	return ""
}

func (m *Location) GetPrivateRedhatSubscriptionPasword() string {
	if m != nil {
		return m.PrivateRedhatSubscriptionPasword
	}
	return ""
}

func (m *Location) GetPrivateRedhatSubscriptionUser() string {
	if m != nil {
		return m.PrivateRedhatSubscriptionUser
	}
	return ""
}

func (m *Location) GetGcpAccountInfo() string {
	if m != nil {
		return m.GcpAccountInfo
	}
	return ""
}

func (m *Location) GetGcpAsn() int64 {
	if m != nil {
		return m.GcpAsn
	}
	return 0
}

func (m *Location) GetGcpRegion() string {
	if m != nil {
		return m.GcpRegion
	}
	return ""
}

func (m *Location) GetGcpSubnet() string {
	if m != nil {
		return m.GcpSubnet
	}
	return ""
}

func (m *Location) GetAwsAccessKey() string {
	if m != nil {
		return m.AwsAccessKey
	}
	return ""
}

func (m *Location) GetAwsRegion() string {
	if m != nil {
		return m.AwsRegion
	}
	return ""
}

func (m *Location) GetAwsSecretKey() string {
	if m != nil {
		return m.AwsSecretKey
	}
	return ""
}

func (m *Location) GetAwsSubnet() string {
	if m != nil {
		return m.AwsSubnet
	}
	return ""
}

type Node struct {
	Uuid                           string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                     string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                     string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                         []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                        *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                    string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                    *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                         *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	Hostname                       string         `protobuf:"bytes,9,opt,name=hostname,proto3" json:"hostname,omitempty"`
	IpAddress                      string         `protobuf:"bytes,10,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	MacAddress                     string         `protobuf:"bytes,11,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	Type                           string         `protobuf:"bytes,12,opt,name=type,proto3" json:"type,omitempty"`
	Password                       string         `protobuf:"bytes,13,opt,name=password,proto3" json:"password,omitempty"`
	SshKey                         string         `protobuf:"bytes,14,opt,name=ssh_key,json=sshKey,proto3" json:"ssh_key,omitempty"`
	Username                       string         `protobuf:"bytes,15,opt,name=username,proto3" json:"username,omitempty"`
	AwsAmi                         string         `protobuf:"bytes,16,opt,name=aws_ami,json=awsAmi,proto3" json:"aws_ami,omitempty"`
	AwsInstanceType                string         `protobuf:"bytes,17,opt,name=aws_instance_type,json=awsInstanceType,proto3" json:"aws_instance_type,omitempty"`
	GcpImage                       string         `protobuf:"bytes,18,opt,name=gcp_image,json=gcpImage,proto3" json:"gcp_image,omitempty"`
	GcpMachineType                 string         `protobuf:"bytes,19,opt,name=gcp_machine_type,json=gcpMachineType,proto3" json:"gcp_machine_type,omitempty"`
	PrivateMachineProperties       string         `protobuf:"bytes,20,opt,name=private_machine_properties,json=privateMachineProperties,proto3" json:"private_machine_properties,omitempty"`
	PrivateMachineState            string         `protobuf:"bytes,21,opt,name=private_machine_state,json=privateMachineState,proto3" json:"private_machine_state,omitempty"`
	PrivatePowerManagementIp       string         `protobuf:"bytes,22,opt,name=private_power_management_ip,json=privatePowerManagementIp,proto3" json:"private_power_management_ip,omitempty"`
	PrivatePowerManagementPassword string         `protobuf:"bytes,23,opt,name=private_power_management_password,json=privatePowerManagementPassword,proto3" json:"private_power_management_password,omitempty"`
	PrivatePowerManagementUsername string         `protobuf:"bytes,24,opt,name=private_power_management_username,json=privatePowerManagementUsername,proto3" json:"private_power_management_username,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{96} }

func (m *Node) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Node) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Node) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Node) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Node) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Node) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Node) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Node) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Node) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Node) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *Node) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *Node) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Node) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Node) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func (m *Node) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Node) GetAwsAmi() string {
	if m != nil {
		return m.AwsAmi
	}
	return ""
}

func (m *Node) GetAwsInstanceType() string {
	if m != nil {
		return m.AwsInstanceType
	}
	return ""
}

func (m *Node) GetGcpImage() string {
	if m != nil {
		return m.GcpImage
	}
	return ""
}

func (m *Node) GetGcpMachineType() string {
	if m != nil {
		return m.GcpMachineType
	}
	return ""
}

func (m *Node) GetPrivateMachineProperties() string {
	if m != nil {
		return m.PrivateMachineProperties
	}
	return ""
}

func (m *Node) GetPrivateMachineState() string {
	if m != nil {
		return m.PrivateMachineState
	}
	return ""
}

func (m *Node) GetPrivatePowerManagementIp() string {
	if m != nil {
		return m.PrivatePowerManagementIp
	}
	return ""
}

func (m *Node) GetPrivatePowerManagementPassword() string {
	if m != nil {
		return m.PrivatePowerManagementPassword
	}
	return ""
}

func (m *Node) GetPrivatePowerManagementUsername() string {
	if m != nil {
		return m.PrivatePowerManagementUsername
	}
	return ""
}

type OpenstackCluster struct {
	ProvisioningLog                           string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress                      int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage                 string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime                     string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState                         string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                                      string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                                string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                                string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                                    []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                                   *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                               string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                               *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                                    *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
	AdminPassword                             string         `protobuf:"bytes,14,opt,name=admin_password,json=adminPassword,proto3" json:"admin_password,omitempty"`
	ContrailClusterId                         string         `protobuf:"bytes,15,opt,name=contrail_cluster_id,json=contrailClusterId,proto3" json:"contrail_cluster_id,omitempty"`
	DefaultCapacityDrives                     string         `protobuf:"bytes,16,opt,name=default_capacity_drives,json=defaultCapacityDrives,proto3" json:"default_capacity_drives,omitempty"`
	DefaultJournalDrives                      string         `protobuf:"bytes,17,opt,name=default_journal_drives,json=defaultJournalDrives,proto3" json:"default_journal_drives,omitempty"`
	DefaultOsdDrives                          string         `protobuf:"bytes,18,opt,name=default_osd_drives,json=defaultOsdDrives,proto3" json:"default_osd_drives,omitempty"`
	DefaultPerformanceDrives                  string         `protobuf:"bytes,19,opt,name=default_performance_drives,json=defaultPerformanceDrives,proto3" json:"default_performance_drives,omitempty"`
	DefaultStorageAccessBondInterfaceMembers  string         `protobuf:"bytes,20,opt,name=default_storage_access_bond_interface_members,json=defaultStorageAccessBondInterfaceMembers,proto3" json:"default_storage_access_bond_interface_members,omitempty"`
	DefaultStorageBackendBondInterfaceMembers string         `protobuf:"bytes,21,opt,name=default_storage_backend_bond_interface_members,json=defaultStorageBackendBondInterfaceMembers,proto3" json:"default_storage_backend_bond_interface_members,omitempty"`
	ExternalAllocationPoolEnd                 string         `protobuf:"bytes,22,opt,name=external_allocation_pool_end,json=externalAllocationPoolEnd,proto3" json:"external_allocation_pool_end,omitempty"`
	ExternalAllocationPoolStart               string         `protobuf:"bytes,23,opt,name=external_allocation_pool_start,json=externalAllocationPoolStart,proto3" json:"external_allocation_pool_start,omitempty"`
	ExternalNetCidr                           string         `protobuf:"bytes,24,opt,name=external_net_cidr,json=externalNetCidr,proto3" json:"external_net_cidr,omitempty"`
	OpenstackWebui                            string         `protobuf:"bytes,25,opt,name=openstack_webui,json=openstackWebui,proto3" json:"openstack_webui,omitempty"`
	PublicGateway                             string         `protobuf:"bytes,26,opt,name=public_gateway,json=publicGateway,proto3" json:"public_gateway,omitempty"`
	PublicIp                                  string         `protobuf:"bytes,27,opt,name=public_ip,json=publicIp,proto3" json:"public_ip,omitempty"`
}

func (m *OpenstackCluster) Reset()                    { *m = OpenstackCluster{} }
func (m *OpenstackCluster) String() string            { return proto.CompactTextString(m) }
func (*OpenstackCluster) ProtoMessage()               {}
func (*OpenstackCluster) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{97} }

func (m *OpenstackCluster) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *OpenstackCluster) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *OpenstackCluster) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *OpenstackCluster) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *OpenstackCluster) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *OpenstackCluster) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *OpenstackCluster) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *OpenstackCluster) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *OpenstackCluster) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *OpenstackCluster) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *OpenstackCluster) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *OpenstackCluster) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *OpenstackCluster) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *OpenstackCluster) GetAdminPassword() string {
	if m != nil {
		return m.AdminPassword
	}
	return ""
}

func (m *OpenstackCluster) GetContrailClusterId() string {
	if m != nil {
		return m.ContrailClusterId
	}
	return ""
}

func (m *OpenstackCluster) GetDefaultCapacityDrives() string {
	if m != nil {
		return m.DefaultCapacityDrives
	}
	return ""
}

func (m *OpenstackCluster) GetDefaultJournalDrives() string {
	if m != nil {
		return m.DefaultJournalDrives
	}
	return ""
}

func (m *OpenstackCluster) GetDefaultOsdDrives() string {
	if m != nil {
		return m.DefaultOsdDrives
	}
	return ""
}

func (m *OpenstackCluster) GetDefaultPerformanceDrives() string {
	if m != nil {
		return m.DefaultPerformanceDrives
	}
	return ""
}

func (m *OpenstackCluster) GetDefaultStorageAccessBondInterfaceMembers() string {
	if m != nil {
		return m.DefaultStorageAccessBondInterfaceMembers
	}
	return ""
}

func (m *OpenstackCluster) GetDefaultStorageBackendBondInterfaceMembers() string {
	if m != nil {
		return m.DefaultStorageBackendBondInterfaceMembers
	}
	return ""
}

func (m *OpenstackCluster) GetExternalAllocationPoolEnd() string {
	if m != nil {
		return m.ExternalAllocationPoolEnd
	}
	return ""
}

func (m *OpenstackCluster) GetExternalAllocationPoolStart() string {
	if m != nil {
		return m.ExternalAllocationPoolStart
	}
	return ""
}

func (m *OpenstackCluster) GetExternalNetCidr() string {
	if m != nil {
		return m.ExternalNetCidr
	}
	return ""
}

func (m *OpenstackCluster) GetOpenstackWebui() string {
	if m != nil {
		return m.OpenstackWebui
	}
	return ""
}

func (m *OpenstackCluster) GetPublicGateway() string {
	if m != nil {
		return m.PublicGateway
	}
	return ""
}

func (m *OpenstackCluster) GetPublicIp() string {
	if m != nil {
		return m.PublicIp
	}
	return ""
}

type OpenstackComputeNodeRole struct {
	ProvisioningLog             string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress        int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage   string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime       string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState           string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                        string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                  string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                  string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                      []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                     *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                 string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                 *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                      *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
	DefaultGateway              string         `protobuf:"bytes,14,opt,name=default_gateway,json=defaultGateway,proto3" json:"default_gateway,omitempty"`
	VrouterBondInterface        string         `protobuf:"bytes,15,opt,name=vrouter_bond_interface,json=vrouterBondInterface,proto3" json:"vrouter_bond_interface,omitempty"`
	VrouterBondInterfaceMembers string         `protobuf:"bytes,16,opt,name=vrouter_bond_interface_members,json=vrouterBondInterfaceMembers,proto3" json:"vrouter_bond_interface_members,omitempty"`
	VrouterType                 string         `protobuf:"bytes,17,opt,name=vrouter_type,json=vrouterType,proto3" json:"vrouter_type,omitempty"`
}

func (m *OpenstackComputeNodeRole) Reset()         { *m = OpenstackComputeNodeRole{} }
func (m *OpenstackComputeNodeRole) String() string { return proto.CompactTextString(m) }
func (*OpenstackComputeNodeRole) ProtoMessage()    {}
func (*OpenstackComputeNodeRole) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{98}
}

func (m *OpenstackComputeNodeRole) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *OpenstackComputeNodeRole) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *OpenstackComputeNodeRole) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *OpenstackComputeNodeRole) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *OpenstackComputeNodeRole) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *OpenstackComputeNodeRole) GetDefaultGateway() string {
	if m != nil {
		return m.DefaultGateway
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetVrouterBondInterface() string {
	if m != nil {
		return m.VrouterBondInterface
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetVrouterBondInterfaceMembers() string {
	if m != nil {
		return m.VrouterBondInterfaceMembers
	}
	return ""
}

func (m *OpenstackComputeNodeRole) GetVrouterType() string {
	if m != nil {
		return m.VrouterType
	}
	return ""
}

type OpenstackStorageNodeRole struct {
	ProvisioningLog                    string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress               int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage          string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime              string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState                  string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                               string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                         string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                         string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                             []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                            *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName                        string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations                        *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                             *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
	JournalDrives                      string         `protobuf:"bytes,14,opt,name=journal_drives,json=journalDrives,proto3" json:"journal_drives,omitempty"`
	OsdDrives                          string         `protobuf:"bytes,15,opt,name=osd_drives,json=osdDrives,proto3" json:"osd_drives,omitempty"`
	StorageAccessBondInterfaceMembers  string         `protobuf:"bytes,16,opt,name=storage_access_bond_interface_members,json=storageAccessBondInterfaceMembers,proto3" json:"storage_access_bond_interface_members,omitempty"`
	StorageBackendBondInterfaceMembers string         `protobuf:"bytes,17,opt,name=storage_backend_bond_interface_members,json=storageBackendBondInterfaceMembers,proto3" json:"storage_backend_bond_interface_members,omitempty"`
}

func (m *OpenstackStorageNodeRole) Reset()         { *m = OpenstackStorageNodeRole{} }
func (m *OpenstackStorageNodeRole) String() string { return proto.CompactTextString(m) }
func (*OpenstackStorageNodeRole) ProtoMessage()    {}
func (*OpenstackStorageNodeRole) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{99}
}

func (m *OpenstackStorageNodeRole) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *OpenstackStorageNodeRole) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *OpenstackStorageNodeRole) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *OpenstackStorageNodeRole) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *OpenstackStorageNodeRole) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *OpenstackStorageNodeRole) GetJournalDrives() string {
	if m != nil {
		return m.JournalDrives
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetOsdDrives() string {
	if m != nil {
		return m.OsdDrives
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetStorageAccessBondInterfaceMembers() string {
	if m != nil {
		return m.StorageAccessBondInterfaceMembers
	}
	return ""
}

func (m *OpenstackStorageNodeRole) GetStorageBackendBondInterfaceMembers() string {
	if m != nil {
		return m.StorageBackendBondInterfaceMembers
	}
	return ""
}

type VPNGroup struct {
	ProvisioningLog           string         `protobuf:"bytes,1,opt,name=provisioning_log,json=provisioningLog,proto3" json:"provisioning_log,omitempty"`
	ProvisioningProgress      int64          `protobuf:"varint,2,opt,name=provisioning_progress,json=provisioningProgress,proto3" json:"provisioning_progress,omitempty"`
	ProvisioningProgressStage string         `protobuf:"bytes,3,opt,name=provisioning_progress_stage,json=provisioningProgressStage,proto3" json:"provisioning_progress_stage,omitempty"`
	ProvisioningStartTime     string         `protobuf:"bytes,4,opt,name=provisioning_start_time,json=provisioningStartTime,proto3" json:"provisioning_start_time,omitempty"`
	ProvisioningState         string         `protobuf:"bytes,5,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	Uuid                      string         `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid                string         `protobuf:"bytes,7,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType                string         `protobuf:"bytes,8,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName                    []string       `protobuf:"bytes,9,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms                   *IdPermsType   `protobuf:"bytes,10,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName               string         `protobuf:"bytes,11,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations               *KeyValuePairs `protobuf:"bytes,12,opt,name=annotations" json:"annotations,omitempty"`
	Perms2                    *PermType2     `protobuf:"bytes,13,opt,name=perms2" json:"perms2,omitempty"`
	Type                      string         `protobuf:"bytes,14,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *VPNGroup) Reset()                    { *m = VPNGroup{} }
func (m *VPNGroup) String() string            { return proto.CompactTextString(m) }
func (*VPNGroup) ProtoMessage()               {}
func (*VPNGroup) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{100} }

func (m *VPNGroup) GetProvisioningLog() string {
	if m != nil {
		return m.ProvisioningLog
	}
	return ""
}

func (m *VPNGroup) GetProvisioningProgress() int64 {
	if m != nil {
		return m.ProvisioningProgress
	}
	return 0
}

func (m *VPNGroup) GetProvisioningProgressStage() string {
	if m != nil {
		return m.ProvisioningProgressStage
	}
	return ""
}

func (m *VPNGroup) GetProvisioningStartTime() string {
	if m != nil {
		return m.ProvisioningStartTime
	}
	return ""
}

func (m *VPNGroup) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *VPNGroup) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VPNGroup) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *VPNGroup) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *VPNGroup) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *VPNGroup) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *VPNGroup) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *VPNGroup) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *VPNGroup) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *VPNGroup) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type Widget struct {
	Uuid            string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	ParentUuid      string         `protobuf:"bytes,2,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentType      string         `protobuf:"bytes,3,opt,name=parent_type,json=parentType,proto3" json:"parent_type,omitempty"`
	FqName          []string       `protobuf:"bytes,4,rep,name=fq_name,json=fqName" json:"fq_name,omitempty"`
	IdPerms         *IdPermsType   `protobuf:"bytes,5,opt,name=id_perms,json=idPerms" json:"id_perms,omitempty"`
	DisplayName     string         `protobuf:"bytes,6,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Annotations     *KeyValuePairs `protobuf:"bytes,7,opt,name=annotations" json:"annotations,omitempty"`
	Perms2          *PermType2     `protobuf:"bytes,8,opt,name=perms2" json:"perms2,omitempty"`
	ContainerConfig string         `protobuf:"bytes,9,opt,name=container_config,json=containerConfig,proto3" json:"container_config,omitempty"`
	ContentConfig   string         `protobuf:"bytes,10,opt,name=content_config,json=contentConfig,proto3" json:"content_config,omitempty"`
	LayoutConfig    string         `protobuf:"bytes,11,opt,name=layout_config,json=layoutConfig,proto3" json:"layout_config,omitempty"`
}

func (m *Widget) Reset()                    { *m = Widget{} }
func (m *Widget) String() string            { return proto.CompactTextString(m) }
func (*Widget) ProtoMessage()               {}
func (*Widget) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{101} }

func (m *Widget) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Widget) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *Widget) GetParentType() string {
	if m != nil {
		return m.ParentType
	}
	return ""
}

func (m *Widget) GetFqName() []string {
	if m != nil {
		return m.FqName
	}
	return nil
}

func (m *Widget) GetIdPerms() *IdPermsType {
	if m != nil {
		return m.IdPerms
	}
	return nil
}

func (m *Widget) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Widget) GetAnnotations() *KeyValuePairs {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Widget) GetPerms2() *PermType2 {
	if m != nil {
		return m.Perms2
	}
	return nil
}

func (m *Widget) GetContainerConfig() string {
	if m != nil {
		return m.ContainerConfig
	}
	return ""
}

func (m *Widget) GetContentConfig() string {
	if m != nil {
		return m.ContentConfig
	}
	return ""
}

func (m *Widget) GetLayoutConfig() string {
	if m != nil {
		return m.LayoutConfig
	}
	return ""
}

type PermType struct {
	Owner       string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	OwnerAccess int64  `protobuf:"varint,2,opt,name=owner_access,json=ownerAccess,proto3" json:"owner_access,omitempty"`
	OtherAccess int64  `protobuf:"varint,3,opt,name=other_access,json=otherAccess,proto3" json:"other_access,omitempty"`
	Group       string `protobuf:"bytes,4,opt,name=group,proto3" json:"group,omitempty"`
	GroupAccess int64  `protobuf:"varint,5,opt,name=group_access,json=groupAccess,proto3" json:"group_access,omitempty"`
}

func (m *PermType) Reset()                    { *m = PermType{} }
func (m *PermType) String() string            { return proto.CompactTextString(m) }
func (*PermType) ProtoMessage()               {}
func (*PermType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{102} }

func (m *PermType) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *PermType) GetOwnerAccess() int64 {
	if m != nil {
		return m.OwnerAccess
	}
	return 0
}

func (m *PermType) GetOtherAccess() int64 {
	if m != nil {
		return m.OtherAccess
	}
	return 0
}

func (m *PermType) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *PermType) GetGroupAccess() int64 {
	if m != nil {
		return m.GroupAccess
	}
	return 0
}

type LoadbalancerHealthmonitorType struct {
	Delay         int64  `protobuf:"varint,1,opt,name=delay,proto3" json:"delay,omitempty"`
	ExpectedCodes string `protobuf:"bytes,2,opt,name=expected_codes,json=expectedCodes,proto3" json:"expected_codes,omitempty"`
	MaxRetries    int64  `protobuf:"varint,3,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	HttpMethod    string `protobuf:"bytes,4,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	AdminState    bool   `protobuf:"varint,5,opt,name=admin_state,json=adminState,proto3" json:"admin_state,omitempty"`
	Timeout       int64  `protobuf:"varint,6,opt,name=timeout,proto3" json:"timeout,omitempty"`
	UrlPath       string `protobuf:"bytes,7,opt,name=url_path,json=urlPath,proto3" json:"url_path,omitempty"`
	MonitorType   string `protobuf:"bytes,8,opt,name=monitor_type,json=monitorType,proto3" json:"monitor_type,omitempty"`
}

func (m *LoadbalancerHealthmonitorType) Reset()         { *m = LoadbalancerHealthmonitorType{} }
func (m *LoadbalancerHealthmonitorType) String() string { return proto.CompactTextString(m) }
func (*LoadbalancerHealthmonitorType) ProtoMessage()    {}
func (*LoadbalancerHealthmonitorType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{103}
}

func (m *LoadbalancerHealthmonitorType) GetDelay() int64 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *LoadbalancerHealthmonitorType) GetExpectedCodes() string {
	if m != nil {
		return m.ExpectedCodes
	}
	return ""
}

func (m *LoadbalancerHealthmonitorType) GetMaxRetries() int64 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

func (m *LoadbalancerHealthmonitorType) GetHttpMethod() string {
	if m != nil {
		return m.HttpMethod
	}
	return ""
}

func (m *LoadbalancerHealthmonitorType) GetAdminState() bool {
	if m != nil {
		return m.AdminState
	}
	return false
}

func (m *LoadbalancerHealthmonitorType) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *LoadbalancerHealthmonitorType) GetUrlPath() string {
	if m != nil {
		return m.UrlPath
	}
	return ""
}

func (m *LoadbalancerHealthmonitorType) GetMonitorType() string {
	if m != nil {
		return m.MonitorType
	}
	return ""
}

type SNMPCredentials struct {
	V3PrivacyProtocol        string `protobuf:"bytes,1,opt,name=v3_privacy_protocol,json=v3PrivacyProtocol,proto3" json:"v3_privacy_protocol,omitempty"`
	Retries                  int64  `protobuf:"varint,2,opt,name=retries,proto3" json:"retries,omitempty"`
	V3AuthenticationPassword string `protobuf:"bytes,3,opt,name=v3_authentication_password,json=v3AuthenticationPassword,proto3" json:"v3_authentication_password,omitempty"`
	V3EngineTime             int64  `protobuf:"varint,4,opt,name=v3_engine_time,json=v3EngineTime,proto3" json:"v3_engine_time,omitempty"`
	V3EngineId               string `protobuf:"bytes,5,opt,name=v3_engine_id,json=v3EngineId,proto3" json:"v3_engine_id,omitempty"`
	LocalPort                int64  `protobuf:"varint,6,opt,name=local_port,json=localPort,proto3" json:"local_port,omitempty"`
	V3SecurityLevel          string `protobuf:"bytes,7,opt,name=v3_security_level,json=v3SecurityLevel,proto3" json:"v3_security_level,omitempty"`
	V3Context                string `protobuf:"bytes,8,opt,name=v3_context,json=v3Context,proto3" json:"v3_context,omitempty"`
	V3SecurityName           string `protobuf:"bytes,9,opt,name=v3_security_name,json=v3SecurityName,proto3" json:"v3_security_name,omitempty"`
	V3AuthenticationProtocol string `protobuf:"bytes,10,opt,name=v3_authentication_protocol,json=v3AuthenticationProtocol,proto3" json:"v3_authentication_protocol,omitempty"`
	V2Community              string `protobuf:"bytes,11,opt,name=v2_community,json=v2Community,proto3" json:"v2_community,omitempty"`
	V3SecurityEngineId       string `protobuf:"bytes,12,opt,name=v3_security_engine_id,json=v3SecurityEngineId,proto3" json:"v3_security_engine_id,omitempty"`
	V3ContextEngineId        string `protobuf:"bytes,13,opt,name=v3_context_engine_id,json=v3ContextEngineId,proto3" json:"v3_context_engine_id,omitempty"`
	Version                  int64  `protobuf:"varint,14,opt,name=version,proto3" json:"version,omitempty"`
	Timeout                  int64  `protobuf:"varint,15,opt,name=timeout,proto3" json:"timeout,omitempty"`
	V3PrivacyPassword        string `protobuf:"bytes,16,opt,name=v3_privacy_password,json=v3PrivacyPassword,proto3" json:"v3_privacy_password,omitempty"`
	V3EngineBoots            int64  `protobuf:"varint,17,opt,name=v3_engine_boots,json=v3EngineBoots,proto3" json:"v3_engine_boots,omitempty"`
}

func (m *SNMPCredentials) Reset()                    { *m = SNMPCredentials{} }
func (m *SNMPCredentials) String() string            { return proto.CompactTextString(m) }
func (*SNMPCredentials) ProtoMessage()               {}
func (*SNMPCredentials) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{104} }

func (m *SNMPCredentials) GetV3PrivacyProtocol() string {
	if m != nil {
		return m.V3PrivacyProtocol
	}
	return ""
}

func (m *SNMPCredentials) GetRetries() int64 {
	if m != nil {
		return m.Retries
	}
	return 0
}

func (m *SNMPCredentials) GetV3AuthenticationPassword() string {
	if m != nil {
		return m.V3AuthenticationPassword
	}
	return ""
}

func (m *SNMPCredentials) GetV3EngineTime() int64 {
	if m != nil {
		return m.V3EngineTime
	}
	return 0
}

func (m *SNMPCredentials) GetV3EngineId() string {
	if m != nil {
		return m.V3EngineId
	}
	return ""
}

func (m *SNMPCredentials) GetLocalPort() int64 {
	if m != nil {
		return m.LocalPort
	}
	return 0
}

func (m *SNMPCredentials) GetV3SecurityLevel() string {
	if m != nil {
		return m.V3SecurityLevel
	}
	return ""
}

func (m *SNMPCredentials) GetV3Context() string {
	if m != nil {
		return m.V3Context
	}
	return ""
}

func (m *SNMPCredentials) GetV3SecurityName() string {
	if m != nil {
		return m.V3SecurityName
	}
	return ""
}

func (m *SNMPCredentials) GetV3AuthenticationProtocol() string {
	if m != nil {
		return m.V3AuthenticationProtocol
	}
	return ""
}

func (m *SNMPCredentials) GetV2Community() string {
	if m != nil {
		return m.V2Community
	}
	return ""
}

func (m *SNMPCredentials) GetV3SecurityEngineId() string {
	if m != nil {
		return m.V3SecurityEngineId
	}
	return ""
}

func (m *SNMPCredentials) GetV3ContextEngineId() string {
	if m != nil {
		return m.V3ContextEngineId
	}
	return ""
}

func (m *SNMPCredentials) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SNMPCredentials) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *SNMPCredentials) GetV3PrivacyPassword() string {
	if m != nil {
		return m.V3PrivacyPassword
	}
	return ""
}

func (m *SNMPCredentials) GetV3EngineBoots() int64 {
	if m != nil {
		return m.V3EngineBoots
	}
	return 0
}

type PolicyBasedForwardingRuleType struct {
	DstMac                  string `protobuf:"bytes,1,opt,name=dst_mac,json=dstMac,proto3" json:"dst_mac,omitempty"`
	Protocol                string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Ipv6ServiceChainAddress string `protobuf:"bytes,3,opt,name=ipv6_service_chain_address,json=ipv6ServiceChainAddress,proto3" json:"ipv6_service_chain_address,omitempty"`
	Direction               string `protobuf:"bytes,4,opt,name=direction,proto3" json:"direction,omitempty"`
	MplsLabel               int64  `protobuf:"varint,5,opt,name=mpls_label,json=mplsLabel,proto3" json:"mpls_label,omitempty"`
	VlanTag                 int64  `protobuf:"varint,6,opt,name=vlan_tag,json=vlanTag,proto3" json:"vlan_tag,omitempty"`
	SrcMac                  string `protobuf:"bytes,7,opt,name=src_mac,json=srcMac,proto3" json:"src_mac,omitempty"`
	ServiceChainAddress     string `protobuf:"bytes,8,opt,name=service_chain_address,json=serviceChainAddress,proto3" json:"service_chain_address,omitempty"`
}

func (m *PolicyBasedForwardingRuleType) Reset()         { *m = PolicyBasedForwardingRuleType{} }
func (m *PolicyBasedForwardingRuleType) String() string { return proto.CompactTextString(m) }
func (*PolicyBasedForwardingRuleType) ProtoMessage()    {}
func (*PolicyBasedForwardingRuleType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{105}
}

func (m *PolicyBasedForwardingRuleType) GetDstMac() string {
	if m != nil {
		return m.DstMac
	}
	return ""
}

func (m *PolicyBasedForwardingRuleType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *PolicyBasedForwardingRuleType) GetIpv6ServiceChainAddress() string {
	if m != nil {
		return m.Ipv6ServiceChainAddress
	}
	return ""
}

func (m *PolicyBasedForwardingRuleType) GetDirection() string {
	if m != nil {
		return m.Direction
	}
	return ""
}

func (m *PolicyBasedForwardingRuleType) GetMplsLabel() int64 {
	if m != nil {
		return m.MplsLabel
	}
	return 0
}

func (m *PolicyBasedForwardingRuleType) GetVlanTag() int64 {
	if m != nil {
		return m.VlanTag
	}
	return 0
}

func (m *PolicyBasedForwardingRuleType) GetSrcMac() string {
	if m != nil {
		return m.SrcMac
	}
	return ""
}

func (m *PolicyBasedForwardingRuleType) GetServiceChainAddress() string {
	if m != nil {
		return m.ServiceChainAddress
	}
	return ""
}

type VirtualMachineInterfacePropertiesType struct {
	SubInterfaceVlanTag  int64                `protobuf:"varint,1,opt,name=sub_interface_vlan_tag,json=subInterfaceVlanTag,proto3" json:"sub_interface_vlan_tag,omitempty"`
	LocalPreference      int64                `protobuf:"varint,2,opt,name=local_preference,json=localPreference,proto3" json:"local_preference,omitempty"`
	InterfaceMirror      *InterfaceMirrorType `protobuf:"bytes,3,opt,name=interface_mirror,json=interfaceMirror" json:"interface_mirror,omitempty"`
	ServiceInterfaceType string               `protobuf:"bytes,4,opt,name=service_interface_type,json=serviceInterfaceType,proto3" json:"service_interface_type,omitempty"`
}

func (m *VirtualMachineInterfacePropertiesType) Reset()         { *m = VirtualMachineInterfacePropertiesType{} }
func (m *VirtualMachineInterfacePropertiesType) String() string { return proto.CompactTextString(m) }
func (*VirtualMachineInterfacePropertiesType) ProtoMessage()    {}
func (*VirtualMachineInterfacePropertiesType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{106}
}

func (m *VirtualMachineInterfacePropertiesType) GetSubInterfaceVlanTag() int64 {
	if m != nil {
		return m.SubInterfaceVlanTag
	}
	return 0
}

func (m *VirtualMachineInterfacePropertiesType) GetLocalPreference() int64 {
	if m != nil {
		return m.LocalPreference
	}
	return 0
}

func (m *VirtualMachineInterfacePropertiesType) GetInterfaceMirror() *InterfaceMirrorType {
	if m != nil {
		return m.InterfaceMirror
	}
	return nil
}

func (m *VirtualMachineInterfacePropertiesType) GetServiceInterfaceType() string {
	if m != nil {
		return m.ServiceInterfaceType
	}
	return ""
}

type VirtualNetworkPolicyType struct {
	Timer    *TimerType    `protobuf:"bytes,1,opt,name=timer" json:"timer,omitempty"`
	Sequence *SequenceType `protobuf:"bytes,2,opt,name=sequence" json:"sequence,omitempty"`
}

func (m *VirtualNetworkPolicyType) Reset()         { *m = VirtualNetworkPolicyType{} }
func (m *VirtualNetworkPolicyType) String() string { return proto.CompactTextString(m) }
func (*VirtualNetworkPolicyType) ProtoMessage()    {}
func (*VirtualNetworkPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{107}
}

func (m *VirtualNetworkPolicyType) GetTimer() *TimerType {
	if m != nil {
		return m.Timer
	}
	return nil
}

func (m *VirtualNetworkPolicyType) GetSequence() *SequenceType {
	if m != nil {
		return m.Sequence
	}
	return nil
}

type ShareType struct {
	TenantAccess int64  `protobuf:"varint,1,opt,name=tenant_access,json=tenantAccess,proto3" json:"tenant_access,omitempty"`
	Tenant       string `protobuf:"bytes,2,opt,name=tenant,proto3" json:"tenant,omitempty"`
}

func (m *ShareType) Reset()                    { *m = ShareType{} }
func (m *ShareType) String() string            { return proto.CompactTextString(m) }
func (*ShareType) ProtoMessage()               {}
func (*ShareType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{108} }

func (m *ShareType) GetTenantAccess() int64 {
	if m != nil {
		return m.TenantAccess
	}
	return 0
}

func (m *ShareType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

type StaticMirrorNhType struct {
	VtepDstIpAddress  string `protobuf:"bytes,1,opt,name=vtep_dst_ip_address,json=vtepDstIpAddress,proto3" json:"vtep_dst_ip_address,omitempty"`
	VtepDstMacAddress string `protobuf:"bytes,2,opt,name=vtep_dst_mac_address,json=vtepDstMacAddress,proto3" json:"vtep_dst_mac_address,omitempty"`
	Vni               int64  `protobuf:"varint,3,opt,name=vni,proto3" json:"vni,omitempty"`
}

func (m *StaticMirrorNhType) Reset()                    { *m = StaticMirrorNhType{} }
func (m *StaticMirrorNhType) String() string            { return proto.CompactTextString(m) }
func (*StaticMirrorNhType) ProtoMessage()               {}
func (*StaticMirrorNhType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{109} }

func (m *StaticMirrorNhType) GetVtepDstIpAddress() string {
	if m != nil {
		return m.VtepDstIpAddress
	}
	return ""
}

func (m *StaticMirrorNhType) GetVtepDstMacAddress() string {
	if m != nil {
		return m.VtepDstMacAddress
	}
	return ""
}

func (m *StaticMirrorNhType) GetVni() int64 {
	if m != nil {
		return m.Vni
	}
	return 0
}

type FirewallRuleMatchTagsTypeIdList struct {
	TagType []int64 `protobuf:"varint,1,rep,packed,name=tag_type,json=tagType" json:"tag_type,omitempty"`
}

func (m *FirewallRuleMatchTagsTypeIdList) Reset()         { *m = FirewallRuleMatchTagsTypeIdList{} }
func (m *FirewallRuleMatchTagsTypeIdList) String() string { return proto.CompactTextString(m) }
func (*FirewallRuleMatchTagsTypeIdList) ProtoMessage()    {}
func (*FirewallRuleMatchTagsTypeIdList) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{110}
}

func (m *FirewallRuleMatchTagsTypeIdList) GetTagType() []int64 {
	if m != nil {
		return m.TagType
	}
	return nil
}

type CommunityAttributes struct {
	CommunityAttribute [][]byte `protobuf:"bytes,1,rep,name=community_attribute,json=communityAttribute" json:"community_attribute,omitempty"`
}

func (m *CommunityAttributes) Reset()                    { *m = CommunityAttributes{} }
func (m *CommunityAttributes) String() string            { return proto.CompactTextString(m) }
func (*CommunityAttributes) ProtoMessage()               {}
func (*CommunityAttributes) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{111} }

func (m *CommunityAttributes) GetCommunityAttribute() [][]byte {
	if m != nil {
		return m.CommunityAttribute
	}
	return nil
}

type IpAddressesType struct {
	IpAddress string `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
}

func (m *IpAddressesType) Reset()                    { *m = IpAddressesType{} }
func (m *IpAddressesType) String() string            { return proto.CompactTextString(m) }
func (*IpAddressesType) ProtoMessage()               {}
func (*IpAddressesType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{112} }

func (m *IpAddressesType) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

type ServiceTemplateInterfaceType struct {
	StaticRouteEnable    bool   `protobuf:"varint,1,opt,name=static_route_enable,json=staticRouteEnable,proto3" json:"static_route_enable,omitempty"`
	SharedIp             bool   `protobuf:"varint,2,opt,name=shared_ip,json=sharedIp,proto3" json:"shared_ip,omitempty"`
	ServiceInterfaceType string `protobuf:"bytes,3,opt,name=service_interface_type,json=serviceInterfaceType,proto3" json:"service_interface_type,omitempty"`
}

func (m *ServiceTemplateInterfaceType) Reset()         { *m = ServiceTemplateInterfaceType{} }
func (m *ServiceTemplateInterfaceType) String() string { return proto.CompactTextString(m) }
func (*ServiceTemplateInterfaceType) ProtoMessage()    {}
func (*ServiceTemplateInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{113}
}

func (m *ServiceTemplateInterfaceType) GetStaticRouteEnable() bool {
	if m != nil {
		return m.StaticRouteEnable
	}
	return false
}

func (m *ServiceTemplateInterfaceType) GetSharedIp() bool {
	if m != nil {
		return m.SharedIp
	}
	return false
}

func (m *ServiceTemplateInterfaceType) GetServiceInterfaceType() string {
	if m != nil {
		return m.ServiceInterfaceType
	}
	return ""
}

type IdPermsType struct {
	Enable       bool      `protobuf:"varint,1,opt,name=enable,proto3" json:"enable,omitempty"`
	Description  string    `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Created      string    `protobuf:"bytes,3,opt,name=created,proto3" json:"created,omitempty"`
	Creator      string    `protobuf:"bytes,4,opt,name=creator,proto3" json:"creator,omitempty"`
	UserVisible  bool      `protobuf:"varint,5,opt,name=user_visible,json=userVisible,proto3" json:"user_visible,omitempty"`
	LastModified string    `protobuf:"bytes,6,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	Permissions  *PermType `protobuf:"bytes,7,opt,name=permissions" json:"permissions,omitempty"`
}

func (m *IdPermsType) Reset()                    { *m = IdPermsType{} }
func (m *IdPermsType) String() string            { return proto.CompactTextString(m) }
func (*IdPermsType) ProtoMessage()               {}
func (*IdPermsType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{114} }

func (m *IdPermsType) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *IdPermsType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *IdPermsType) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *IdPermsType) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *IdPermsType) GetUserVisible() bool {
	if m != nil {
		return m.UserVisible
	}
	return false
}

func (m *IdPermsType) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *IdPermsType) GetPermissions() *PermType {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type RbacPermType struct {
	RoleCrud string `protobuf:"bytes,1,opt,name=role_crud,json=roleCrud,proto3" json:"role_crud,omitempty"`
	RoleName string `protobuf:"bytes,2,opt,name=role_name,json=roleName,proto3" json:"role_name,omitempty"`
}

func (m *RbacPermType) Reset()                    { *m = RbacPermType{} }
func (m *RbacPermType) String() string            { return proto.CompactTextString(m) }
func (*RbacPermType) ProtoMessage()               {}
func (*RbacPermType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{115} }

func (m *RbacPermType) GetRoleCrud() string {
	if m != nil {
		return m.RoleCrud
	}
	return ""
}

func (m *RbacPermType) GetRoleName() string {
	if m != nil {
		return m.RoleName
	}
	return ""
}

type FlowAgingTimeoutList struct {
	FlowAgingTimeout []*FlowAgingTimeout `protobuf:"bytes,1,rep,name=flow_aging_timeout,json=flowAgingTimeout" json:"flow_aging_timeout,omitempty"`
}

func (m *FlowAgingTimeoutList) Reset()                    { *m = FlowAgingTimeoutList{} }
func (m *FlowAgingTimeoutList) String() string            { return proto.CompactTextString(m) }
func (*FlowAgingTimeoutList) ProtoMessage()               {}
func (*FlowAgingTimeoutList) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{116} }

func (m *FlowAgingTimeoutList) GetFlowAgingTimeout() []*FlowAgingTimeout {
	if m != nil {
		return m.FlowAgingTimeout
	}
	return nil
}

type UveKeysType struct {
	UveKey []string `protobuf:"bytes,1,rep,name=uve_key,json=uveKey" json:"uve_key,omitempty"`
}

func (m *UveKeysType) Reset()                    { *m = UveKeysType{} }
func (m *UveKeysType) String() string            { return proto.CompactTextString(m) }
func (*UveKeysType) ProtoMessage()               {}
func (*UveKeysType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{117} }

func (m *UveKeysType) GetUveKey() []string {
	if m != nil {
		return m.UveKey
	}
	return nil
}

type DiscoveryServiceAssignmentType struct {
	Subscriber []*DiscoveryPubSubEndPointType `protobuf:"bytes,1,rep,name=subscriber" json:"subscriber,omitempty"`
	Publisher  *DiscoveryPubSubEndPointType   `protobuf:"bytes,2,opt,name=publisher" json:"publisher,omitempty"`
}

func (m *DiscoveryServiceAssignmentType) Reset()         { *m = DiscoveryServiceAssignmentType{} }
func (m *DiscoveryServiceAssignmentType) String() string { return proto.CompactTextString(m) }
func (*DiscoveryServiceAssignmentType) ProtoMessage()    {}
func (*DiscoveryServiceAssignmentType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{118}
}

func (m *DiscoveryServiceAssignmentType) GetSubscriber() []*DiscoveryPubSubEndPointType {
	if m != nil {
		return m.Subscriber
	}
	return nil
}

func (m *DiscoveryServiceAssignmentType) GetPublisher() *DiscoveryPubSubEndPointType {
	if m != nil {
		return m.Publisher
	}
	return nil
}

type GracefulRestartParametersType struct {
	Enable               bool  `protobuf:"varint,1,opt,name=enable,proto3" json:"enable,omitempty"`
	EndOfRibTimeout      int64 `protobuf:"varint,2,opt,name=end_of_rib_timeout,json=endOfRibTimeout,proto3" json:"end_of_rib_timeout,omitempty"`
	BgpHelperEnable      bool  `protobuf:"varint,3,opt,name=bgp_helper_enable,json=bgpHelperEnable,proto3" json:"bgp_helper_enable,omitempty"`
	XmppHelperEnable     bool  `protobuf:"varint,4,opt,name=xmpp_helper_enable,json=xmppHelperEnable,proto3" json:"xmpp_helper_enable,omitempty"`
	RestartTime          int64 `protobuf:"varint,5,opt,name=restart_time,json=restartTime,proto3" json:"restart_time,omitempty"`
	LongLivedRestartTime int64 `protobuf:"varint,6,opt,name=long_lived_restart_time,json=longLivedRestartTime,proto3" json:"long_lived_restart_time,omitempty"`
}

func (m *GracefulRestartParametersType) Reset()         { *m = GracefulRestartParametersType{} }
func (m *GracefulRestartParametersType) String() string { return proto.CompactTextString(m) }
func (*GracefulRestartParametersType) ProtoMessage()    {}
func (*GracefulRestartParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{119}
}

func (m *GracefulRestartParametersType) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *GracefulRestartParametersType) GetEndOfRibTimeout() int64 {
	if m != nil {
		return m.EndOfRibTimeout
	}
	return 0
}

func (m *GracefulRestartParametersType) GetBgpHelperEnable() bool {
	if m != nil {
		return m.BgpHelperEnable
	}
	return false
}

func (m *GracefulRestartParametersType) GetXmppHelperEnable() bool {
	if m != nil {
		return m.XmppHelperEnable
	}
	return false
}

func (m *GracefulRestartParametersType) GetRestartTime() int64 {
	if m != nil {
		return m.RestartTime
	}
	return 0
}

func (m *GracefulRestartParametersType) GetLongLivedRestartTime() int64 {
	if m != nil {
		return m.LongLivedRestartTime
	}
	return 0
}

type ServiceInterfaceTag struct {
	InterfaceType string `protobuf:"bytes,1,opt,name=interface_type,json=interfaceType,proto3" json:"interface_type,omitempty"`
}

func (m *ServiceInterfaceTag) Reset()                    { *m = ServiceInterfaceTag{} }
func (m *ServiceInterfaceTag) String() string            { return proto.CompactTextString(m) }
func (*ServiceInterfaceTag) ProtoMessage()               {}
func (*ServiceInterfaceTag) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{120} }

func (m *ServiceInterfaceTag) GetInterfaceType() string {
	if m != nil {
		return m.InterfaceType
	}
	return ""
}

type AllocationPoolType struct {
	VrouterSpecificPool bool   `protobuf:"varint,1,opt,name=vrouter_specific_pool,json=vrouterSpecificPool,proto3" json:"vrouter_specific_pool,omitempty"`
	Start               string `protobuf:"bytes,2,opt,name=start,proto3" json:"start,omitempty"`
	End                 string `protobuf:"bytes,3,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *AllocationPoolType) Reset()                    { *m = AllocationPoolType{} }
func (m *AllocationPoolType) String() string            { return proto.CompactTextString(m) }
func (*AllocationPoolType) ProtoMessage()               {}
func (*AllocationPoolType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{121} }

func (m *AllocationPoolType) GetVrouterSpecificPool() bool {
	if m != nil {
		return m.VrouterSpecificPool
	}
	return false
}

func (m *AllocationPoolType) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *AllocationPoolType) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

type PolicyRuleType struct {
	Direction    string          `protobuf:"bytes,1,opt,name=direction,proto3" json:"direction,omitempty"`
	Protocol     string          `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	DstAddresses []*AddressType  `protobuf:"bytes,3,rep,name=dst_addresses,json=dstAddresses" json:"dst_addresses,omitempty"`
	ActionList   *ActionListType `protobuf:"bytes,4,opt,name=action_list,json=actionList" json:"action_list,omitempty"`
	Created      string          `protobuf:"bytes,5,opt,name=created,proto3" json:"created,omitempty"`
	RuleUuid     string          `protobuf:"bytes,6,opt,name=rule_uuid,json=ruleUuid,proto3" json:"rule_uuid,omitempty"`
	DstPorts     []*PortType     `protobuf:"bytes,7,rep,name=dst_ports,json=dstPorts" json:"dst_ports,omitempty"`
	Application  []string        `protobuf:"bytes,8,rep,name=application" json:"application,omitempty"`
	LastModified string          `protobuf:"bytes,9,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	Ethertype    string          `protobuf:"bytes,10,opt,name=ethertype,proto3" json:"ethertype,omitempty"`
	SrcAddresses []*AddressType  `protobuf:"bytes,11,rep,name=src_addresses,json=srcAddresses" json:"src_addresses,omitempty"`
	RuleSequence *SequenceType   `protobuf:"bytes,12,opt,name=rule_sequence,json=ruleSequence" json:"rule_sequence,omitempty"`
	SrcPorts     []*PortType     `protobuf:"bytes,13,rep,name=src_ports,json=srcPorts" json:"src_ports,omitempty"`
}

func (m *PolicyRuleType) Reset()                    { *m = PolicyRuleType{} }
func (m *PolicyRuleType) String() string            { return proto.CompactTextString(m) }
func (*PolicyRuleType) ProtoMessage()               {}
func (*PolicyRuleType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{122} }

func (m *PolicyRuleType) GetDirection() string {
	if m != nil {
		return m.Direction
	}
	return ""
}

func (m *PolicyRuleType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *PolicyRuleType) GetDstAddresses() []*AddressType {
	if m != nil {
		return m.DstAddresses
	}
	return nil
}

func (m *PolicyRuleType) GetActionList() *ActionListType {
	if m != nil {
		return m.ActionList
	}
	return nil
}

func (m *PolicyRuleType) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *PolicyRuleType) GetRuleUuid() string {
	if m != nil {
		return m.RuleUuid
	}
	return ""
}

func (m *PolicyRuleType) GetDstPorts() []*PortType {
	if m != nil {
		return m.DstPorts
	}
	return nil
}

func (m *PolicyRuleType) GetApplication() []string {
	if m != nil {
		return m.Application
	}
	return nil
}

func (m *PolicyRuleType) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *PolicyRuleType) GetEthertype() string {
	if m != nil {
		return m.Ethertype
	}
	return ""
}

func (m *PolicyRuleType) GetSrcAddresses() []*AddressType {
	if m != nil {
		return m.SrcAddresses
	}
	return nil
}

func (m *PolicyRuleType) GetRuleSequence() *SequenceType {
	if m != nil {
		return m.RuleSequence
	}
	return nil
}

func (m *PolicyRuleType) GetSrcPorts() []*PortType {
	if m != nil {
		return m.SrcPorts
	}
	return nil
}

type VirtualDnsRecordType struct {
	RecordName         string `protobuf:"bytes,1,opt,name=record_name,json=recordName,proto3" json:"record_name,omitempty"`
	RecordClass        string `protobuf:"bytes,2,opt,name=record_class,json=recordClass,proto3" json:"record_class,omitempty"`
	RecordData         string `protobuf:"bytes,3,opt,name=record_data,json=recordData,proto3" json:"record_data,omitempty"`
	RecordType         string `protobuf:"bytes,4,opt,name=record_type,json=recordType,proto3" json:"record_type,omitempty"`
	RecordTtlSeconds   int64  `protobuf:"varint,5,opt,name=record_ttl_seconds,json=recordTtlSeconds,proto3" json:"record_ttl_seconds,omitempty"`
	RecordMxPreference int64  `protobuf:"varint,6,opt,name=record_mx_preference,json=recordMxPreference,proto3" json:"record_mx_preference,omitempty"`
}

func (m *VirtualDnsRecordType) Reset()                    { *m = VirtualDnsRecordType{} }
func (m *VirtualDnsRecordType) String() string            { return proto.CompactTextString(m) }
func (*VirtualDnsRecordType) ProtoMessage()               {}
func (*VirtualDnsRecordType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{123} }

func (m *VirtualDnsRecordType) GetRecordName() string {
	if m != nil {
		return m.RecordName
	}
	return ""
}

func (m *VirtualDnsRecordType) GetRecordClass() string {
	if m != nil {
		return m.RecordClass
	}
	return ""
}

func (m *VirtualDnsRecordType) GetRecordData() string {
	if m != nil {
		return m.RecordData
	}
	return ""
}

func (m *VirtualDnsRecordType) GetRecordType() string {
	if m != nil {
		return m.RecordType
	}
	return ""
}

func (m *VirtualDnsRecordType) GetRecordTtlSeconds() int64 {
	if m != nil {
		return m.RecordTtlSeconds
	}
	return 0
}

func (m *VirtualDnsRecordType) GetRecordMxPreference() int64 {
	if m != nil {
		return m.RecordMxPreference
	}
	return 0
}

type AlarmExpression struct {
	Operation string         `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	Operand1  string         `protobuf:"bytes,2,opt,name=operand1,proto3" json:"operand1,omitempty"`
	Variables []string       `protobuf:"bytes,3,rep,name=variables" json:"variables,omitempty"`
	Operand2  *AlarmOperand2 `protobuf:"bytes,4,opt,name=operand2" json:"operand2,omitempty"`
}

func (m *AlarmExpression) Reset()                    { *m = AlarmExpression{} }
func (m *AlarmExpression) String() string            { return proto.CompactTextString(m) }
func (*AlarmExpression) ProtoMessage()               {}
func (*AlarmExpression) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{124} }

func (m *AlarmExpression) GetOperation() string {
	if m != nil {
		return m.Operation
	}
	return ""
}

func (m *AlarmExpression) GetOperand1() string {
	if m != nil {
		return m.Operand1
	}
	return ""
}

func (m *AlarmExpression) GetVariables() []string {
	if m != nil {
		return m.Variables
	}
	return nil
}

func (m *AlarmExpression) GetOperand2() *AlarmOperand2 {
	if m != nil {
		return m.Operand2
	}
	return nil
}

type FirewallServiceType struct {
	Protocol   string    `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	DstPorts   *PortType `protobuf:"bytes,2,opt,name=dst_ports,json=dstPorts" json:"dst_ports,omitempty"`
	SrcPorts   *PortType `protobuf:"bytes,3,opt,name=src_ports,json=srcPorts" json:"src_ports,omitempty"`
	ProtocolId int64     `protobuf:"varint,4,opt,name=protocol_id,json=protocolId,proto3" json:"protocol_id,omitempty"`
}

func (m *FirewallServiceType) Reset()                    { *m = FirewallServiceType{} }
func (m *FirewallServiceType) String() string            { return proto.CompactTextString(m) }
func (*FirewallServiceType) ProtoMessage()               {}
func (*FirewallServiceType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{125} }

func (m *FirewallServiceType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *FirewallServiceType) GetDstPorts() *PortType {
	if m != nil {
		return m.DstPorts
	}
	return nil
}

func (m *FirewallServiceType) GetSrcPorts() *PortType {
	if m != nil {
		return m.SrcPorts
	}
	return nil
}

func (m *FirewallServiceType) GetProtocolId() int64 {
	if m != nil {
		return m.ProtocolId
	}
	return 0
}

type RoutingPolicyServiceInstanceType struct {
	RightSequence string `protobuf:"bytes,1,opt,name=right_sequence,json=rightSequence,proto3" json:"right_sequence,omitempty"`
	LeftSequence  string `protobuf:"bytes,2,opt,name=left_sequence,json=leftSequence,proto3" json:"left_sequence,omitempty"`
}

func (m *RoutingPolicyServiceInstanceType) Reset()         { *m = RoutingPolicyServiceInstanceType{} }
func (m *RoutingPolicyServiceInstanceType) String() string { return proto.CompactTextString(m) }
func (*RoutingPolicyServiceInstanceType) ProtoMessage()    {}
func (*RoutingPolicyServiceInstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{126}
}

func (m *RoutingPolicyServiceInstanceType) GetRightSequence() string {
	if m != nil {
		return m.RightSequence
	}
	return ""
}

func (m *RoutingPolicyServiceInstanceType) GetLeftSequence() string {
	if m != nil {
		return m.LeftSequence
	}
	return ""
}

type TimerType struct {
	StartTime   string `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	OffInterval string `protobuf:"bytes,2,opt,name=off_interval,json=offInterval,proto3" json:"off_interval,omitempty"`
	OnInterval  string `protobuf:"bytes,3,opt,name=on_interval,json=onInterval,proto3" json:"on_interval,omitempty"`
	EndTime     string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *TimerType) Reset()                    { *m = TimerType{} }
func (m *TimerType) String() string            { return proto.CompactTextString(m) }
func (*TimerType) ProtoMessage()               {}
func (*TimerType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{127} }

func (m *TimerType) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *TimerType) GetOffInterval() string {
	if m != nil {
		return m.OffInterval
	}
	return ""
}

func (m *TimerType) GetOnInterval() string {
	if m != nil {
		return m.OnInterval
	}
	return ""
}

func (m *TimerType) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

type FirewallRuleEndpointType struct {
	AddressGroup   string      `protobuf:"bytes,1,opt,name=address_group,json=addressGroup,proto3" json:"address_group,omitempty"`
	Subnet         *SubnetType `protobuf:"bytes,2,opt,name=subnet" json:"subnet,omitempty"`
	Tags           []string    `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty"`
	TagIds         []int64     `protobuf:"varint,4,rep,packed,name=tag_ids,json=tagIds" json:"tag_ids,omitempty"`
	VirtualNetwork string      `protobuf:"bytes,5,opt,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
	Any            bool        `protobuf:"varint,6,opt,name=any,proto3" json:"any,omitempty"`
}

func (m *FirewallRuleEndpointType) Reset()         { *m = FirewallRuleEndpointType{} }
func (m *FirewallRuleEndpointType) String() string { return proto.CompactTextString(m) }
func (*FirewallRuleEndpointType) ProtoMessage()    {}
func (*FirewallRuleEndpointType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{128}
}

func (m *FirewallRuleEndpointType) GetAddressGroup() string {
	if m != nil {
		return m.AddressGroup
	}
	return ""
}

func (m *FirewallRuleEndpointType) GetSubnet() *SubnetType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *FirewallRuleEndpointType) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *FirewallRuleEndpointType) GetTagIds() []int64 {
	if m != nil {
		return m.TagIds
	}
	return nil
}

func (m *FirewallRuleEndpointType) GetVirtualNetwork() string {
	if m != nil {
		return m.VirtualNetwork
	}
	return ""
}

func (m *FirewallRuleEndpointType) GetAny() bool {
	if m != nil {
		return m.Any
	}
	return false
}

type InterfaceMirrorType struct {
	TrafficDirection string            `protobuf:"bytes,1,opt,name=traffic_direction,json=trafficDirection,proto3" json:"traffic_direction,omitempty"`
	MirrorTo         *MirrorActionType `protobuf:"bytes,2,opt,name=mirror_to,json=mirrorTo" json:"mirror_to,omitempty"`
}

func (m *InterfaceMirrorType) Reset()                    { *m = InterfaceMirrorType{} }
func (m *InterfaceMirrorType) String() string            { return proto.CompactTextString(m) }
func (*InterfaceMirrorType) ProtoMessage()               {}
func (*InterfaceMirrorType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{129} }

func (m *InterfaceMirrorType) GetTrafficDirection() string {
	if m != nil {
		return m.TrafficDirection
	}
	return ""
}

func (m *InterfaceMirrorType) GetMirrorTo() *MirrorActionType {
	if m != nil {
		return m.MirrorTo
	}
	return nil
}

type VirtualNetworkType struct {
	ForwardingMode         string `protobuf:"bytes,1,opt,name=forwarding_mode,json=forwardingMode,proto3" json:"forwarding_mode,omitempty"`
	AllowTransit           bool   `protobuf:"varint,2,opt,name=allow_transit,json=allowTransit,proto3" json:"allow_transit,omitempty"`
	NetworkId              int64  `protobuf:"varint,3,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
	MirrorDestination      bool   `protobuf:"varint,4,opt,name=mirror_destination,json=mirrorDestination,proto3" json:"mirror_destination,omitempty"`
	VxlanNetworkIdentifier int64  `protobuf:"varint,5,opt,name=vxlan_network_identifier,json=vxlanNetworkIdentifier,proto3" json:"vxlan_network_identifier,omitempty"`
	Rpf                    string `protobuf:"bytes,6,opt,name=rpf,proto3" json:"rpf,omitempty"`
}

func (m *VirtualNetworkType) Reset()                    { *m = VirtualNetworkType{} }
func (m *VirtualNetworkType) String() string            { return proto.CompactTextString(m) }
func (*VirtualNetworkType) ProtoMessage()               {}
func (*VirtualNetworkType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{130} }

func (m *VirtualNetworkType) GetForwardingMode() string {
	if m != nil {
		return m.ForwardingMode
	}
	return ""
}

func (m *VirtualNetworkType) GetAllowTransit() bool {
	if m != nil {
		return m.AllowTransit
	}
	return false
}

func (m *VirtualNetworkType) GetNetworkId() int64 {
	if m != nil {
		return m.NetworkId
	}
	return 0
}

func (m *VirtualNetworkType) GetMirrorDestination() bool {
	if m != nil {
		return m.MirrorDestination
	}
	return false
}

func (m *VirtualNetworkType) GetVxlanNetworkIdentifier() int64 {
	if m != nil {
		return m.VxlanNetworkIdentifier
	}
	return 0
}

func (m *VirtualNetworkType) GetRpf() string {
	if m != nil {
		return m.Rpf
	}
	return ""
}

type PortType struct {
	EndPort   int64 `protobuf:"varint,1,opt,name=end_port,json=endPort,proto3" json:"end_port,omitempty"`
	StartPort int64 `protobuf:"varint,2,opt,name=start_port,json=startPort,proto3" json:"start_port,omitempty"`
}

func (m *PortType) Reset()                    { *m = PortType{} }
func (m *PortType) String() string            { return proto.CompactTextString(m) }
func (*PortType) ProtoMessage()               {}
func (*PortType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{131} }

func (m *PortType) GetEndPort() int64 {
	if m != nil {
		return m.EndPort
	}
	return 0
}

func (m *PortType) GetStartPort() int64 {
	if m != nil {
		return m.StartPort
	}
	return 0
}

type PortMappings struct {
	PortMappings []*PortMap `protobuf:"bytes,1,rep,name=port_mappings,json=portMappings" json:"port_mappings,omitempty"`
}

func (m *PortMappings) Reset()                    { *m = PortMappings{} }
func (m *PortMappings) String() string            { return proto.CompactTextString(m) }
func (*PortMappings) ProtoMessage()               {}
func (*PortMappings) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{132} }

func (m *PortMappings) GetPortMappings() []*PortMap {
	if m != nil {
		return m.PortMappings
	}
	return nil
}

type ServiceInstanceInterfaceType struct {
	VirtualNetwork      string               `protobuf:"bytes,1,opt,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
	IpAddress           string               `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	AllowedAddressPairs *AllowedAddressPairs `protobuf:"bytes,3,opt,name=allowed_address_pairs,json=allowedAddressPairs" json:"allowed_address_pairs,omitempty"`
	StaticRoutes        *RouteTableType      `protobuf:"bytes,4,opt,name=static_routes,json=staticRoutes" json:"static_routes,omitempty"`
}

func (m *ServiceInstanceInterfaceType) Reset()         { *m = ServiceInstanceInterfaceType{} }
func (m *ServiceInstanceInterfaceType) String() string { return proto.CompactTextString(m) }
func (*ServiceInstanceInterfaceType) ProtoMessage()    {}
func (*ServiceInstanceInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{133}
}

func (m *ServiceInstanceInterfaceType) GetVirtualNetwork() string {
	if m != nil {
		return m.VirtualNetwork
	}
	return ""
}

func (m *ServiceInstanceInterfaceType) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *ServiceInstanceInterfaceType) GetAllowedAddressPairs() *AllowedAddressPairs {
	if m != nil {
		return m.AllowedAddressPairs
	}
	return nil
}

func (m *ServiceInstanceInterfaceType) GetStaticRoutes() *RouteTableType {
	if m != nil {
		return m.StaticRoutes
	}
	return nil
}

type SequenceType struct {
	Major int64 `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	Minor int64 `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
}

func (m *SequenceType) Reset()                    { *m = SequenceType{} }
func (m *SequenceType) String() string            { return proto.CompactTextString(m) }
func (*SequenceType) ProtoMessage()               {}
func (*SequenceType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{134} }

func (m *SequenceType) GetMajor() int64 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *SequenceType) GetMinor() int64 {
	if m != nil {
		return m.Minor
	}
	return 0
}

type SecurityLoggingObjectRuleEntryType struct {
	RuleUuid string `protobuf:"bytes,1,opt,name=rule_uuid,json=ruleUuid,proto3" json:"rule_uuid,omitempty"`
	Rate     int64  `protobuf:"varint,2,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *SecurityLoggingObjectRuleEntryType) Reset()         { *m = SecurityLoggingObjectRuleEntryType{} }
func (m *SecurityLoggingObjectRuleEntryType) String() string { return proto.CompactTextString(m) }
func (*SecurityLoggingObjectRuleEntryType) ProtoMessage()    {}
func (*SecurityLoggingObjectRuleEntryType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{135}
}

func (m *SecurityLoggingObjectRuleEntryType) GetRuleUuid() string {
	if m != nil {
		return m.RuleUuid
	}
	return ""
}

func (m *SecurityLoggingObjectRuleEntryType) GetRate() int64 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type SubnetType struct {
	IpPrefix    string `protobuf:"bytes,1,opt,name=ip_prefix,json=ipPrefix,proto3" json:"ip_prefix,omitempty"`
	IpPrefixLen int64  `protobuf:"varint,2,opt,name=ip_prefix_len,json=ipPrefixLen,proto3" json:"ip_prefix_len,omitempty"`
}

func (m *SubnetType) Reset()                    { *m = SubnetType{} }
func (m *SubnetType) String() string            { return proto.CompactTextString(m) }
func (*SubnetType) ProtoMessage()               {}
func (*SubnetType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{136} }

func (m *SubnetType) GetIpPrefix() string {
	if m != nil {
		return m.IpPrefix
	}
	return ""
}

func (m *SubnetType) GetIpPrefixLen() int64 {
	if m != nil {
		return m.IpPrefixLen
	}
	return 0
}

type RouteTargetList struct {
	RouteTarget []string `protobuf:"bytes,1,rep,name=route_target,json=routeTarget" json:"route_target,omitempty"`
}

func (m *RouteTargetList) Reset()                    { *m = RouteTargetList{} }
func (m *RouteTargetList) String() string            { return proto.CompactTextString(m) }
func (*RouteTargetList) ProtoMessage()               {}
func (*RouteTargetList) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{137} }

func (m *RouteTargetList) GetRouteTarget() []string {
	if m != nil {
		return m.RouteTarget
	}
	return nil
}

type LinklocalServiceEntryType struct {
	IpFabricServiceIp       []string `protobuf:"bytes,1,rep,name=ip_fabric_service_ip,json=ipFabricServiceIp" json:"ip_fabric_service_ip,omitempty"`
	LinklocalServiceName    string   `protobuf:"bytes,2,opt,name=linklocal_service_name,json=linklocalServiceName,proto3" json:"linklocal_service_name,omitempty"`
	LinklocalServiceIp      string   `protobuf:"bytes,3,opt,name=linklocal_service_ip,json=linklocalServiceIp,proto3" json:"linklocal_service_ip,omitempty"`
	IpFabricServicePort     int64    `protobuf:"varint,4,opt,name=ip_fabric_service_port,json=ipFabricServicePort,proto3" json:"ip_fabric_service_port,omitempty"`
	IpFabric_DNSServiceName string   `protobuf:"bytes,5,opt,name=ip_fabric_DNS_service_name,json=ipFabricDNSServiceName,proto3" json:"ip_fabric_DNS_service_name,omitempty"`
	LinklocalServicePort    int64    `protobuf:"varint,6,opt,name=linklocal_service_port,json=linklocalServicePort,proto3" json:"linklocal_service_port,omitempty"`
}

func (m *LinklocalServiceEntryType) Reset()         { *m = LinklocalServiceEntryType{} }
func (m *LinklocalServiceEntryType) String() string { return proto.CompactTextString(m) }
func (*LinklocalServiceEntryType) ProtoMessage()    {}
func (*LinklocalServiceEntryType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{138}
}

func (m *LinklocalServiceEntryType) GetIpFabricServiceIp() []string {
	if m != nil {
		return m.IpFabricServiceIp
	}
	return nil
}

func (m *LinklocalServiceEntryType) GetLinklocalServiceName() string {
	if m != nil {
		return m.LinklocalServiceName
	}
	return ""
}

func (m *LinklocalServiceEntryType) GetLinklocalServiceIp() string {
	if m != nil {
		return m.LinklocalServiceIp
	}
	return ""
}

func (m *LinklocalServiceEntryType) GetIpFabricServicePort() int64 {
	if m != nil {
		return m.IpFabricServicePort
	}
	return 0
}

func (m *LinklocalServiceEntryType) GetIpFabric_DNSServiceName() string {
	if m != nil {
		return m.IpFabric_DNSServiceName
	}
	return ""
}

func (m *LinklocalServiceEntryType) GetLinklocalServicePort() int64 {
	if m != nil {
		return m.LinklocalServicePort
	}
	return 0
}

type IpamSubnetType struct {
	Subnet           *SubnetType           `protobuf:"bytes,1,opt,name=subnet" json:"subnet,omitempty"`
	AddrFromStart    bool                  `protobuf:"varint,2,opt,name=addr_from_start,json=addrFromStart,proto3" json:"addr_from_start,omitempty"`
	EnableDhcp       bool                  `protobuf:"varint,3,opt,name=enable_dhcp,json=enableDhcp,proto3" json:"enable_dhcp,omitempty"`
	DefaultGateway   string                `protobuf:"bytes,4,opt,name=default_gateway,json=defaultGateway,proto3" json:"default_gateway,omitempty"`
	AllocUnit        int64                 `protobuf:"varint,5,opt,name=alloc_unit,json=allocUnit,proto3" json:"alloc_unit,omitempty"`
	Created          string                `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
	DnsNameservers   []string              `protobuf:"bytes,7,rep,name=dns_nameservers,json=dnsNameservers" json:"dns_nameservers,omitempty"`
	DhcpOptionList   *DhcpOptionsListType  `protobuf:"bytes,8,opt,name=dhcp_option_list,json=dhcpOptionList" json:"dhcp_option_list,omitempty"`
	SubnetUuid       string                `protobuf:"bytes,9,opt,name=subnet_uuid,json=subnetUuid,proto3" json:"subnet_uuid,omitempty"`
	AllocationPools  []*AllocationPoolType `protobuf:"bytes,10,rep,name=allocation_pools,json=allocationPools" json:"allocation_pools,omitempty"`
	LastModified     string                `protobuf:"bytes,11,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	HostRoutes       *RouteTableType       `protobuf:"bytes,12,opt,name=host_routes,json=hostRoutes" json:"host_routes,omitempty"`
	DnsServerAddress string                `protobuf:"bytes,13,opt,name=dns_server_address,json=dnsServerAddress,proto3" json:"dns_server_address,omitempty"`
	SubnetName       string                `protobuf:"bytes,14,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
}

func (m *IpamSubnetType) Reset()                    { *m = IpamSubnetType{} }
func (m *IpamSubnetType) String() string            { return proto.CompactTextString(m) }
func (*IpamSubnetType) ProtoMessage()               {}
func (*IpamSubnetType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{139} }

func (m *IpamSubnetType) GetSubnet() *SubnetType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *IpamSubnetType) GetAddrFromStart() bool {
	if m != nil {
		return m.AddrFromStart
	}
	return false
}

func (m *IpamSubnetType) GetEnableDhcp() bool {
	if m != nil {
		return m.EnableDhcp
	}
	return false
}

func (m *IpamSubnetType) GetDefaultGateway() string {
	if m != nil {
		return m.DefaultGateway
	}
	return ""
}

func (m *IpamSubnetType) GetAllocUnit() int64 {
	if m != nil {
		return m.AllocUnit
	}
	return 0
}

func (m *IpamSubnetType) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *IpamSubnetType) GetDnsNameservers() []string {
	if m != nil {
		return m.DnsNameservers
	}
	return nil
}

func (m *IpamSubnetType) GetDhcpOptionList() *DhcpOptionsListType {
	if m != nil {
		return m.DhcpOptionList
	}
	return nil
}

func (m *IpamSubnetType) GetSubnetUuid() string {
	if m != nil {
		return m.SubnetUuid
	}
	return ""
}

func (m *IpamSubnetType) GetAllocationPools() []*AllocationPoolType {
	if m != nil {
		return m.AllocationPools
	}
	return nil
}

func (m *IpamSubnetType) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *IpamSubnetType) GetHostRoutes() *RouteTableType {
	if m != nil {
		return m.HostRoutes
	}
	return nil
}

func (m *IpamSubnetType) GetDnsServerAddress() string {
	if m != nil {
		return m.DnsServerAddress
	}
	return ""
}

func (m *IpamSubnetType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

type QuotaType struct {
	VirtualRouter             int64 `protobuf:"varint,1,opt,name=virtual_router,json=virtualRouter,proto3" json:"virtual_router,omitempty"`
	NetworkPolicy             int64 `protobuf:"varint,2,opt,name=network_policy,json=networkPolicy,proto3" json:"network_policy,omitempty"`
	LoadbalancerPool          int64 `protobuf:"varint,3,opt,name=loadbalancer_pool,json=loadbalancerPool,proto3" json:"loadbalancer_pool,omitempty"`
	RouteTable                int64 `protobuf:"varint,4,opt,name=route_table,json=routeTable,proto3" json:"route_table,omitempty"`
	Subnet                    int64 `protobuf:"varint,5,opt,name=subnet,proto3" json:"subnet,omitempty"`
	NetworkIpam               int64 `protobuf:"varint,6,opt,name=network_ipam,json=networkIpam,proto3" json:"network_ipam,omitempty"`
	Virtual_DNSRecord         int64 `protobuf:"varint,7,opt,name=virtual_DNS_record,json=virtualDNSRecord,proto3" json:"virtual_DNS_record,omitempty"`
	LogicalRouter             int64 `protobuf:"varint,8,opt,name=logical_router,json=logicalRouter,proto3" json:"logical_router,omitempty"`
	SecurityGroupRule         int64 `protobuf:"varint,9,opt,name=security_group_rule,json=securityGroupRule,proto3" json:"security_group_rule,omitempty"`
	Virtual_DNS               int64 `protobuf:"varint,10,opt,name=virtual_DNS,json=virtualDNS,proto3" json:"virtual_DNS,omitempty"`
	ServiceInstance           int64 `protobuf:"varint,11,opt,name=service_instance,json=serviceInstance,proto3" json:"service_instance,omitempty"`
	ServiceTemplate           int64 `protobuf:"varint,12,opt,name=service_template,json=serviceTemplate,proto3" json:"service_template,omitempty"`
	BgpRouter                 int64 `protobuf:"varint,13,opt,name=bgp_router,json=bgpRouter,proto3" json:"bgp_router,omitempty"`
	FloatingIp                int64 `protobuf:"varint,14,opt,name=floating_ip,json=floatingIp,proto3" json:"floating_ip,omitempty"`
	FloatingIpPool            int64 `protobuf:"varint,15,opt,name=floating_ip_pool,json=floatingIpPool,proto3" json:"floating_ip_pool,omitempty"`
	LoadbalancerMember        int64 `protobuf:"varint,16,opt,name=loadbalancer_member,json=loadbalancerMember,proto3" json:"loadbalancer_member,omitempty"`
	AccessControlList         int64 `protobuf:"varint,17,opt,name=access_control_list,json=accessControlList,proto3" json:"access_control_list,omitempty"`
	VirtualMachineInterface   int64 `protobuf:"varint,18,opt,name=virtual_machine_interface,json=virtualMachineInterface,proto3" json:"virtual_machine_interface,omitempty"`
	InstanceIp                int64 `protobuf:"varint,19,opt,name=instance_ip,json=instanceIp,proto3" json:"instance_ip,omitempty"`
	GlobalVrouterConfig       int64 `protobuf:"varint,20,opt,name=global_vrouter_config,json=globalVrouterConfig,proto3" json:"global_vrouter_config,omitempty"`
	SecurityLoggingObject     int64 `protobuf:"varint,21,opt,name=security_logging_object,json=securityLoggingObject,proto3" json:"security_logging_object,omitempty"`
	LoadbalancerHealthmonitor int64 `protobuf:"varint,22,opt,name=loadbalancer_healthmonitor,json=loadbalancerHealthmonitor,proto3" json:"loadbalancer_healthmonitor,omitempty"`
	VirtualIp                 int64 `protobuf:"varint,23,opt,name=virtual_ip,json=virtualIp,proto3" json:"virtual_ip,omitempty"`
	Defaults                  int64 `protobuf:"varint,24,opt,name=defaults,proto3" json:"defaults,omitempty"`
	SecurityGroup             int64 `protobuf:"varint,25,opt,name=security_group,json=securityGroup,proto3" json:"security_group,omitempty"`
	VirtualNetwork            int64 `protobuf:"varint,26,opt,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
}

func (m *QuotaType) Reset()                    { *m = QuotaType{} }
func (m *QuotaType) String() string            { return proto.CompactTextString(m) }
func (*QuotaType) ProtoMessage()               {}
func (*QuotaType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{140} }

func (m *QuotaType) GetVirtualRouter() int64 {
	if m != nil {
		return m.VirtualRouter
	}
	return 0
}

func (m *QuotaType) GetNetworkPolicy() int64 {
	if m != nil {
		return m.NetworkPolicy
	}
	return 0
}

func (m *QuotaType) GetLoadbalancerPool() int64 {
	if m != nil {
		return m.LoadbalancerPool
	}
	return 0
}

func (m *QuotaType) GetRouteTable() int64 {
	if m != nil {
		return m.RouteTable
	}
	return 0
}

func (m *QuotaType) GetSubnet() int64 {
	if m != nil {
		return m.Subnet
	}
	return 0
}

func (m *QuotaType) GetNetworkIpam() int64 {
	if m != nil {
		return m.NetworkIpam
	}
	return 0
}

func (m *QuotaType) GetVirtual_DNSRecord() int64 {
	if m != nil {
		return m.Virtual_DNSRecord
	}
	return 0
}

func (m *QuotaType) GetLogicalRouter() int64 {
	if m != nil {
		return m.LogicalRouter
	}
	return 0
}

func (m *QuotaType) GetSecurityGroupRule() int64 {
	if m != nil {
		return m.SecurityGroupRule
	}
	return 0
}

func (m *QuotaType) GetVirtual_DNS() int64 {
	if m != nil {
		return m.Virtual_DNS
	}
	return 0
}

func (m *QuotaType) GetServiceInstance() int64 {
	if m != nil {
		return m.ServiceInstance
	}
	return 0
}

func (m *QuotaType) GetServiceTemplate() int64 {
	if m != nil {
		return m.ServiceTemplate
	}
	return 0
}

func (m *QuotaType) GetBgpRouter() int64 {
	if m != nil {
		return m.BgpRouter
	}
	return 0
}

func (m *QuotaType) GetFloatingIp() int64 {
	if m != nil {
		return m.FloatingIp
	}
	return 0
}

func (m *QuotaType) GetFloatingIpPool() int64 {
	if m != nil {
		return m.FloatingIpPool
	}
	return 0
}

func (m *QuotaType) GetLoadbalancerMember() int64 {
	if m != nil {
		return m.LoadbalancerMember
	}
	return 0
}

func (m *QuotaType) GetAccessControlList() int64 {
	if m != nil {
		return m.AccessControlList
	}
	return 0
}

func (m *QuotaType) GetVirtualMachineInterface() int64 {
	if m != nil {
		return m.VirtualMachineInterface
	}
	return 0
}

func (m *QuotaType) GetInstanceIp() int64 {
	if m != nil {
		return m.InstanceIp
	}
	return 0
}

func (m *QuotaType) GetGlobalVrouterConfig() int64 {
	if m != nil {
		return m.GlobalVrouterConfig
	}
	return 0
}

func (m *QuotaType) GetSecurityLoggingObject() int64 {
	if m != nil {
		return m.SecurityLoggingObject
	}
	return 0
}

func (m *QuotaType) GetLoadbalancerHealthmonitor() int64 {
	if m != nil {
		return m.LoadbalancerHealthmonitor
	}
	return 0
}

func (m *QuotaType) GetVirtualIp() int64 {
	if m != nil {
		return m.VirtualIp
	}
	return 0
}

func (m *QuotaType) GetDefaults() int64 {
	if m != nil {
		return m.Defaults
	}
	return 0
}

func (m *QuotaType) GetSecurityGroup() int64 {
	if m != nil {
		return m.SecurityGroup
	}
	return 0
}

func (m *QuotaType) GetVirtualNetwork() int64 {
	if m != nil {
		return m.VirtualNetwork
	}
	return 0
}

type KeyValuePairs struct {
	KeyValuePair []*KeyValuePair `protobuf:"bytes,1,rep,name=key_value_pair,json=keyValuePair" json:"key_value_pair,omitempty"`
}

func (m *KeyValuePairs) Reset()                    { *m = KeyValuePairs{} }
func (m *KeyValuePairs) String() string            { return proto.CompactTextString(m) }
func (*KeyValuePairs) ProtoMessage()               {}
func (*KeyValuePairs) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{141} }

func (m *KeyValuePairs) GetKeyValuePair() []*KeyValuePair {
	if m != nil {
		return m.KeyValuePair
	}
	return nil
}

type TelemetryStateInfo struct {
	Resource   []*TelemetryResourceInfo `protobuf:"bytes,1,rep,name=resource" json:"resource,omitempty"`
	ServerPort int64                    `protobuf:"varint,2,opt,name=server_port,json=serverPort,proto3" json:"server_port,omitempty"`
	ServerIp   string                   `protobuf:"bytes,3,opt,name=server_ip,json=serverIp,proto3" json:"server_ip,omitempty"`
}

func (m *TelemetryStateInfo) Reset()                    { *m = TelemetryStateInfo{} }
func (m *TelemetryStateInfo) String() string            { return proto.CompactTextString(m) }
func (*TelemetryStateInfo) ProtoMessage()               {}
func (*TelemetryStateInfo) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{142} }

func (m *TelemetryStateInfo) GetResource() []*TelemetryResourceInfo {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *TelemetryStateInfo) GetServerPort() int64 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *TelemetryStateInfo) GetServerIp() string {
	if m != nil {
		return m.ServerIp
	}
	return ""
}

type FirewallRuleMatchTagsType struct {
	TagList []string `protobuf:"bytes,1,rep,name=tag_list,json=tagList" json:"tag_list,omitempty"`
}

func (m *FirewallRuleMatchTagsType) Reset()         { *m = FirewallRuleMatchTagsType{} }
func (m *FirewallRuleMatchTagsType) String() string { return proto.CompactTextString(m) }
func (*FirewallRuleMatchTagsType) ProtoMessage()    {}
func (*FirewallRuleMatchTagsType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{143}
}

func (m *FirewallRuleMatchTagsType) GetTagList() []string {
	if m != nil {
		return m.TagList
	}
	return nil
}

type LinklocalServicesTypes struct {
	LinklocalServiceEntry []*LinklocalServiceEntryType `protobuf:"bytes,1,rep,name=linklocal_service_entry,json=linklocalServiceEntry" json:"linklocal_service_entry,omitempty"`
}

func (m *LinklocalServicesTypes) Reset()                    { *m = LinklocalServicesTypes{} }
func (m *LinklocalServicesTypes) String() string            { return proto.CompactTextString(m) }
func (*LinklocalServicesTypes) ProtoMessage()               {}
func (*LinklocalServicesTypes) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{144} }

func (m *LinklocalServicesTypes) GetLinklocalServiceEntry() []*LinklocalServiceEntryType {
	if m != nil {
		return m.LinklocalServiceEntry
	}
	return nil
}

type RouteTableType struct {
	Route []*RouteType `protobuf:"bytes,1,rep,name=route" json:"route,omitempty"`
}

func (m *RouteTableType) Reset()                    { *m = RouteTableType{} }
func (m *RouteTableType) String() string            { return proto.CompactTextString(m) }
func (*RouteTableType) ProtoMessage()               {}
func (*RouteTableType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{145} }

func (m *RouteTableType) GetRoute() []*RouteType {
	if m != nil {
		return m.Route
	}
	return nil
}

type MacAddressesType struct {
	MacAddress []string `protobuf:"bytes,1,rep,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
}

func (m *MacAddressesType) Reset()                    { *m = MacAddressesType{} }
func (m *MacAddressesType) String() string            { return proto.CompactTextString(m) }
func (*MacAddressesType) ProtoMessage()               {}
func (*MacAddressesType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{146} }

func (m *MacAddressesType) GetMacAddress() []string {
	if m != nil {
		return m.MacAddress
	}
	return nil
}

type VrfAssignRuleType struct {
	RoutingInstance string              `protobuf:"bytes,1,opt,name=routing_instance,json=routingInstance,proto3" json:"routing_instance,omitempty"`
	MatchCondition  *MatchConditionType `protobuf:"bytes,2,opt,name=match_condition,json=matchCondition" json:"match_condition,omitempty"`
	VlanTag         int64               `protobuf:"varint,3,opt,name=vlan_tag,json=vlanTag,proto3" json:"vlan_tag,omitempty"`
	IgnoreAcl       bool                `protobuf:"varint,4,opt,name=ignore_acl,json=ignoreAcl,proto3" json:"ignore_acl,omitempty"`
}

func (m *VrfAssignRuleType) Reset()                    { *m = VrfAssignRuleType{} }
func (m *VrfAssignRuleType) String() string            { return proto.CompactTextString(m) }
func (*VrfAssignRuleType) ProtoMessage()               {}
func (*VrfAssignRuleType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{147} }

func (m *VrfAssignRuleType) GetRoutingInstance() string {
	if m != nil {
		return m.RoutingInstance
	}
	return ""
}

func (m *VrfAssignRuleType) GetMatchCondition() *MatchConditionType {
	if m != nil {
		return m.MatchCondition
	}
	return nil
}

func (m *VrfAssignRuleType) GetVlanTag() int64 {
	if m != nil {
		return m.VlanTag
	}
	return 0
}

func (m *VrfAssignRuleType) GetIgnoreAcl() bool {
	if m != nil {
		return m.IgnoreAcl
	}
	return false
}

type ActionListType struct {
	GatewayName           string            `protobuf:"bytes,1,opt,name=gateway_name,json=gatewayName,proto3" json:"gateway_name,omitempty"`
	Log                   bool              `protobuf:"varint,2,opt,name=log,proto3" json:"log,omitempty"`
	Alert                 bool              `protobuf:"varint,3,opt,name=alert,proto3" json:"alert,omitempty"`
	QosAction             string            `protobuf:"bytes,4,opt,name=qos_action,json=qosAction,proto3" json:"qos_action,omitempty"`
	AssignRoutingInstance string            `protobuf:"bytes,5,opt,name=assign_routing_instance,json=assignRoutingInstance,proto3" json:"assign_routing_instance,omitempty"`
	MirrorTo              *MirrorActionType `protobuf:"bytes,6,opt,name=mirror_to,json=mirrorTo" json:"mirror_to,omitempty"`
	SimpleAction          string            `protobuf:"bytes,7,opt,name=simple_action,json=simpleAction,proto3" json:"simple_action,omitempty"`
	ApplyService          []string          `protobuf:"bytes,8,rep,name=apply_service,json=applyService" json:"apply_service,omitempty"`
}

func (m *ActionListType) Reset()                    { *m = ActionListType{} }
func (m *ActionListType) String() string            { return proto.CompactTextString(m) }
func (*ActionListType) ProtoMessage()               {}
func (*ActionListType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{148} }

func (m *ActionListType) GetGatewayName() string {
	if m != nil {
		return m.GatewayName
	}
	return ""
}

func (m *ActionListType) GetLog() bool {
	if m != nil {
		return m.Log
	}
	return false
}

func (m *ActionListType) GetAlert() bool {
	if m != nil {
		return m.Alert
	}
	return false
}

func (m *ActionListType) GetQosAction() string {
	if m != nil {
		return m.QosAction
	}
	return ""
}

func (m *ActionListType) GetAssignRoutingInstance() string {
	if m != nil {
		return m.AssignRoutingInstance
	}
	return ""
}

func (m *ActionListType) GetMirrorTo() *MirrorActionType {
	if m != nil {
		return m.MirrorTo
	}
	return nil
}

func (m *ActionListType) GetSimpleAction() string {
	if m != nil {
		return m.SimpleAction
	}
	return ""
}

func (m *ActionListType) GetApplyService() []string {
	if m != nil {
		return m.ApplyService
	}
	return nil
}

type AclEntriesType struct {
	Dynamic bool           `protobuf:"varint,1,opt,name=dynamic,proto3" json:"dynamic,omitempty"`
	AclRule []*AclRuleType `protobuf:"bytes,2,rep,name=acl_rule,json=aclRule" json:"acl_rule,omitempty"`
}

func (m *AclEntriesType) Reset()                    { *m = AclEntriesType{} }
func (m *AclEntriesType) String() string            { return proto.CompactTextString(m) }
func (*AclEntriesType) ProtoMessage()               {}
func (*AclEntriesType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{149} }

func (m *AclEntriesType) GetDynamic() bool {
	if m != nil {
		return m.Dynamic
	}
	return false
}

func (m *AclEntriesType) GetAclRule() []*AclRuleType {
	if m != nil {
		return m.AclRule
	}
	return nil
}

type VirtualIpType struct {
	Status                string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	StatusDescription     string `protobuf:"bytes,2,opt,name=status_description,json=statusDescription,proto3" json:"status_description,omitempty"`
	Protocol              string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	SubnetId              string `protobuf:"bytes,4,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	PersistenceCookieName string `protobuf:"bytes,5,opt,name=persistence_cookie_name,json=persistenceCookieName,proto3" json:"persistence_cookie_name,omitempty"`
	ConnectionLimit       int64  `protobuf:"varint,6,opt,name=connection_limit,json=connectionLimit,proto3" json:"connection_limit,omitempty"`
	PersistenceType       string `protobuf:"bytes,7,opt,name=persistence_type,json=persistenceType,proto3" json:"persistence_type,omitempty"`
	AdminState            bool   `protobuf:"varint,8,opt,name=admin_state,json=adminState,proto3" json:"admin_state,omitempty"`
	Address               string `protobuf:"bytes,9,opt,name=address,proto3" json:"address,omitempty"`
	ProtocolPort          int64  `protobuf:"varint,10,opt,name=protocol_port,json=protocolPort,proto3" json:"protocol_port,omitempty"`
}

func (m *VirtualIpType) Reset()                    { *m = VirtualIpType{} }
func (m *VirtualIpType) String() string            { return proto.CompactTextString(m) }
func (*VirtualIpType) ProtoMessage()               {}
func (*VirtualIpType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{150} }

func (m *VirtualIpType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *VirtualIpType) GetStatusDescription() string {
	if m != nil {
		return m.StatusDescription
	}
	return ""
}

func (m *VirtualIpType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *VirtualIpType) GetSubnetId() string {
	if m != nil {
		return m.SubnetId
	}
	return ""
}

func (m *VirtualIpType) GetPersistenceCookieName() string {
	if m != nil {
		return m.PersistenceCookieName
	}
	return ""
}

func (m *VirtualIpType) GetConnectionLimit() int64 {
	if m != nil {
		return m.ConnectionLimit
	}
	return 0
}

func (m *VirtualIpType) GetPersistenceType() string {
	if m != nil {
		return m.PersistenceType
	}
	return ""
}

func (m *VirtualIpType) GetAdminState() bool {
	if m != nil {
		return m.AdminState
	}
	return false
}

func (m *VirtualIpType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *VirtualIpType) GetProtocolPort() int64 {
	if m != nil {
		return m.ProtocolPort
	}
	return 0
}

type RouteType struct {
	Prefix              string               `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	NextHop             string               `protobuf:"bytes,2,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
	CommunityAttributes *CommunityAttributes `protobuf:"bytes,3,opt,name=community_attributes,json=communityAttributes" json:"community_attributes,omitempty"`
	NextHopType         string               `protobuf:"bytes,4,opt,name=next_hop_type,json=nextHopType,proto3" json:"next_hop_type,omitempty"`
}

func (m *RouteType) Reset()                    { *m = RouteType{} }
func (m *RouteType) String() string            { return proto.CompactTextString(m) }
func (*RouteType) ProtoMessage()               {}
func (*RouteType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{151} }

func (m *RouteType) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *RouteType) GetNextHop() string {
	if m != nil {
		return m.NextHop
	}
	return ""
}

func (m *RouteType) GetCommunityAttributes() *CommunityAttributes {
	if m != nil {
		return m.CommunityAttributes
	}
	return nil
}

func (m *RouteType) GetNextHopType() string {
	if m != nil {
		return m.NextHopType
	}
	return ""
}

type LoadbalancerType struct {
	Status             string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	ProvisioningStatus string `protobuf:"bytes,2,opt,name=provisioning_status,json=provisioningStatus,proto3" json:"provisioning_status,omitempty"`
	AdminState         bool   `protobuf:"varint,3,opt,name=admin_state,json=adminState,proto3" json:"admin_state,omitempty"`
	VipAddress         string `protobuf:"bytes,4,opt,name=vip_address,json=vipAddress,proto3" json:"vip_address,omitempty"`
	VipSubnetId        string `protobuf:"bytes,5,opt,name=vip_subnet_id,json=vipSubnetId,proto3" json:"vip_subnet_id,omitempty"`
	OperatingStatus    string `protobuf:"bytes,6,opt,name=operating_status,json=operatingStatus,proto3" json:"operating_status,omitempty"`
}

func (m *LoadbalancerType) Reset()                    { *m = LoadbalancerType{} }
func (m *LoadbalancerType) String() string            { return proto.CompactTextString(m) }
func (*LoadbalancerType) ProtoMessage()               {}
func (*LoadbalancerType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{152} }

func (m *LoadbalancerType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *LoadbalancerType) GetProvisioningStatus() string {
	if m != nil {
		return m.ProvisioningStatus
	}
	return ""
}

func (m *LoadbalancerType) GetAdminState() bool {
	if m != nil {
		return m.AdminState
	}
	return false
}

func (m *LoadbalancerType) GetVipAddress() string {
	if m != nil {
		return m.VipAddress
	}
	return ""
}

func (m *LoadbalancerType) GetVipSubnetId() string {
	if m != nil {
		return m.VipSubnetId
	}
	return ""
}

func (m *LoadbalancerType) GetOperatingStatus() string {
	if m != nil {
		return m.OperatingStatus
	}
	return ""
}

type ProtocolType struct {
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port     int64  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *ProtocolType) Reset()                    { *m = ProtocolType{} }
func (m *ProtocolType) String() string            { return proto.CompactTextString(m) }
func (*ProtocolType) ProtoMessage()               {}
func (*ProtocolType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{153} }

func (m *ProtocolType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ProtocolType) GetPort() int64 {
	if m != nil {
		return m.Port
	}
	return 0
}

type ServiceInstanceType struct {
	RightVirtualNetwork      string                          `protobuf:"bytes,1,opt,name=right_virtual_network,json=rightVirtualNetwork,proto3" json:"right_virtual_network,omitempty"`
	RightIpAddress           string                          `protobuf:"bytes,2,opt,name=right_ip_address,json=rightIpAddress,proto3" json:"right_ip_address,omitempty"`
	AvailabilityZone         string                          `protobuf:"bytes,3,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	ManagementVirtualNetwork string                          `protobuf:"bytes,4,opt,name=management_virtual_network,json=managementVirtualNetwork,proto3" json:"management_virtual_network,omitempty"`
	ScaleOut                 *ServiceScaleOutType            `protobuf:"bytes,5,opt,name=scale_out,json=scaleOut" json:"scale_out,omitempty"`
	HaMode                   string                          `protobuf:"bytes,6,opt,name=ha_mode,json=haMode,proto3" json:"ha_mode,omitempty"`
	VirtualRouterId          string                          `protobuf:"bytes,7,opt,name=virtual_router_id,json=virtualRouterId,proto3" json:"virtual_router_id,omitempty"`
	InterfaceList            []*ServiceInstanceInterfaceType `protobuf:"bytes,8,rep,name=interface_list,json=interfaceList" json:"interface_list,omitempty"`
	LeftIpAddress            string                          `protobuf:"bytes,9,opt,name=left_ip_address,json=leftIpAddress,proto3" json:"left_ip_address,omitempty"`
	LeftVirtualNetwork       string                          `protobuf:"bytes,10,opt,name=left_virtual_network,json=leftVirtualNetwork,proto3" json:"left_virtual_network,omitempty"`
	AutoPolicy               bool                            `protobuf:"varint,11,opt,name=auto_policy,json=autoPolicy,proto3" json:"auto_policy,omitempty"`
}

func (m *ServiceInstanceType) Reset()                    { *m = ServiceInstanceType{} }
func (m *ServiceInstanceType) String() string            { return proto.CompactTextString(m) }
func (*ServiceInstanceType) ProtoMessage()               {}
func (*ServiceInstanceType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{154} }

func (m *ServiceInstanceType) GetRightVirtualNetwork() string {
	if m != nil {
		return m.RightVirtualNetwork
	}
	return ""
}

func (m *ServiceInstanceType) GetRightIpAddress() string {
	if m != nil {
		return m.RightIpAddress
	}
	return ""
}

func (m *ServiceInstanceType) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *ServiceInstanceType) GetManagementVirtualNetwork() string {
	if m != nil {
		return m.ManagementVirtualNetwork
	}
	return ""
}

func (m *ServiceInstanceType) GetScaleOut() *ServiceScaleOutType {
	if m != nil {
		return m.ScaleOut
	}
	return nil
}

func (m *ServiceInstanceType) GetHaMode() string {
	if m != nil {
		return m.HaMode
	}
	return ""
}

func (m *ServiceInstanceType) GetVirtualRouterId() string {
	if m != nil {
		return m.VirtualRouterId
	}
	return ""
}

func (m *ServiceInstanceType) GetInterfaceList() []*ServiceInstanceInterfaceType {
	if m != nil {
		return m.InterfaceList
	}
	return nil
}

func (m *ServiceInstanceType) GetLeftIpAddress() string {
	if m != nil {
		return m.LeftIpAddress
	}
	return ""
}

func (m *ServiceInstanceType) GetLeftVirtualNetwork() string {
	if m != nil {
		return m.LeftVirtualNetwork
	}
	return ""
}

func (m *ServiceInstanceType) GetAutoPolicy() bool {
	if m != nil {
		return m.AutoPolicy
	}
	return false
}

type MatchConditionType struct {
	SrcPort    *PortType    `protobuf:"bytes,1,opt,name=src_port,json=srcPort" json:"src_port,omitempty"`
	SrcAddress *AddressType `protobuf:"bytes,2,opt,name=src_address,json=srcAddress" json:"src_address,omitempty"`
	Ethertype  string       `protobuf:"bytes,3,opt,name=ethertype,proto3" json:"ethertype,omitempty"`
	DstAddress *AddressType `protobuf:"bytes,4,opt,name=dst_address,json=dstAddress" json:"dst_address,omitempty"`
	DstPort    *PortType    `protobuf:"bytes,5,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	Protocol   string       `protobuf:"bytes,6,opt,name=protocol,proto3" json:"protocol,omitempty"`
}

func (m *MatchConditionType) Reset()                    { *m = MatchConditionType{} }
func (m *MatchConditionType) String() string            { return proto.CompactTextString(m) }
func (*MatchConditionType) ProtoMessage()               {}
func (*MatchConditionType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{155} }

func (m *MatchConditionType) GetSrcPort() *PortType {
	if m != nil {
		return m.SrcPort
	}
	return nil
}

func (m *MatchConditionType) GetSrcAddress() *AddressType {
	if m != nil {
		return m.SrcAddress
	}
	return nil
}

func (m *MatchConditionType) GetEthertype() string {
	if m != nil {
		return m.Ethertype
	}
	return ""
}

func (m *MatchConditionType) GetDstAddress() *AddressType {
	if m != nil {
		return m.DstAddress
	}
	return nil
}

func (m *MatchConditionType) GetDstPort() *PortType {
	if m != nil {
		return m.DstPort
	}
	return nil
}

func (m *MatchConditionType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

type LoadbalancerMemberType struct {
	Status            string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	StatusDescription string `protobuf:"bytes,2,opt,name=status_description,json=statusDescription,proto3" json:"status_description,omitempty"`
	Weight            int64  `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	AdminState        bool   `protobuf:"varint,4,opt,name=admin_state,json=adminState,proto3" json:"admin_state,omitempty"`
	Address           string `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	ProtocolPort      int64  `protobuf:"varint,6,opt,name=protocol_port,json=protocolPort,proto3" json:"protocol_port,omitempty"`
}

func (m *LoadbalancerMemberType) Reset()                    { *m = LoadbalancerMemberType{} }
func (m *LoadbalancerMemberType) String() string            { return proto.CompactTextString(m) }
func (*LoadbalancerMemberType) ProtoMessage()               {}
func (*LoadbalancerMemberType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{156} }

func (m *LoadbalancerMemberType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *LoadbalancerMemberType) GetStatusDescription() string {
	if m != nil {
		return m.StatusDescription
	}
	return ""
}

func (m *LoadbalancerMemberType) GetWeight() int64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *LoadbalancerMemberType) GetAdminState() bool {
	if m != nil {
		return m.AdminState
	}
	return false
}

func (m *LoadbalancerMemberType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *LoadbalancerMemberType) GetProtocolPort() int64 {
	if m != nil {
		return m.ProtocolPort
	}
	return 0
}

type UserCredentials struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *UserCredentials) Reset()                    { *m = UserCredentials{} }
func (m *UserCredentials) String() string            { return proto.CompactTextString(m) }
func (*UserCredentials) ProtoMessage()               {}
func (*UserCredentials) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{157} }

func (m *UserCredentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserCredentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type AllowedAddressPairs struct {
	AllowedAddressPair []*AllowedAddressPair `protobuf:"bytes,1,rep,name=allowed_address_pair,json=allowedAddressPair" json:"allowed_address_pair,omitempty"`
}

func (m *AllowedAddressPairs) Reset()                    { *m = AllowedAddressPairs{} }
func (m *AllowedAddressPairs) String() string            { return proto.CompactTextString(m) }
func (*AllowedAddressPairs) ProtoMessage()               {}
func (*AllowedAddressPairs) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{158} }

func (m *AllowedAddressPairs) GetAllowedAddressPair() []*AllowedAddressPair {
	if m != nil {
		return m.AllowedAddressPair
	}
	return nil
}

type TelemetryResourceInfo struct {
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Rate string `protobuf:"bytes,2,opt,name=rate,proto3" json:"rate,omitempty"`
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *TelemetryResourceInfo) Reset()                    { *m = TelemetryResourceInfo{} }
func (m *TelemetryResourceInfo) String() string            { return proto.CompactTextString(m) }
func (*TelemetryResourceInfo) ProtoMessage()               {}
func (*TelemetryResourceInfo) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{159} }

func (m *TelemetryResourceInfo) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *TelemetryResourceInfo) GetRate() string {
	if m != nil {
		return m.Rate
	}
	return ""
}

func (m *TelemetryResourceInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ControlTrafficDscpType struct {
	Control   int64 `protobuf:"varint,1,opt,name=control,proto3" json:"control,omitempty"`
	Analytics int64 `protobuf:"varint,2,opt,name=analytics,proto3" json:"analytics,omitempty"`
	Dns       int64 `protobuf:"varint,3,opt,name=dns,proto3" json:"dns,omitempty"`
}

func (m *ControlTrafficDscpType) Reset()                    { *m = ControlTrafficDscpType{} }
func (m *ControlTrafficDscpType) String() string            { return proto.CompactTextString(m) }
func (*ControlTrafficDscpType) ProtoMessage()               {}
func (*ControlTrafficDscpType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{160} }

func (m *ControlTrafficDscpType) GetControl() int64 {
	if m != nil {
		return m.Control
	}
	return 0
}

func (m *ControlTrafficDscpType) GetAnalytics() int64 {
	if m != nil {
		return m.Analytics
	}
	return 0
}

func (m *ControlTrafficDscpType) GetDns() int64 {
	if m != nil {
		return m.Dns
	}
	return 0
}

type UserDefinedLogStat struct {
	Pattern string `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *UserDefinedLogStat) Reset()                    { *m = UserDefinedLogStat{} }
func (m *UserDefinedLogStat) String() string            { return proto.CompactTextString(m) }
func (*UserDefinedLogStat) ProtoMessage()               {}
func (*UserDefinedLogStat) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{161} }

func (m *UserDefinedLogStat) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *UserDefinedLogStat) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type LoadbalancerPoolType struct {
	Status                string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Protocol              string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	SubnetId              string `protobuf:"bytes,3,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	SessionPersistence    string `protobuf:"bytes,4,opt,name=session_persistence,json=sessionPersistence,proto3" json:"session_persistence,omitempty"`
	AdminState            bool   `protobuf:"varint,5,opt,name=admin_state,json=adminState,proto3" json:"admin_state,omitempty"`
	PersistenceCookieName string `protobuf:"bytes,6,opt,name=persistence_cookie_name,json=persistenceCookieName,proto3" json:"persistence_cookie_name,omitempty"`
	StatusDescription     string `protobuf:"bytes,7,opt,name=status_description,json=statusDescription,proto3" json:"status_description,omitempty"`
	LoadbalancerMethod    string `protobuf:"bytes,8,opt,name=loadbalancer_method,json=loadbalancerMethod,proto3" json:"loadbalancer_method,omitempty"`
}

func (m *LoadbalancerPoolType) Reset()                    { *m = LoadbalancerPoolType{} }
func (m *LoadbalancerPoolType) String() string            { return proto.CompactTextString(m) }
func (*LoadbalancerPoolType) ProtoMessage()               {}
func (*LoadbalancerPoolType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{162} }

func (m *LoadbalancerPoolType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *LoadbalancerPoolType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *LoadbalancerPoolType) GetSubnetId() string {
	if m != nil {
		return m.SubnetId
	}
	return ""
}

func (m *LoadbalancerPoolType) GetSessionPersistence() string {
	if m != nil {
		return m.SessionPersistence
	}
	return ""
}

func (m *LoadbalancerPoolType) GetAdminState() bool {
	if m != nil {
		return m.AdminState
	}
	return false
}

func (m *LoadbalancerPoolType) GetPersistenceCookieName() string {
	if m != nil {
		return m.PersistenceCookieName
	}
	return ""
}

func (m *LoadbalancerPoolType) GetStatusDescription() string {
	if m != nil {
		return m.StatusDescription
	}
	return ""
}

func (m *LoadbalancerPoolType) GetLoadbalancerMethod() string {
	if m != nil {
		return m.LoadbalancerMethod
	}
	return ""
}

type KeyValuePair struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Key   string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *KeyValuePair) Reset()                    { *m = KeyValuePair{} }
func (m *KeyValuePair) String() string            { return proto.CompactTextString(m) }
func (*KeyValuePair) ProtoMessage()               {}
func (*KeyValuePair) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{163} }

func (m *KeyValuePair) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *KeyValuePair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type IpamSubnets struct {
	Subnets []*IpamSubnetType `protobuf:"bytes,1,rep,name=subnets" json:"subnets,omitempty"`
}

func (m *IpamSubnets) Reset()                    { *m = IpamSubnets{} }
func (m *IpamSubnets) String() string            { return proto.CompactTextString(m) }
func (*IpamSubnets) ProtoMessage()               {}
func (*IpamSubnets) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{164} }

func (m *IpamSubnets) GetSubnets() []*IpamSubnetType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

type LoadbalancerListenerType struct {
	DefaultTlsContainer string   `protobuf:"bytes,1,opt,name=default_tls_container,json=defaultTlsContainer,proto3" json:"default_tls_container,omitempty"`
	Protocol            string   `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	ConnectionLimit     int64    `protobuf:"varint,3,opt,name=connection_limit,json=connectionLimit,proto3" json:"connection_limit,omitempty"`
	AdminState          bool     `protobuf:"varint,4,opt,name=admin_state,json=adminState,proto3" json:"admin_state,omitempty"`
	SniContainers       []string `protobuf:"bytes,5,rep,name=sni_containers,json=sniContainers" json:"sni_containers,omitempty"`
	ProtocolPort        int64    `protobuf:"varint,6,opt,name=protocol_port,json=protocolPort,proto3" json:"protocol_port,omitempty"`
}

func (m *LoadbalancerListenerType) Reset()         { *m = LoadbalancerListenerType{} }
func (m *LoadbalancerListenerType) String() string { return proto.CompactTextString(m) }
func (*LoadbalancerListenerType) ProtoMessage()    {}
func (*LoadbalancerListenerType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{165}
}

func (m *LoadbalancerListenerType) GetDefaultTlsContainer() string {
	if m != nil {
		return m.DefaultTlsContainer
	}
	return ""
}

func (m *LoadbalancerListenerType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *LoadbalancerListenerType) GetConnectionLimit() int64 {
	if m != nil {
		return m.ConnectionLimit
	}
	return 0
}

func (m *LoadbalancerListenerType) GetAdminState() bool {
	if m != nil {
		return m.AdminState
	}
	return false
}

func (m *LoadbalancerListenerType) GetSniContainers() []string {
	if m != nil {
		return m.SniContainers
	}
	return nil
}

func (m *LoadbalancerListenerType) GetProtocolPort() int64 {
	if m != nil {
		return m.ProtocolPort
	}
	return 0
}

type BridgeDomainMembershipType struct {
	VlanTag int64 `protobuf:"varint,1,opt,name=vlan_tag,json=vlanTag,proto3" json:"vlan_tag,omitempty"`
}

func (m *BridgeDomainMembershipType) Reset()         { *m = BridgeDomainMembershipType{} }
func (m *BridgeDomainMembershipType) String() string { return proto.CompactTextString(m) }
func (*BridgeDomainMembershipType) ProtoMessage()    {}
func (*BridgeDomainMembershipType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{166}
}

func (m *BridgeDomainMembershipType) GetVlanTag() int64 {
	if m != nil {
		return m.VlanTag
	}
	return 0
}

type VnSubnetsType struct {
	IpamSubnets []*IpamSubnetType `protobuf:"bytes,1,rep,name=ipam_subnets,json=ipamSubnets" json:"ipam_subnets,omitempty"`
	HostRoutes  *RouteTableType   `protobuf:"bytes,2,opt,name=host_routes,json=hostRoutes" json:"host_routes,omitempty"`
}

func (m *VnSubnetsType) Reset()                    { *m = VnSubnetsType{} }
func (m *VnSubnetsType) String() string            { return proto.CompactTextString(m) }
func (*VnSubnetsType) ProtoMessage()               {}
func (*VnSubnetsType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{167} }

func (m *VnSubnetsType) GetIpamSubnets() []*IpamSubnetType {
	if m != nil {
		return m.IpamSubnets
	}
	return nil
}

func (m *VnSubnetsType) GetHostRoutes() *RouteTableType {
	if m != nil {
		return m.HostRoutes
	}
	return nil
}

type ServiceApplianceInterfaceType struct {
	InterfaceType string `protobuf:"bytes,1,opt,name=interface_type,json=interfaceType,proto3" json:"interface_type,omitempty"`
}

func (m *ServiceApplianceInterfaceType) Reset()         { *m = ServiceApplianceInterfaceType{} }
func (m *ServiceApplianceInterfaceType) String() string { return proto.CompactTextString(m) }
func (*ServiceApplianceInterfaceType) ProtoMessage()    {}
func (*ServiceApplianceInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{168}
}

func (m *ServiceApplianceInterfaceType) GetInterfaceType() string {
	if m != nil {
		return m.InterfaceType
	}
	return ""
}

type SubnetListType struct {
	Subnet []*SubnetType `protobuf:"bytes,1,rep,name=subnet" json:"subnet,omitempty"`
}

func (m *SubnetListType) Reset()                    { *m = SubnetListType{} }
func (m *SubnetListType) String() string            { return proto.CompactTextString(m) }
func (*SubnetListType) ProtoMessage()               {}
func (*SubnetListType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{169} }

func (m *SubnetListType) GetSubnet() []*SubnetType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

type BGPaaServiceParametersType struct {
	PortStart int64 `protobuf:"varint,1,opt,name=port_start,json=portStart,proto3" json:"port_start,omitempty"`
	PortEnd   int64 `protobuf:"varint,2,opt,name=port_end,json=portEnd,proto3" json:"port_end,omitempty"`
}

func (m *BGPaaServiceParametersType) Reset()         { *m = BGPaaServiceParametersType{} }
func (m *BGPaaServiceParametersType) String() string { return proto.CompactTextString(m) }
func (*BGPaaServiceParametersType) ProtoMessage()    {}
func (*BGPaaServiceParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{170}
}

func (m *BGPaaServiceParametersType) GetPortStart() int64 {
	if m != nil {
		return m.PortStart
	}
	return 0
}

func (m *BGPaaServiceParametersType) GetPortEnd() int64 {
	if m != nil {
		return m.PortEnd
	}
	return 0
}

type IpamDnsAddressType struct {
	TenantDnsServerAddress *IpAddressesType `protobuf:"bytes,1,opt,name=tenant_dns_server_address,json=tenantDnsServerAddress" json:"tenant_dns_server_address,omitempty"`
	VirtualDnsServerName   string           `protobuf:"bytes,2,opt,name=virtual_dns_server_name,json=virtualDnsServerName,proto3" json:"virtual_dns_server_name,omitempty"`
}

func (m *IpamDnsAddressType) Reset()                    { *m = IpamDnsAddressType{} }
func (m *IpamDnsAddressType) String() string            { return proto.CompactTextString(m) }
func (*IpamDnsAddressType) ProtoMessage()               {}
func (*IpamDnsAddressType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{171} }

func (m *IpamDnsAddressType) GetTenantDnsServerAddress() *IpAddressesType {
	if m != nil {
		return m.TenantDnsServerAddress
	}
	return nil
}

func (m *IpamDnsAddressType) GetVirtualDnsServerName() string {
	if m != nil {
		return m.VirtualDnsServerName
	}
	return ""
}

type DhcpOptionsListType struct {
	DhcpOption []*DhcpOptionType `protobuf:"bytes,1,rep,name=dhcp_option,json=dhcpOption" json:"dhcp_option,omitempty"`
}

func (m *DhcpOptionsListType) Reset()                    { *m = DhcpOptionsListType{} }
func (m *DhcpOptionsListType) String() string            { return proto.CompactTextString(m) }
func (*DhcpOptionsListType) ProtoMessage()               {}
func (*DhcpOptionsListType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{172} }

func (m *DhcpOptionsListType) GetDhcpOption() []*DhcpOptionType {
	if m != nil {
		return m.DhcpOption
	}
	return nil
}

type MACLimitControlType struct {
	MacLimit       int64  `protobuf:"varint,1,opt,name=mac_limit,json=macLimit,proto3" json:"mac_limit,omitempty"`
	MacLimitAction string `protobuf:"bytes,2,opt,name=mac_limit_action,json=macLimitAction,proto3" json:"mac_limit_action,omitempty"`
}

func (m *MACLimitControlType) Reset()                    { *m = MACLimitControlType{} }
func (m *MACLimitControlType) String() string            { return proto.CompactTextString(m) }
func (*MACLimitControlType) ProtoMessage()               {}
func (*MACLimitControlType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{173} }

func (m *MACLimitControlType) GetMacLimit() int64 {
	if m != nil {
		return m.MacLimit
	}
	return 0
}

func (m *MACLimitControlType) GetMacLimitAction() string {
	if m != nil {
		return m.MacLimitAction
	}
	return ""
}

type UserDefinedLogStatList struct {
	Statlist []*UserDefinedLogStat `protobuf:"bytes,1,rep,name=statlist" json:"statlist,omitempty"`
}

func (m *UserDefinedLogStatList) Reset()                    { *m = UserDefinedLogStatList{} }
func (m *UserDefinedLogStatList) String() string            { return proto.CompactTextString(m) }
func (*UserDefinedLogStatList) ProtoMessage()               {}
func (*UserDefinedLogStatList) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{174} }

func (m *UserDefinedLogStatList) GetStatlist() []*UserDefinedLogStat {
	if m != nil {
		return m.Statlist
	}
	return nil
}

type EcmpHashingIncludeFields struct {
	DestinationIp     bool `protobuf:"varint,1,opt,name=destination_ip,json=destinationIp,proto3" json:"destination_ip,omitempty"`
	IpProtocol        bool `protobuf:"varint,2,opt,name=ip_protocol,json=ipProtocol,proto3" json:"ip_protocol,omitempty"`
	SourceIp          bool `protobuf:"varint,3,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	HashingConfigured bool `protobuf:"varint,4,opt,name=hashing_configured,json=hashingConfigured,proto3" json:"hashing_configured,omitempty"`
	SourcePort        bool `protobuf:"varint,5,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	DestinationPort   bool `protobuf:"varint,6,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
}

func (m *EcmpHashingIncludeFields) Reset()         { *m = EcmpHashingIncludeFields{} }
func (m *EcmpHashingIncludeFields) String() string { return proto.CompactTextString(m) }
func (*EcmpHashingIncludeFields) ProtoMessage()    {}
func (*EcmpHashingIncludeFields) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{175}
}

func (m *EcmpHashingIncludeFields) GetDestinationIp() bool {
	if m != nil {
		return m.DestinationIp
	}
	return false
}

func (m *EcmpHashingIncludeFields) GetIpProtocol() bool {
	if m != nil {
		return m.IpProtocol
	}
	return false
}

func (m *EcmpHashingIncludeFields) GetSourceIp() bool {
	if m != nil {
		return m.SourceIp
	}
	return false
}

func (m *EcmpHashingIncludeFields) GetHashingConfigured() bool {
	if m != nil {
		return m.HashingConfigured
	}
	return false
}

func (m *EcmpHashingIncludeFields) GetSourcePort() bool {
	if m != nil {
		return m.SourcePort
	}
	return false
}

func (m *EcmpHashingIncludeFields) GetDestinationPort() bool {
	if m != nil {
		return m.DestinationPort
	}
	return false
}

type EncapsulationPrioritiesType struct {
	Encapsulation [][]byte `protobuf:"bytes,1,rep,name=encapsulation" json:"encapsulation,omitempty"`
}

func (m *EncapsulationPrioritiesType) Reset()         { *m = EncapsulationPrioritiesType{} }
func (m *EncapsulationPrioritiesType) String() string { return proto.CompactTextString(m) }
func (*EncapsulationPrioritiesType) ProtoMessage()    {}
func (*EncapsulationPrioritiesType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{176}
}

func (m *EncapsulationPrioritiesType) GetEncapsulation() [][]byte {
	if m != nil {
		return m.Encapsulation
	}
	return nil
}

type VirtualRouterNetworkIpamType struct {
	Subnet          []*SubnetType         `protobuf:"bytes,1,rep,name=subnet" json:"subnet,omitempty"`
	AllocationPools []*AllocationPoolType `protobuf:"bytes,2,rep,name=allocation_pools,json=allocationPools" json:"allocation_pools,omitempty"`
}

func (m *VirtualRouterNetworkIpamType) Reset()         { *m = VirtualRouterNetworkIpamType{} }
func (m *VirtualRouterNetworkIpamType) String() string { return proto.CompactTextString(m) }
func (*VirtualRouterNetworkIpamType) ProtoMessage()    {}
func (*VirtualRouterNetworkIpamType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{177}
}

func (m *VirtualRouterNetworkIpamType) GetSubnet() []*SubnetType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *VirtualRouterNetworkIpamType) GetAllocationPools() []*AllocationPoolType {
	if m != nil {
		return m.AllocationPools
	}
	return nil
}

type VirtualDnsType struct {
	FloatingIpRecord         string `protobuf:"bytes,1,opt,name=floating_ip_record,json=floatingIpRecord,proto3" json:"floating_ip_record,omitempty"`
	DomainName               string `protobuf:"bytes,2,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
	ExternalVisible          bool   `protobuf:"varint,3,opt,name=external_visible,json=externalVisible,proto3" json:"external_visible,omitempty"`
	NextVirtual_DNS          string `protobuf:"bytes,4,opt,name=next_virtual_DNS,json=nextVirtualDNS,proto3" json:"next_virtual_DNS,omitempty"`
	DynamicRecordsFromClient bool   `protobuf:"varint,5,opt,name=dynamic_records_from_client,json=dynamicRecordsFromClient,proto3" json:"dynamic_records_from_client,omitempty"`
	ReverseResolution        bool   `protobuf:"varint,6,opt,name=reverse_resolution,json=reverseResolution,proto3" json:"reverse_resolution,omitempty"`
	DefaultTtlSeconds        int64  `protobuf:"varint,7,opt,name=default_ttl_seconds,json=defaultTtlSeconds,proto3" json:"default_ttl_seconds,omitempty"`
	RecordOrder              string `protobuf:"bytes,8,opt,name=record_order,json=recordOrder,proto3" json:"record_order,omitempty"`
}

func (m *VirtualDnsType) Reset()                    { *m = VirtualDnsType{} }
func (m *VirtualDnsType) String() string            { return proto.CompactTextString(m) }
func (*VirtualDnsType) ProtoMessage()               {}
func (*VirtualDnsType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{178} }

func (m *VirtualDnsType) GetFloatingIpRecord() string {
	if m != nil {
		return m.FloatingIpRecord
	}
	return ""
}

func (m *VirtualDnsType) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

func (m *VirtualDnsType) GetExternalVisible() bool {
	if m != nil {
		return m.ExternalVisible
	}
	return false
}

func (m *VirtualDnsType) GetNextVirtual_DNS() string {
	if m != nil {
		return m.NextVirtual_DNS
	}
	return ""
}

func (m *VirtualDnsType) GetDynamicRecordsFromClient() bool {
	if m != nil {
		return m.DynamicRecordsFromClient
	}
	return false
}

func (m *VirtualDnsType) GetReverseResolution() bool {
	if m != nil {
		return m.ReverseResolution
	}
	return false
}

func (m *VirtualDnsType) GetDefaultTtlSeconds() int64 {
	if m != nil {
		return m.DefaultTtlSeconds
	}
	return 0
}

func (m *VirtualDnsType) GetRecordOrder() string {
	if m != nil {
		return m.RecordOrder
	}
	return ""
}

type FirewallSequence struct {
	Sequence string `protobuf:"bytes,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
}

func (m *FirewallSequence) Reset()                    { *m = FirewallSequence{} }
func (m *FirewallSequence) String() string            { return proto.CompactTextString(m) }
func (*FirewallSequence) ProtoMessage()               {}
func (*FirewallSequence) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{179} }

func (m *FirewallSequence) GetSequence() string {
	if m != nil {
		return m.Sequence
	}
	return ""
}

type MirrorActionType struct {
	NicAssistedMirroringVlan int64               `protobuf:"varint,1,opt,name=nic_assisted_mirroring_vlan,json=nicAssistedMirroringVlan,proto3" json:"nic_assisted_mirroring_vlan,omitempty"`
	AnalyzerName             string              `protobuf:"bytes,2,opt,name=analyzer_name,json=analyzerName,proto3" json:"analyzer_name,omitempty"`
	NhMode                   string              `protobuf:"bytes,3,opt,name=nh_mode,json=nhMode,proto3" json:"nh_mode,omitempty"`
	JuniperHeader            bool                `protobuf:"varint,4,opt,name=juniper_header,json=juniperHeader,proto3" json:"juniper_header,omitempty"`
	UdpPort                  int64               `protobuf:"varint,5,opt,name=udp_port,json=udpPort,proto3" json:"udp_port,omitempty"`
	RoutingInstance          string              `protobuf:"bytes,6,opt,name=routing_instance,json=routingInstance,proto3" json:"routing_instance,omitempty"`
	StaticNhHeader           *StaticMirrorNhType `protobuf:"bytes,7,opt,name=static_nh_header,json=staticNhHeader" json:"static_nh_header,omitempty"`
	AnalyzerIpAddress        string              `protobuf:"bytes,8,opt,name=analyzer_ip_address,json=analyzerIpAddress,proto3" json:"analyzer_ip_address,omitempty"`
	Encapsulation            string              `protobuf:"bytes,9,opt,name=encapsulation,proto3" json:"encapsulation,omitempty"`
	AnalyzerMacAddress       string              `protobuf:"bytes,10,opt,name=analyzer_mac_address,json=analyzerMacAddress,proto3" json:"analyzer_mac_address,omitempty"`
	NicAssistedMirroring     bool                `protobuf:"varint,11,opt,name=nic_assisted_mirroring,json=nicAssistedMirroring,proto3" json:"nic_assisted_mirroring,omitempty"`
}

func (m *MirrorActionType) Reset()                    { *m = MirrorActionType{} }
func (m *MirrorActionType) String() string            { return proto.CompactTextString(m) }
func (*MirrorActionType) ProtoMessage()               {}
func (*MirrorActionType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{180} }

func (m *MirrorActionType) GetNicAssistedMirroringVlan() int64 {
	if m != nil {
		return m.NicAssistedMirroringVlan
	}
	return 0
}

func (m *MirrorActionType) GetAnalyzerName() string {
	if m != nil {
		return m.AnalyzerName
	}
	return ""
}

func (m *MirrorActionType) GetNhMode() string {
	if m != nil {
		return m.NhMode
	}
	return ""
}

func (m *MirrorActionType) GetJuniperHeader() bool {
	if m != nil {
		return m.JuniperHeader
	}
	return false
}

func (m *MirrorActionType) GetUdpPort() int64 {
	if m != nil {
		return m.UdpPort
	}
	return 0
}

func (m *MirrorActionType) GetRoutingInstance() string {
	if m != nil {
		return m.RoutingInstance
	}
	return ""
}

func (m *MirrorActionType) GetStaticNhHeader() *StaticMirrorNhType {
	if m != nil {
		return m.StaticNhHeader
	}
	return nil
}

func (m *MirrorActionType) GetAnalyzerIpAddress() string {
	if m != nil {
		return m.AnalyzerIpAddress
	}
	return ""
}

func (m *MirrorActionType) GetEncapsulation() string {
	if m != nil {
		return m.Encapsulation
	}
	return ""
}

func (m *MirrorActionType) GetAnalyzerMacAddress() string {
	if m != nil {
		return m.AnalyzerMacAddress
	}
	return ""
}

func (m *MirrorActionType) GetNicAssistedMirroring() bool {
	if m != nil {
		return m.NicAssistedMirroring
	}
	return false
}

type IpamType struct {
	IpamMethod     string               `protobuf:"bytes,1,opt,name=ipam_method,json=ipamMethod,proto3" json:"ipam_method,omitempty"`
	IpamDnsMethod  string               `protobuf:"bytes,2,opt,name=ipam_dns_method,json=ipamDnsMethod,proto3" json:"ipam_dns_method,omitempty"`
	IpamDnsServer  *IpamDnsAddressType  `protobuf:"bytes,3,opt,name=ipam_dns_server,json=ipamDnsServer" json:"ipam_dns_server,omitempty"`
	DhcpOptionList *DhcpOptionsListType `protobuf:"bytes,4,opt,name=dhcp_option_list,json=dhcpOptionList" json:"dhcp_option_list,omitempty"`
	HostRoutes     *RouteTableType      `protobuf:"bytes,5,opt,name=host_routes,json=hostRoutes" json:"host_routes,omitempty"`
	CidrBlock      *SubnetType          `protobuf:"bytes,6,opt,name=cidr_block,json=cidrBlock" json:"cidr_block,omitempty"`
}

func (m *IpamType) Reset()                    { *m = IpamType{} }
func (m *IpamType) String() string            { return proto.CompactTextString(m) }
func (*IpamType) ProtoMessage()               {}
func (*IpamType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{181} }

func (m *IpamType) GetIpamMethod() string {
	if m != nil {
		return m.IpamMethod
	}
	return ""
}

func (m *IpamType) GetIpamDnsMethod() string {
	if m != nil {
		return m.IpamDnsMethod
	}
	return ""
}

func (m *IpamType) GetIpamDnsServer() *IpamDnsAddressType {
	if m != nil {
		return m.IpamDnsServer
	}
	return nil
}

func (m *IpamType) GetDhcpOptionList() *DhcpOptionsListType {
	if m != nil {
		return m.DhcpOptionList
	}
	return nil
}

func (m *IpamType) GetHostRoutes() *RouteTableType {
	if m != nil {
		return m.HostRoutes
	}
	return nil
}

func (m *IpamType) GetCidrBlock() *SubnetType {
	if m != nil {
		return m.CidrBlock
	}
	return nil
}

type JunosServicePorts struct {
	ServicePort []string `protobuf:"bytes,1,rep,name=service_port,json=servicePort" json:"service_port,omitempty"`
}

func (m *JunosServicePorts) Reset()                    { *m = JunosServicePorts{} }
func (m *JunosServicePorts) String() string            { return proto.CompactTextString(m) }
func (*JunosServicePorts) ProtoMessage()               {}
func (*JunosServicePorts) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{182} }

func (m *JunosServicePorts) GetServicePort() []string {
	if m != nil {
		return m.ServicePort
	}
	return nil
}

type AlarmOperand2 struct {
	UveAttribute string `protobuf:"bytes,1,opt,name=uve_attribute,json=uveAttribute,proto3" json:"uve_attribute,omitempty"`
	JsonValue    string `protobuf:"bytes,2,opt,name=json_value,json=jsonValue,proto3" json:"json_value,omitempty"`
}

func (m *AlarmOperand2) Reset()                    { *m = AlarmOperand2{} }
func (m *AlarmOperand2) String() string            { return proto.CompactTextString(m) }
func (*AlarmOperand2) ProtoMessage()               {}
func (*AlarmOperand2) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{183} }

func (m *AlarmOperand2) GetUveAttribute() string {
	if m != nil {
		return m.UveAttribute
	}
	return ""
}

func (m *AlarmOperand2) GetJsonValue() string {
	if m != nil {
		return m.JsonValue
	}
	return ""
}

type RbacRuleType struct {
	RuleObject string          `protobuf:"bytes,1,opt,name=rule_object,json=ruleObject,proto3" json:"rule_object,omitempty"`
	RulePerms  []*RbacPermType `protobuf:"bytes,2,rep,name=rule_perms,json=rulePerms" json:"rule_perms,omitempty"`
	RuleField  string          `protobuf:"bytes,3,opt,name=rule_field,json=ruleField,proto3" json:"rule_field,omitempty"`
}

func (m *RbacRuleType) Reset()                    { *m = RbacRuleType{} }
func (m *RbacRuleType) String() string            { return proto.CompactTextString(m) }
func (*RbacRuleType) ProtoMessage()               {}
func (*RbacRuleType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{184} }

func (m *RbacRuleType) GetRuleObject() string {
	if m != nil {
		return m.RuleObject
	}
	return ""
}

func (m *RbacRuleType) GetRulePerms() []*RbacPermType {
	if m != nil {
		return m.RulePerms
	}
	return nil
}

func (m *RbacRuleType) GetRuleField() string {
	if m != nil {
		return m.RuleField
	}
	return ""
}

type DomainLimitsType struct {
	ProjectLimit        int64 `protobuf:"varint,1,opt,name=project_limit,json=projectLimit,proto3" json:"project_limit,omitempty"`
	VirtualNetworkLimit int64 `protobuf:"varint,2,opt,name=virtual_network_limit,json=virtualNetworkLimit,proto3" json:"virtual_network_limit,omitempty"`
	SecurityGroupLimit  int64 `protobuf:"varint,3,opt,name=security_group_limit,json=securityGroupLimit,proto3" json:"security_group_limit,omitempty"`
}

func (m *DomainLimitsType) Reset()                    { *m = DomainLimitsType{} }
func (m *DomainLimitsType) String() string            { return proto.CompactTextString(m) }
func (*DomainLimitsType) ProtoMessage()               {}
func (*DomainLimitsType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{185} }

func (m *DomainLimitsType) GetProjectLimit() int64 {
	if m != nil {
		return m.ProjectLimit
	}
	return 0
}

func (m *DomainLimitsType) GetVirtualNetworkLimit() int64 {
	if m != nil {
		return m.VirtualNetworkLimit
	}
	return 0
}

func (m *DomainLimitsType) GetSecurityGroupLimit() int64 {
	if m != nil {
		return m.SecurityGroupLimit
	}
	return 0
}

type PolicyEntriesType struct {
	PolicyRule []*PolicyRuleType `protobuf:"bytes,1,rep,name=policy_rule,json=policyRule" json:"policy_rule,omitempty"`
}

func (m *PolicyEntriesType) Reset()                    { *m = PolicyEntriesType{} }
func (m *PolicyEntriesType) String() string            { return proto.CompactTextString(m) }
func (*PolicyEntriesType) ProtoMessage()               {}
func (*PolicyEntriesType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{186} }

func (m *PolicyEntriesType) GetPolicyRule() []*PolicyRuleType {
	if m != nil {
		return m.PolicyRule
	}
	return nil
}

type ServiceHealthCheckType struct {
	DelayUsecs      int64  `protobuf:"varint,1,opt,name=delayUsecs,proto3" json:"delayUsecs,omitempty"`
	TimeoutUsecs    int64  `protobuf:"varint,2,opt,name=timeoutUsecs,proto3" json:"timeoutUsecs,omitempty"`
	Enabled         bool   `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Delay           int64  `protobuf:"varint,4,opt,name=delay,proto3" json:"delay,omitempty"`
	ExpectedCodes   string `protobuf:"bytes,5,opt,name=expected_codes,json=expectedCodes,proto3" json:"expected_codes,omitempty"`
	MaxRetries      int64  `protobuf:"varint,6,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	HealthCheckType string `protobuf:"bytes,7,opt,name=health_check_type,json=healthCheckType,proto3" json:"health_check_type,omitempty"`
	HttpMethod      string `protobuf:"bytes,8,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	Timeout         int64  `protobuf:"varint,9,opt,name=timeout,proto3" json:"timeout,omitempty"`
	UrlPath         string `protobuf:"bytes,10,opt,name=url_path,json=urlPath,proto3" json:"url_path,omitempty"`
	MonitorType     string `protobuf:"bytes,11,opt,name=monitor_type,json=monitorType,proto3" json:"monitor_type,omitempty"`
}

func (m *ServiceHealthCheckType) Reset()                    { *m = ServiceHealthCheckType{} }
func (m *ServiceHealthCheckType) String() string            { return proto.CompactTextString(m) }
func (*ServiceHealthCheckType) ProtoMessage()               {}
func (*ServiceHealthCheckType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{187} }

func (m *ServiceHealthCheckType) GetDelayUsecs() int64 {
	if m != nil {
		return m.DelayUsecs
	}
	return 0
}

func (m *ServiceHealthCheckType) GetTimeoutUsecs() int64 {
	if m != nil {
		return m.TimeoutUsecs
	}
	return 0
}

func (m *ServiceHealthCheckType) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *ServiceHealthCheckType) GetDelay() int64 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *ServiceHealthCheckType) GetExpectedCodes() string {
	if m != nil {
		return m.ExpectedCodes
	}
	return ""
}

func (m *ServiceHealthCheckType) GetMaxRetries() int64 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

func (m *ServiceHealthCheckType) GetHealthCheckType() string {
	if m != nil {
		return m.HealthCheckType
	}
	return ""
}

func (m *ServiceHealthCheckType) GetHttpMethod() string {
	if m != nil {
		return m.HttpMethod
	}
	return ""
}

func (m *ServiceHealthCheckType) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *ServiceHealthCheckType) GetUrlPath() string {
	if m != nil {
		return m.UrlPath
	}
	return ""
}

func (m *ServiceHealthCheckType) GetMonitorType() string {
	if m != nil {
		return m.MonitorType
	}
	return ""
}

type AddressType struct {
	SecurityGroup  string        `protobuf:"bytes,1,opt,name=security_group,json=securityGroup,proto3" json:"security_group,omitempty"`
	Subnet         *SubnetType   `protobuf:"bytes,2,opt,name=subnet" json:"subnet,omitempty"`
	NetworkPolicy  string        `protobuf:"bytes,3,opt,name=network_policy,json=networkPolicy,proto3" json:"network_policy,omitempty"`
	SubnetList     []*SubnetType `protobuf:"bytes,4,rep,name=subnet_list,json=subnetList" json:"subnet_list,omitempty"`
	VirtualNetwork string        `protobuf:"bytes,5,opt,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
}

func (m *AddressType) Reset()                    { *m = AddressType{} }
func (m *AddressType) String() string            { return proto.CompactTextString(m) }
func (*AddressType) ProtoMessage()               {}
func (*AddressType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{188} }

func (m *AddressType) GetSecurityGroup() string {
	if m != nil {
		return m.SecurityGroup
	}
	return ""
}

func (m *AddressType) GetSubnet() *SubnetType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *AddressType) GetNetworkPolicy() string {
	if m != nil {
		return m.NetworkPolicy
	}
	return ""
}

func (m *AddressType) GetSubnetList() []*SubnetType {
	if m != nil {
		return m.SubnetList
	}
	return nil
}

func (m *AddressType) GetVirtualNetwork() string {
	if m != nil {
		return m.VirtualNetwork
	}
	return ""
}

type FlowAgingTimeout struct {
	TimeoutInSeconds int64  `protobuf:"varint,1,opt,name=timeout_in_seconds,json=timeoutInSeconds,proto3" json:"timeout_in_seconds,omitempty"`
	Protocol         string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port             int64  `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *FlowAgingTimeout) Reset()                    { *m = FlowAgingTimeout{} }
func (m *FlowAgingTimeout) String() string            { return proto.CompactTextString(m) }
func (*FlowAgingTimeout) ProtoMessage()               {}
func (*FlowAgingTimeout) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{189} }

func (m *FlowAgingTimeout) GetTimeoutInSeconds() int64 {
	if m != nil {
		return m.TimeoutInSeconds
	}
	return 0
}

func (m *FlowAgingTimeout) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *FlowAgingTimeout) GetPort() int64 {
	if m != nil {
		return m.Port
	}
	return 0
}

type QosIdForwardingClassPair struct {
	Key               int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	ForwardingClassId int64 `protobuf:"varint,2,opt,name=forwarding_class_id,json=forwardingClassId,proto3" json:"forwarding_class_id,omitempty"`
}

func (m *QosIdForwardingClassPair) Reset()         { *m = QosIdForwardingClassPair{} }
func (m *QosIdForwardingClassPair) String() string { return proto.CompactTextString(m) }
func (*QosIdForwardingClassPair) ProtoMessage()    {}
func (*QosIdForwardingClassPair) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{190}
}

func (m *QosIdForwardingClassPair) GetKey() int64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *QosIdForwardingClassPair) GetForwardingClassId() int64 {
	if m != nil {
		return m.ForwardingClassId
	}
	return 0
}

type RbacRuleEntriesType struct {
	RbacRule []*RbacRuleType `protobuf:"bytes,1,rep,name=rbac_rule,json=rbacRule" json:"rbac_rule,omitempty"`
}

func (m *RbacRuleEntriesType) Reset()                    { *m = RbacRuleEntriesType{} }
func (m *RbacRuleEntriesType) String() string            { return proto.CompactTextString(m) }
func (*RbacRuleEntriesType) ProtoMessage()               {}
func (*RbacRuleEntriesType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{191} }

func (m *RbacRuleEntriesType) GetRbacRule() []*RbacRuleType {
	if m != nil {
		return m.RbacRule
	}
	return nil
}

type FloatingIpPoolSubnetType struct {
	SubnetUuid []string `protobuf:"bytes,1,rep,name=subnet_uuid,json=subnetUuid" json:"subnet_uuid,omitempty"`
}

func (m *FloatingIpPoolSubnetType) Reset()         { *m = FloatingIpPoolSubnetType{} }
func (m *FloatingIpPoolSubnetType) String() string { return proto.CompactTextString(m) }
func (*FloatingIpPoolSubnetType) ProtoMessage()    {}
func (*FloatingIpPoolSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{192}
}

func (m *FloatingIpPoolSubnetType) GetSubnetUuid() []string {
	if m != nil {
		return m.SubnetUuid
	}
	return nil
}

type ServiceTemplateType struct {
	AvailabilityZoneEnable    bool                            `protobuf:"varint,1,opt,name=availability_zone_enable,json=availabilityZoneEnable,proto3" json:"availability_zone_enable,omitempty"`
	InstanceData              string                          `protobuf:"bytes,2,opt,name=instance_data,json=instanceData,proto3" json:"instance_data,omitempty"`
	OrderedInterfaces         bool                            `protobuf:"varint,3,opt,name=ordered_interfaces,json=orderedInterfaces,proto3" json:"ordered_interfaces,omitempty"`
	ServiceVirtualizationType string                          `protobuf:"bytes,4,opt,name=service_virtualization_type,json=serviceVirtualizationType,proto3" json:"service_virtualization_type,omitempty"`
	InterfaceType             []*ServiceTemplateInterfaceType `protobuf:"bytes,5,rep,name=interface_type,json=interfaceType" json:"interface_type,omitempty"`
	ImageName                 string                          `protobuf:"bytes,6,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	ServiceMode               string                          `protobuf:"bytes,7,opt,name=service_mode,json=serviceMode,proto3" json:"service_mode,omitempty"`
	Version                   int64                           `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
	ServiceType               string                          `protobuf:"bytes,9,opt,name=service_type,json=serviceType,proto3" json:"service_type,omitempty"`
	Flavor                    string                          `protobuf:"bytes,10,opt,name=flavor,proto3" json:"flavor,omitempty"`
	ServiceScaling            bool                            `protobuf:"varint,11,opt,name=service_scaling,json=serviceScaling,proto3" json:"service_scaling,omitempty"`
	VrouterInstanceType       string                          `protobuf:"bytes,12,opt,name=vrouter_instance_type,json=vrouterInstanceType,proto3" json:"vrouter_instance_type,omitempty"`
}

func (m *ServiceTemplateType) Reset()                    { *m = ServiceTemplateType{} }
func (m *ServiceTemplateType) String() string            { return proto.CompactTextString(m) }
func (*ServiceTemplateType) ProtoMessage()               {}
func (*ServiceTemplateType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{193} }

func (m *ServiceTemplateType) GetAvailabilityZoneEnable() bool {
	if m != nil {
		return m.AvailabilityZoneEnable
	}
	return false
}

func (m *ServiceTemplateType) GetInstanceData() string {
	if m != nil {
		return m.InstanceData
	}
	return ""
}

func (m *ServiceTemplateType) GetOrderedInterfaces() bool {
	if m != nil {
		return m.OrderedInterfaces
	}
	return false
}

func (m *ServiceTemplateType) GetServiceVirtualizationType() string {
	if m != nil {
		return m.ServiceVirtualizationType
	}
	return ""
}

func (m *ServiceTemplateType) GetInterfaceType() []*ServiceTemplateInterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return nil
}

func (m *ServiceTemplateType) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *ServiceTemplateType) GetServiceMode() string {
	if m != nil {
		return m.ServiceMode
	}
	return ""
}

func (m *ServiceTemplateType) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ServiceTemplateType) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

func (m *ServiceTemplateType) GetFlavor() string {
	if m != nil {
		return m.Flavor
	}
	return ""
}

func (m *ServiceTemplateType) GetServiceScaling() bool {
	if m != nil {
		return m.ServiceScaling
	}
	return false
}

func (m *ServiceTemplateType) GetVrouterInstanceType() string {
	if m != nil {
		return m.VrouterInstanceType
	}
	return ""
}

type FatFlowProtocols struct {
	FatFlowProtocol []*ProtocolType `protobuf:"bytes,1,rep,name=fat_flow_protocol,json=fatFlowProtocol" json:"fat_flow_protocol,omitempty"`
}

func (m *FatFlowProtocols) Reset()                    { *m = FatFlowProtocols{} }
func (m *FatFlowProtocols) String() string            { return proto.CompactTextString(m) }
func (*FatFlowProtocols) ProtoMessage()               {}
func (*FatFlowProtocols) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{194} }

func (m *FatFlowProtocols) GetFatFlowProtocol() []*ProtocolType {
	if m != nil {
		return m.FatFlowProtocol
	}
	return nil
}

type MACMoveLimitControlType struct {
	MacMoveTimeWindow  int64  `protobuf:"varint,1,opt,name=mac_move_time_window,json=macMoveTimeWindow,proto3" json:"mac_move_time_window,omitempty"`
	MacMoveLimit       int64  `protobuf:"varint,2,opt,name=mac_move_limit,json=macMoveLimit,proto3" json:"mac_move_limit,omitempty"`
	MacMoveLimitAction string `protobuf:"bytes,3,opt,name=mac_move_limit_action,json=macMoveLimitAction,proto3" json:"mac_move_limit_action,omitempty"`
}

func (m *MACMoveLimitControlType) Reset()         { *m = MACMoveLimitControlType{} }
func (m *MACMoveLimitControlType) String() string { return proto.CompactTextString(m) }
func (*MACMoveLimitControlType) ProtoMessage()    {}
func (*MACMoveLimitControlType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{195}
}

func (m *MACMoveLimitControlType) GetMacMoveTimeWindow() int64 {
	if m != nil {
		return m.MacMoveTimeWindow
	}
	return 0
}

func (m *MACMoveLimitControlType) GetMacMoveLimit() int64 {
	if m != nil {
		return m.MacMoveLimit
	}
	return 0
}

func (m *MACMoveLimitControlType) GetMacMoveLimitAction() string {
	if m != nil {
		return m.MacMoveLimitAction
	}
	return ""
}

type DiscoveryPubSubEndPointType struct {
	EpVersion string      `protobuf:"bytes,1,opt,name=ep_version,json=epVersion,proto3" json:"ep_version,omitempty"`
	EpId      string      `protobuf:"bytes,2,opt,name=ep_id,json=epId,proto3" json:"ep_id,omitempty"`
	EpType    string      `protobuf:"bytes,3,opt,name=ep_type,json=epType,proto3" json:"ep_type,omitempty"`
	EpPrefix  *SubnetType `protobuf:"bytes,4,opt,name=ep_prefix,json=epPrefix" json:"ep_prefix,omitempty"`
}

func (m *DiscoveryPubSubEndPointType) Reset()         { *m = DiscoveryPubSubEndPointType{} }
func (m *DiscoveryPubSubEndPointType) String() string { return proto.CompactTextString(m) }
func (*DiscoveryPubSubEndPointType) ProtoMessage()    {}
func (*DiscoveryPubSubEndPointType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{196}
}

func (m *DiscoveryPubSubEndPointType) GetEpVersion() string {
	if m != nil {
		return m.EpVersion
	}
	return ""
}

func (m *DiscoveryPubSubEndPointType) GetEpId() string {
	if m != nil {
		return m.EpId
	}
	return ""
}

func (m *DiscoveryPubSubEndPointType) GetEpType() string {
	if m != nil {
		return m.EpType
	}
	return ""
}

func (m *DiscoveryPubSubEndPointType) GetEpPrefix() *SubnetType {
	if m != nil {
		return m.EpPrefix
	}
	return nil
}

type AclRuleType struct {
	RuleUuid       string              `protobuf:"bytes,1,opt,name=rule_uuid,json=ruleUuid,proto3" json:"rule_uuid,omitempty"`
	MatchCondition *MatchConditionType `protobuf:"bytes,2,opt,name=match_condition,json=matchCondition" json:"match_condition,omitempty"`
	Direction      string              `protobuf:"bytes,3,opt,name=direction,proto3" json:"direction,omitempty"`
	ActionList     *ActionListType     `protobuf:"bytes,4,opt,name=action_list,json=actionList" json:"action_list,omitempty"`
}

func (m *AclRuleType) Reset()                    { *m = AclRuleType{} }
func (m *AclRuleType) String() string            { return proto.CompactTextString(m) }
func (*AclRuleType) ProtoMessage()               {}
func (*AclRuleType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{197} }

func (m *AclRuleType) GetRuleUuid() string {
	if m != nil {
		return m.RuleUuid
	}
	return ""
}

func (m *AclRuleType) GetMatchCondition() *MatchConditionType {
	if m != nil {
		return m.MatchCondition
	}
	return nil
}

func (m *AclRuleType) GetDirection() string {
	if m != nil {
		return m.Direction
	}
	return ""
}

func (m *AclRuleType) GetActionList() *ActionListType {
	if m != nil {
		return m.ActionList
	}
	return nil
}

type PluginProperty struct {
	Property string `protobuf:"bytes,1,opt,name=property,proto3" json:"property,omitempty"`
	Value    string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PluginProperty) Reset()                    { *m = PluginProperty{} }
func (m *PluginProperty) String() string            { return proto.CompactTextString(m) }
func (*PluginProperty) ProtoMessage()               {}
func (*PluginProperty) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{198} }

func (m *PluginProperty) GetProperty() string {
	if m != nil {
		return m.Property
	}
	return ""
}

func (m *PluginProperty) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type SecurityLoggingObjectRuleListType struct {
	Rule []*SecurityLoggingObjectRuleEntryType `protobuf:"bytes,1,rep,name=rule" json:"rule,omitempty"`
}

func (m *SecurityLoggingObjectRuleListType) Reset()         { *m = SecurityLoggingObjectRuleListType{} }
func (m *SecurityLoggingObjectRuleListType) String() string { return proto.CompactTextString(m) }
func (*SecurityLoggingObjectRuleListType) ProtoMessage()    {}
func (*SecurityLoggingObjectRuleListType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{199}
}

func (m *SecurityLoggingObjectRuleListType) GetRule() []*SecurityLoggingObjectRuleEntryType {
	if m != nil {
		return m.Rule
	}
	return nil
}

type FirewallServiceGroupType struct {
	FirewallService []*FirewallServiceType `protobuf:"bytes,1,rep,name=firewall_service,json=firewallService" json:"firewall_service,omitempty"`
}

func (m *FirewallServiceGroupType) Reset()         { *m = FirewallServiceGroupType{} }
func (m *FirewallServiceGroupType) String() string { return proto.CompactTextString(m) }
func (*FirewallServiceGroupType) ProtoMessage()    {}
func (*FirewallServiceGroupType) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{200}
}

func (m *FirewallServiceGroupType) GetFirewallService() []*FirewallServiceType {
	if m != nil {
		return m.FirewallService
	}
	return nil
}

type VrfAssignTableType struct {
	VrfAssignRule []*VrfAssignRuleType `protobuf:"bytes,1,rep,name=vrf_assign_rule,json=vrfAssignRule" json:"vrf_assign_rule,omitempty"`
}

func (m *VrfAssignTableType) Reset()                    { *m = VrfAssignTableType{} }
func (m *VrfAssignTableType) String() string            { return proto.CompactTextString(m) }
func (*VrfAssignTableType) ProtoMessage()               {}
func (*VrfAssignTableType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{201} }

func (m *VrfAssignTableType) GetVrfAssignRule() []*VrfAssignRuleType {
	if m != nil {
		return m.VrfAssignRule
	}
	return nil
}

type MemberType struct {
	Role string `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *MemberType) Reset()                    { *m = MemberType{} }
func (m *MemberType) String() string            { return proto.CompactTextString(m) }
func (*MemberType) ProtoMessage()               {}
func (*MemberType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{202} }

func (m *MemberType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

type AlarmAndList struct {
	AndList []*AlarmExpression `protobuf:"bytes,1,rep,name=and_list,json=andList" json:"and_list,omitempty"`
}

func (m *AlarmAndList) Reset()                    { *m = AlarmAndList{} }
func (m *AlarmAndList) String() string            { return proto.CompactTextString(m) }
func (*AlarmAndList) ProtoMessage()               {}
func (*AlarmAndList) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{203} }

func (m *AlarmAndList) GetAndList() []*AlarmExpression {
	if m != nil {
		return m.AndList
	}
	return nil
}

type PortMap struct {
	SrcPort  int64  `protobuf:"varint,1,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	DstPort  int64  `protobuf:"varint,3,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
}

func (m *PortMap) Reset()                    { *m = PortMap{} }
func (m *PortMap) String() string            { return proto.CompactTextString(m) }
func (*PortMap) ProtoMessage()               {}
func (*PortMap) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{204} }

func (m *PortMap) GetSrcPort() int64 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *PortMap) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *PortMap) GetDstPort() int64 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

type ProviderDetails struct {
	SegmentationId  int64  `protobuf:"varint,1,opt,name=segmentation_id,json=segmentationId,proto3" json:"segmentation_id,omitempty"`
	PhysicalNetwork string `protobuf:"bytes,2,opt,name=physical_network,json=physicalNetwork,proto3" json:"physical_network,omitempty"`
}

func (m *ProviderDetails) Reset()                    { *m = ProviderDetails{} }
func (m *ProviderDetails) String() string            { return proto.CompactTextString(m) }
func (*ProviderDetails) ProtoMessage()               {}
func (*ProviderDetails) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{205} }

func (m *ProviderDetails) GetSegmentationId() int64 {
	if m != nil {
		return m.SegmentationId
	}
	return 0
}

func (m *ProviderDetails) GetPhysicalNetwork() string {
	if m != nil {
		return m.PhysicalNetwork
	}
	return ""
}

type PermType2 struct {
	Owner        string       `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	OwnerAccess  int64        `protobuf:"varint,2,opt,name=owner_access,json=ownerAccess,proto3" json:"owner_access,omitempty"`
	GlobalAccess int64        `protobuf:"varint,3,opt,name=global_access,json=globalAccess,proto3" json:"global_access,omitempty"`
	Share        []*ShareType `protobuf:"bytes,4,rep,name=share" json:"share,omitempty"`
}

func (m *PermType2) Reset()                    { *m = PermType2{} }
func (m *PermType2) String() string            { return proto.CompactTextString(m) }
func (*PermType2) ProtoMessage()               {}
func (*PermType2) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{206} }

func (m *PermType2) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *PermType2) GetOwnerAccess() int64 {
	if m != nil {
		return m.OwnerAccess
	}
	return 0
}

func (m *PermType2) GetGlobalAccess() int64 {
	if m != nil {
		return m.GlobalAccess
	}
	return 0
}

func (m *PermType2) GetShare() []*ShareType {
	if m != nil {
		return m.Share
	}
	return nil
}

type DhcpOptionType struct {
	DhcpOptionValue      string `protobuf:"bytes,1,opt,name=dhcp_option_value,json=dhcpOptionValue,proto3" json:"dhcp_option_value,omitempty"`
	DhcpOptionValueBytes string `protobuf:"bytes,2,opt,name=dhcp_option_value_bytes,json=dhcpOptionValueBytes,proto3" json:"dhcp_option_value_bytes,omitempty"`
	DhcpOptionName       string `protobuf:"bytes,3,opt,name=dhcp_option_name,json=dhcpOptionName,proto3" json:"dhcp_option_name,omitempty"`
}

func (m *DhcpOptionType) Reset()                    { *m = DhcpOptionType{} }
func (m *DhcpOptionType) String() string            { return proto.CompactTextString(m) }
func (*DhcpOptionType) ProtoMessage()               {}
func (*DhcpOptionType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{207} }

func (m *DhcpOptionType) GetDhcpOptionValue() string {
	if m != nil {
		return m.DhcpOptionValue
	}
	return ""
}

func (m *DhcpOptionType) GetDhcpOptionValueBytes() string {
	if m != nil {
		return m.DhcpOptionValueBytes
	}
	return ""
}

func (m *DhcpOptionType) GetDhcpOptionName() string {
	if m != nil {
		return m.DhcpOptionName
	}
	return ""
}

type QosIdForwardingClassPairs struct {
	QosIdForwardingClassPair []*QosIdForwardingClassPair `protobuf:"bytes,1,rep,name=qos_id_forwarding_class_pair,json=qosIdForwardingClassPair" json:"qos_id_forwarding_class_pair,omitempty"`
}

func (m *QosIdForwardingClassPairs) Reset()         { *m = QosIdForwardingClassPairs{} }
func (m *QosIdForwardingClassPairs) String() string { return proto.CompactTextString(m) }
func (*QosIdForwardingClassPairs) ProtoMessage()    {}
func (*QosIdForwardingClassPairs) Descriptor() ([]byte, []int) {
	return fileDescriptorContrail, []int{208}
}

func (m *QosIdForwardingClassPairs) GetQosIdForwardingClassPair() []*QosIdForwardingClassPair {
	if m != nil {
		return m.QosIdForwardingClassPair
	}
	return nil
}

type PluginProperties struct {
	PluginProperty []*PluginProperty `protobuf:"bytes,1,rep,name=plugin_property,json=pluginProperty" json:"plugin_property,omitempty"`
}

func (m *PluginProperties) Reset()                    { *m = PluginProperties{} }
func (m *PluginProperties) String() string            { return proto.CompactTextString(m) }
func (*PluginProperties) ProtoMessage()               {}
func (*PluginProperties) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{209} }

func (m *PluginProperties) GetPluginProperty() []*PluginProperty {
	if m != nil {
		return m.PluginProperty
	}
	return nil
}

type AlarmOrList struct {
	OrList []*AlarmAndList `protobuf:"bytes,1,rep,name=or_list,json=orList" json:"or_list,omitempty"`
}

func (m *AlarmOrList) Reset()                    { *m = AlarmOrList{} }
func (m *AlarmOrList) String() string            { return proto.CompactTextString(m) }
func (*AlarmOrList) ProtoMessage()               {}
func (*AlarmOrList) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{210} }

func (m *AlarmOrList) GetOrList() []*AlarmAndList {
	if m != nil {
		return m.OrList
	}
	return nil
}

type ServiceScaleOutType struct {
	AutoScale    bool  `protobuf:"varint,1,opt,name=auto_scale,json=autoScale,proto3" json:"auto_scale,omitempty"`
	MaxInstances int64 `protobuf:"varint,2,opt,name=max_instances,json=maxInstances,proto3" json:"max_instances,omitempty"`
}

func (m *ServiceScaleOutType) Reset()                    { *m = ServiceScaleOutType{} }
func (m *ServiceScaleOutType) String() string            { return proto.CompactTextString(m) }
func (*ServiceScaleOutType) ProtoMessage()               {}
func (*ServiceScaleOutType) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{211} }

func (m *ServiceScaleOutType) GetAutoScale() bool {
	if m != nil {
		return m.AutoScale
	}
	return false
}

func (m *ServiceScaleOutType) GetMaxInstances() int64 {
	if m != nil {
		return m.MaxInstances
	}
	return 0
}

type AllowedAddressPair struct {
	Ip          *SubnetType `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	Mac         string      `protobuf:"bytes,2,opt,name=mac,proto3" json:"mac,omitempty"`
	AddressMode string      `protobuf:"bytes,3,opt,name=address_mode,json=addressMode,proto3" json:"address_mode,omitempty"`
}

func (m *AllowedAddressPair) Reset()                    { *m = AllowedAddressPair{} }
func (m *AllowedAddressPair) String() string            { return proto.CompactTextString(m) }
func (*AllowedAddressPair) ProtoMessage()               {}
func (*AllowedAddressPair) Descriptor() ([]byte, []int) { return fileDescriptorContrail, []int{212} }

func (m *AllowedAddressPair) GetIp() *SubnetType {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *AllowedAddressPair) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *AllowedAddressPair) GetAddressMode() string {
	if m != nil {
		return m.AddressMode
	}
	return ""
}

func init() {
	proto.RegisterType((*ResourceRequest)(nil), "ResourceRequest")
	proto.RegisterType((*ResourceResponse)(nil), "ResourceResponse")
	proto.RegisterType((*DeleteRequest)(nil), "DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "DeleteResponse")
	proto.RegisterType((*ListRequest)(nil), "ListRequest")
	proto.RegisterType((*Resource)(nil), "Resource")
	proto.RegisterType((*AccessControlList)(nil), "AccessControlList")
	proto.RegisterType((*AddressGroup)(nil), "AddressGroup")
	proto.RegisterType((*Alarm)(nil), "Alarm")
	proto.RegisterType((*AliasIPPool)(nil), "AliasIPPool")
	proto.RegisterType((*AliasIP)(nil), "AliasIP")
	proto.RegisterType((*AnalyticsNode)(nil), "AnalyticsNode")
	proto.RegisterType((*APIAccessList)(nil), "APIAccessList")
	proto.RegisterType((*ApplicationPolicySet)(nil), "ApplicationPolicySet")
	proto.RegisterType((*BGPAsAService)(nil), "BGPAsAService")
	proto.RegisterType((*BGPRouter)(nil), "BGPRouter")
	proto.RegisterType((*BGPVPN)(nil), "BGPVPN")
	proto.RegisterType((*BridgeDomain)(nil), "BridgeDomain")
	proto.RegisterType((*ConfigNode)(nil), "ConfigNode")
	proto.RegisterType((*ConfigRoot)(nil), "ConfigRoot")
	proto.RegisterType((*CustomerAttachment)(nil), "CustomerAttachment")
	proto.RegisterType((*DatabaseNode)(nil), "DatabaseNode")
	proto.RegisterType((*DiscoveryServiceAssignment)(nil), "DiscoveryServiceAssignment")
	proto.RegisterType((*Domain)(nil), "Domain")
	proto.RegisterType((*DsaRule)(nil), "DsaRule")
	proto.RegisterType((*E2ServiceProvider)(nil), "E2ServiceProvider")
	proto.RegisterType((*FirewallPolicy)(nil), "FirewallPolicy")
	proto.RegisterType((*FirewallRule)(nil), "FirewallRule")
	proto.RegisterType((*FloatingIPPool)(nil), "FloatingIPPool")
	proto.RegisterType((*FloatingIP)(nil), "FloatingIP")
	proto.RegisterType((*ForwardingClass)(nil), "ForwardingClass")
	proto.RegisterType((*GlobalQosConfig)(nil), "GlobalQosConfig")
	proto.RegisterType((*GlobalSystemConfig)(nil), "GlobalSystemConfig")
	proto.RegisterType((*GlobalVrouterConfig)(nil), "GlobalVrouterConfig")
	proto.RegisterType((*InstanceIP)(nil), "InstanceIP")
	proto.RegisterType((*InterfaceRouteTable)(nil), "InterfaceRouteTable")
	proto.RegisterType((*LoadbalancerHealthmonitor)(nil), "LoadbalancerHealthmonitor")
	proto.RegisterType((*LoadbalancerListener)(nil), "LoadbalancerListener")
	proto.RegisterType((*LoadbalancerMember)(nil), "LoadbalancerMember")
	proto.RegisterType((*LoadbalancerPool)(nil), "LoadbalancerPool")
	proto.RegisterType((*Loadbalancer)(nil), "Loadbalancer")
	proto.RegisterType((*LogicalInterface)(nil), "LogicalInterface")
	proto.RegisterType((*LogicalRouter)(nil), "LogicalRouter")
	proto.RegisterType((*Namespace)(nil), "Namespace")
	proto.RegisterType((*NetworkDeviceConfig)(nil), "NetworkDeviceConfig")
	proto.RegisterType((*NetworkIpam)(nil), "NetworkIpam")
	proto.RegisterType((*NetworkPolicy)(nil), "NetworkPolicy")
	proto.RegisterType((*PeeringPolicy)(nil), "PeeringPolicy")
	proto.RegisterType((*PhysicalInterface)(nil), "PhysicalInterface")
	proto.RegisterType((*PhysicalRouter)(nil), "PhysicalRouter")
	proto.RegisterType((*PolicyManagement)(nil), "PolicyManagement")
	proto.RegisterType((*PortTuple)(nil), "PortTuple")
	proto.RegisterType((*Project)(nil), "Project")
	proto.RegisterType((*ProviderAttachment)(nil), "ProviderAttachment")
	proto.RegisterType((*QosConfig)(nil), "QosConfig")
	proto.RegisterType((*QosQueue)(nil), "QosQueue")
	proto.RegisterType((*RouteAggregate)(nil), "RouteAggregate")
	proto.RegisterType((*RouteTable)(nil), "RouteTable")
	proto.RegisterType((*RouteTarget)(nil), "RouteTarget")
	proto.RegisterType((*RoutingInstance)(nil), "RoutingInstance")
	proto.RegisterType((*RoutingPolicy)(nil), "RoutingPolicy")
	proto.RegisterType((*SecurityGroup)(nil), "SecurityGroup")
	proto.RegisterType((*SecurityLoggingObject)(nil), "SecurityLoggingObject")
	proto.RegisterType((*ServiceAppliance)(nil), "ServiceAppliance")
	proto.RegisterType((*ServiceApplianceSet)(nil), "ServiceApplianceSet")
	proto.RegisterType((*ServiceConnectionModule)(nil), "ServiceConnectionModule")
	proto.RegisterType((*ServiceEndpoint)(nil), "ServiceEndpoint")
	proto.RegisterType((*ServiceGroup)(nil), "ServiceGroup")
	proto.RegisterType((*ServiceHealthCheck)(nil), "ServiceHealthCheck")
	proto.RegisterType((*ServiceInstance)(nil), "ServiceInstance")
	proto.RegisterType((*ServiceObject)(nil), "ServiceObject")
	proto.RegisterType((*ServiceTemplate)(nil), "ServiceTemplate")
	proto.RegisterType((*Subnet)(nil), "Subnet")
	proto.RegisterType((*Tag)(nil), "Tag")
	proto.RegisterType((*TagType)(nil), "TagType")
	proto.RegisterType((*User)(nil), "User")
	proto.RegisterType((*VirtualDNSRecord)(nil), "VirtualDNSRecord")
	proto.RegisterType((*VirtualDNS)(nil), "VirtualDNS")
	proto.RegisterType((*VirtualIP)(nil), "VirtualIP")
	proto.RegisterType((*VirtualMachineInterface)(nil), "VirtualMachineInterface")
	proto.RegisterType((*VirtualMachine)(nil), "VirtualMachine")
	proto.RegisterType((*VirtualNetwork)(nil), "VirtualNetwork")
	proto.RegisterType((*VirtualRouter)(nil), "VirtualRouter")
	proto.RegisterType((*AppformixNodeRole)(nil), "AppformixNodeRole")
	proto.RegisterType((*BaremetalNode)(nil), "BaremetalNode")
	proto.RegisterType((*BaremetalPort)(nil), "BaremetalPort")
	proto.RegisterType((*ContrailAnalyticsDatabaseNodeRole)(nil), "ContrailAnalyticsDatabaseNodeRole")
	proto.RegisterType((*ContrailAnalyticsNode)(nil), "ContrailAnalyticsNode")
	proto.RegisterType((*ContrailCluster)(nil), "ContrailCluster")
	proto.RegisterType((*ContrailControllerNodeRole)(nil), "ContrailControllerNodeRole")
	proto.RegisterType((*ControllerNodeRole)(nil), "ControllerNodeRole")
	proto.RegisterType((*Dashboard)(nil), "Dashboard")
	proto.RegisterType((*Keypair)(nil), "Keypair")
	proto.RegisterType((*KubernetesCluster)(nil), "KubernetesCluster")
	proto.RegisterType((*KubernetesNode)(nil), "KubernetesNode")
	proto.RegisterType((*Location)(nil), "Location")
	proto.RegisterType((*Node)(nil), "Node")
	proto.RegisterType((*OpenstackCluster)(nil), "OpenstackCluster")
	proto.RegisterType((*OpenstackComputeNodeRole)(nil), "OpenstackComputeNodeRole")
	proto.RegisterType((*OpenstackStorageNodeRole)(nil), "OpenstackStorageNodeRole")
	proto.RegisterType((*VPNGroup)(nil), "VPNGroup")
	proto.RegisterType((*Widget)(nil), "Widget")
	proto.RegisterType((*PermType)(nil), "PermType")
	proto.RegisterType((*LoadbalancerHealthmonitorType)(nil), "LoadbalancerHealthmonitorType")
	proto.RegisterType((*SNMPCredentials)(nil), "SNMPCredentials")
	proto.RegisterType((*PolicyBasedForwardingRuleType)(nil), "PolicyBasedForwardingRuleType")
	proto.RegisterType((*VirtualMachineInterfacePropertiesType)(nil), "VirtualMachineInterfacePropertiesType")
	proto.RegisterType((*VirtualNetworkPolicyType)(nil), "VirtualNetworkPolicyType")
	proto.RegisterType((*ShareType)(nil), "ShareType")
	proto.RegisterType((*StaticMirrorNhType)(nil), "StaticMirrorNhType")
	proto.RegisterType((*FirewallRuleMatchTagsTypeIdList)(nil), "FirewallRuleMatchTagsTypeIdList")
	proto.RegisterType((*CommunityAttributes)(nil), "CommunityAttributes")
	proto.RegisterType((*IpAddressesType)(nil), "IpAddressesType")
	proto.RegisterType((*ServiceTemplateInterfaceType)(nil), "ServiceTemplateInterfaceType")
	proto.RegisterType((*IdPermsType)(nil), "IdPermsType")
	proto.RegisterType((*RbacPermType)(nil), "RbacPermType")
	proto.RegisterType((*FlowAgingTimeoutList)(nil), "FlowAgingTimeoutList")
	proto.RegisterType((*UveKeysType)(nil), "UveKeysType")
	proto.RegisterType((*DiscoveryServiceAssignmentType)(nil), "DiscoveryServiceAssignmentType")
	proto.RegisterType((*GracefulRestartParametersType)(nil), "GracefulRestartParametersType")
	proto.RegisterType((*ServiceInterfaceTag)(nil), "ServiceInterfaceTag")
	proto.RegisterType((*AllocationPoolType)(nil), "AllocationPoolType")
	proto.RegisterType((*PolicyRuleType)(nil), "PolicyRuleType")
	proto.RegisterType((*VirtualDnsRecordType)(nil), "VirtualDnsRecordType")
	proto.RegisterType((*AlarmExpression)(nil), "AlarmExpression")
	proto.RegisterType((*FirewallServiceType)(nil), "FirewallServiceType")
	proto.RegisterType((*RoutingPolicyServiceInstanceType)(nil), "RoutingPolicyServiceInstanceType")
	proto.RegisterType((*TimerType)(nil), "TimerType")
	proto.RegisterType((*FirewallRuleEndpointType)(nil), "FirewallRuleEndpointType")
	proto.RegisterType((*InterfaceMirrorType)(nil), "InterfaceMirrorType")
	proto.RegisterType((*VirtualNetworkType)(nil), "VirtualNetworkType")
	proto.RegisterType((*PortType)(nil), "PortType")
	proto.RegisterType((*PortMappings)(nil), "PortMappings")
	proto.RegisterType((*ServiceInstanceInterfaceType)(nil), "ServiceInstanceInterfaceType")
	proto.RegisterType((*SequenceType)(nil), "SequenceType")
	proto.RegisterType((*SecurityLoggingObjectRuleEntryType)(nil), "SecurityLoggingObjectRuleEntryType")
	proto.RegisterType((*SubnetType)(nil), "SubnetType")
	proto.RegisterType((*RouteTargetList)(nil), "RouteTargetList")
	proto.RegisterType((*LinklocalServiceEntryType)(nil), "LinklocalServiceEntryType")
	proto.RegisterType((*IpamSubnetType)(nil), "IpamSubnetType")
	proto.RegisterType((*QuotaType)(nil), "QuotaType")
	proto.RegisterType((*KeyValuePairs)(nil), "KeyValuePairs")
	proto.RegisterType((*TelemetryStateInfo)(nil), "TelemetryStateInfo")
	proto.RegisterType((*FirewallRuleMatchTagsType)(nil), "FirewallRuleMatchTagsType")
	proto.RegisterType((*LinklocalServicesTypes)(nil), "LinklocalServicesTypes")
	proto.RegisterType((*RouteTableType)(nil), "RouteTableType")
	proto.RegisterType((*MacAddressesType)(nil), "MacAddressesType")
	proto.RegisterType((*VrfAssignRuleType)(nil), "VrfAssignRuleType")
	proto.RegisterType((*ActionListType)(nil), "ActionListType")
	proto.RegisterType((*AclEntriesType)(nil), "AclEntriesType")
	proto.RegisterType((*VirtualIpType)(nil), "VirtualIpType")
	proto.RegisterType((*RouteType)(nil), "RouteType")
	proto.RegisterType((*LoadbalancerType)(nil), "LoadbalancerType")
	proto.RegisterType((*ProtocolType)(nil), "ProtocolType")
	proto.RegisterType((*ServiceInstanceType)(nil), "ServiceInstanceType")
	proto.RegisterType((*MatchConditionType)(nil), "MatchConditionType")
	proto.RegisterType((*LoadbalancerMemberType)(nil), "LoadbalancerMemberType")
	proto.RegisterType((*UserCredentials)(nil), "UserCredentials")
	proto.RegisterType((*AllowedAddressPairs)(nil), "AllowedAddressPairs")
	proto.RegisterType((*TelemetryResourceInfo)(nil), "TelemetryResourceInfo")
	proto.RegisterType((*ControlTrafficDscpType)(nil), "ControlTrafficDscpType")
	proto.RegisterType((*UserDefinedLogStat)(nil), "UserDefinedLogStat")
	proto.RegisterType((*LoadbalancerPoolType)(nil), "LoadbalancerPoolType")
	proto.RegisterType((*KeyValuePair)(nil), "KeyValuePair")
	proto.RegisterType((*IpamSubnets)(nil), "IpamSubnets")
	proto.RegisterType((*LoadbalancerListenerType)(nil), "LoadbalancerListenerType")
	proto.RegisterType((*BridgeDomainMembershipType)(nil), "BridgeDomainMembershipType")
	proto.RegisterType((*VnSubnetsType)(nil), "VnSubnetsType")
	proto.RegisterType((*ServiceApplianceInterfaceType)(nil), "ServiceApplianceInterfaceType")
	proto.RegisterType((*SubnetListType)(nil), "SubnetListType")
	proto.RegisterType((*BGPaaServiceParametersType)(nil), "BGPaaServiceParametersType")
	proto.RegisterType((*IpamDnsAddressType)(nil), "IpamDnsAddressType")
	proto.RegisterType((*DhcpOptionsListType)(nil), "DhcpOptionsListType")
	proto.RegisterType((*MACLimitControlType)(nil), "MACLimitControlType")
	proto.RegisterType((*UserDefinedLogStatList)(nil), "UserDefinedLogStatList")
	proto.RegisterType((*EcmpHashingIncludeFields)(nil), "EcmpHashingIncludeFields")
	proto.RegisterType((*EncapsulationPrioritiesType)(nil), "EncapsulationPrioritiesType")
	proto.RegisterType((*VirtualRouterNetworkIpamType)(nil), "VirtualRouterNetworkIpamType")
	proto.RegisterType((*VirtualDnsType)(nil), "VirtualDnsType")
	proto.RegisterType((*FirewallSequence)(nil), "FirewallSequence")
	proto.RegisterType((*MirrorActionType)(nil), "MirrorActionType")
	proto.RegisterType((*IpamType)(nil), "IpamType")
	proto.RegisterType((*JunosServicePorts)(nil), "JunosServicePorts")
	proto.RegisterType((*AlarmOperand2)(nil), "AlarmOperand2")
	proto.RegisterType((*RbacRuleType)(nil), "RbacRuleType")
	proto.RegisterType((*DomainLimitsType)(nil), "DomainLimitsType")
	proto.RegisterType((*PolicyEntriesType)(nil), "PolicyEntriesType")
	proto.RegisterType((*ServiceHealthCheckType)(nil), "ServiceHealthCheckType")
	proto.RegisterType((*AddressType)(nil), "AddressType")
	proto.RegisterType((*FlowAgingTimeout)(nil), "FlowAgingTimeout")
	proto.RegisterType((*QosIdForwardingClassPair)(nil), "QosIdForwardingClassPair")
	proto.RegisterType((*RbacRuleEntriesType)(nil), "RbacRuleEntriesType")
	proto.RegisterType((*FloatingIpPoolSubnetType)(nil), "FloatingIpPoolSubnetType")
	proto.RegisterType((*ServiceTemplateType)(nil), "ServiceTemplateType")
	proto.RegisterType((*FatFlowProtocols)(nil), "FatFlowProtocols")
	proto.RegisterType((*MACMoveLimitControlType)(nil), "MACMoveLimitControlType")
	proto.RegisterType((*DiscoveryPubSubEndPointType)(nil), "DiscoveryPubSubEndPointType")
	proto.RegisterType((*AclRuleType)(nil), "AclRuleType")
	proto.RegisterType((*PluginProperty)(nil), "PluginProperty")
	proto.RegisterType((*SecurityLoggingObjectRuleListType)(nil), "SecurityLoggingObjectRuleListType")
	proto.RegisterType((*FirewallServiceGroupType)(nil), "FirewallServiceGroupType")
	proto.RegisterType((*VrfAssignTableType)(nil), "VrfAssignTableType")
	proto.RegisterType((*MemberType)(nil), "MemberType")
	proto.RegisterType((*AlarmAndList)(nil), "AlarmAndList")
	proto.RegisterType((*PortMap)(nil), "PortMap")
	proto.RegisterType((*ProviderDetails)(nil), "ProviderDetails")
	proto.RegisterType((*PermType2)(nil), "PermType2")
	proto.RegisterType((*DhcpOptionType)(nil), "DhcpOptionType")
	proto.RegisterType((*QosIdForwardingClassPairs)(nil), "QosIdForwardingClassPairs")
	proto.RegisterType((*PluginProperties)(nil), "PluginProperties")
	proto.RegisterType((*AlarmOrList)(nil), "AlarmOrList")
	proto.RegisterType((*ServiceScaleOutType)(nil), "ServiceScaleOutType")
	proto.RegisterType((*AllowedAddressPair)(nil), "AllowedAddressPair")
	proto.RegisterEnum("ResponseType", ResponseType_name, ResponseType_value)
}
func (m *ResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for _, msg := range m.Resource {
			dAtA[i] = 0x12
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResourceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ResponseType))
	}
	if m.Resource != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Resource.Size()))
		n1, err := m.Resource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ResourceType)))
		i += copy(dAtA[i:], m.ResourceType)
	}
	if len(m.Uuid) > 0 {
		for _, s := range m.Uuid {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ResponseType))
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	return i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ResourceType)))
		i += copy(dAtA[i:], m.ResourceType)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Limit))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Offset))
	}
	if m.Detail {
		dAtA[i] = 0x20
		i++
		if m.Detail {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Count {
		dAtA[i] = 0x28
		i++
		if m.Count {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Shared {
		dAtA[i] = 0x30
		i++
		if m.Shared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExcludeHrefs {
		dAtA[i] = 0x38
		i++
		if m.ExcludeHrefs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ParentFqName) > 0 {
		for _, s := range m.ParentFqName {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.ParentUuids) > 0 {
		for _, s := range m.ParentUuids {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.BackrefUuids) > 0 {
		for _, s := range m.BackrefUuids {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ObjectUuids) > 0 {
		for _, s := range m.ObjectUuids {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Resource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResourceOneof != nil {
		nn2, err := m.ResourceOneof.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *Resource_AccessControlList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AccessControlList != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AccessControlList.Size()))
		n3, err := m.AccessControlList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Resource_AddressGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AddressGroup != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AddressGroup.Size()))
		n4, err := m.AddressGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Resource_Alarm) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Alarm != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Alarm.Size()))
		n5, err := m.Alarm.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Resource_AliasIpPool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AliasIpPool != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AliasIpPool.Size()))
		n6, err := m.AliasIpPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Resource_AliasIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AliasIp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AliasIp.Size()))
		n7, err := m.AliasIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Resource_AnalyticsNode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnalyticsNode != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AnalyticsNode.Size()))
		n8, err := m.AnalyticsNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Resource_ApiAccessList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ApiAccessList != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ApiAccessList.Size()))
		n9, err := m.ApiAccessList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Resource_ApplicationPolicySet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ApplicationPolicySet != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ApplicationPolicySet.Size()))
		n10, err := m.ApplicationPolicySet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Resource_BgpAsAService) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BgpAsAService != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.BgpAsAService.Size()))
		n11, err := m.BgpAsAService.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Resource_BgpRouter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BgpRouter != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.BgpRouter.Size()))
		n12, err := m.BgpRouter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Resource_Bgpvpn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Bgpvpn != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Bgpvpn.Size()))
		n13, err := m.Bgpvpn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *Resource_BridgeDomain) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BridgeDomain != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.BridgeDomain.Size()))
		n14, err := m.BridgeDomain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *Resource_ConfigNode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ConfigNode != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ConfigNode.Size()))
		n15, err := m.ConfigNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *Resource_ConfigRoot) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ConfigRoot != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ConfigRoot.Size()))
		n16, err := m.ConfigRoot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *Resource_CustomerAttachment) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CustomerAttachment != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.CustomerAttachment.Size()))
		n17, err := m.CustomerAttachment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *Resource_DatabaseNode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DatabaseNode != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DatabaseNode.Size()))
		n18, err := m.DatabaseNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *Resource_DiscoveryServiceAssignment) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DiscoveryServiceAssignment != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DiscoveryServiceAssignment.Size()))
		n19, err := m.DiscoveryServiceAssignment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *Resource_Domain) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Domain != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Domain.Size()))
		n20, err := m.Domain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *Resource_DsaRule) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DsaRule != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DsaRule.Size()))
		n21, err := m.DsaRule.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *Resource_E2ServiceProvider) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.E2ServiceProvider != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.E2ServiceProvider.Size()))
		n22, err := m.E2ServiceProvider.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *Resource_FirewallPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FirewallPolicy != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FirewallPolicy.Size()))
		n23, err := m.FirewallPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *Resource_FirewallRule) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FirewallRule != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FirewallRule.Size()))
		n24, err := m.FirewallRule.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *Resource_FloatingIpPool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FloatingIpPool != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FloatingIpPool.Size()))
		n25, err := m.FloatingIpPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *Resource_FloatingIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FloatingIp != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FloatingIp.Size()))
		n26, err := m.FloatingIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *Resource_ForwardingClass) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ForwardingClass != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ForwardingClass.Size()))
		n27, err := m.ForwardingClass.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *Resource_GlobalQosConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GlobalQosConfig != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.GlobalQosConfig.Size()))
		n28, err := m.GlobalQosConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *Resource_GlobalSystemConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GlobalSystemConfig != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.GlobalSystemConfig.Size()))
		n29, err := m.GlobalSystemConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *Resource_GlobalVrouterConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GlobalVrouterConfig != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.GlobalVrouterConfig.Size()))
		n30, err := m.GlobalVrouterConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *Resource_InstanceIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InstanceIp != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.InstanceIp.Size()))
		n31, err := m.InstanceIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *Resource_InterfaceRouteTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InterfaceRouteTable != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.InterfaceRouteTable.Size()))
		n32, err := m.InterfaceRouteTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *Resource_LoadbalancerHealthmonitor) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoadbalancerHealthmonitor != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerHealthmonitor.Size()))
		n33, err := m.LoadbalancerHealthmonitor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *Resource_LoadbalancerListener) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoadbalancerListener != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerListener.Size()))
		n34, err := m.LoadbalancerListener.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *Resource_LoadbalancerMember) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoadbalancerMember != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerMember.Size()))
		n35, err := m.LoadbalancerMember.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *Resource_LoadbalancerPool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoadbalancerPool != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerPool.Size()))
		n36, err := m.LoadbalancerPool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *Resource_Loadbalancer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Loadbalancer != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Loadbalancer.Size()))
		n37, err := m.Loadbalancer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *Resource_LogicalInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogicalInterface != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LogicalInterface.Size()))
		n38, err := m.LogicalInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *Resource_LogicalRouter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogicalRouter != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LogicalRouter.Size()))
		n39, err := m.LogicalRouter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *Resource_Namespace) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Namespace != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Namespace.Size()))
		n40, err := m.Namespace.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *Resource_NetworkDeviceConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetworkDeviceConfig != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NetworkDeviceConfig.Size()))
		n41, err := m.NetworkDeviceConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *Resource_NetworkIpam) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetworkIpam != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NetworkIpam.Size()))
		n42, err := m.NetworkIpam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}
func (m *Resource_NetworkPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetworkPolicy != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NetworkPolicy.Size()))
		n43, err := m.NetworkPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}
func (m *Resource_PeeringPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PeeringPolicy != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PeeringPolicy.Size()))
		n44, err := m.PeeringPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}
func (m *Resource_PhysicalInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PhysicalInterface != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PhysicalInterface.Size()))
		n45, err := m.PhysicalInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *Resource_PhysicalRouter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PhysicalRouter != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PhysicalRouter.Size()))
		n46, err := m.PhysicalRouter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func (m *Resource_PolicyManagement) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PolicyManagement != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PolicyManagement.Size()))
		n47, err := m.PolicyManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}
func (m *Resource_PortTuple) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PortTuple != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PortTuple.Size()))
		n48, err := m.PortTuple.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *Resource_Project) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Project != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Project.Size()))
		n49, err := m.Project.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *Resource_ProviderAttachment) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ProviderAttachment != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProviderAttachment.Size()))
		n50, err := m.ProviderAttachment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}
func (m *Resource_QosConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.QosConfig != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.QosConfig.Size()))
		n51, err := m.QosConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}
func (m *Resource_QosQueue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.QosQueue != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.QosQueue.Size()))
		n52, err := m.QosQueue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	return i, nil
}
func (m *Resource_RouteAggregate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RouteAggregate != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RouteAggregate.Size()))
		n53, err := m.RouteAggregate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}
func (m *Resource_RouteTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RouteTable != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RouteTable.Size()))
		n54, err := m.RouteTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}
func (m *Resource_RouteTarget) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RouteTarget != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RouteTarget.Size()))
		n55, err := m.RouteTarget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}
func (m *Resource_RoutingInstance) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RoutingInstance != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RoutingInstance.Size()))
		n56, err := m.RoutingInstance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}
func (m *Resource_RoutingPolicy) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RoutingPolicy != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RoutingPolicy.Size()))
		n57, err := m.RoutingPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}
func (m *Resource_SecurityGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SecurityGroup != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityGroup.Size()))
		n58, err := m.SecurityGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}
func (m *Resource_SecurityLoggingObject) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SecurityLoggingObject != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityLoggingObject.Size()))
		n59, err := m.SecurityLoggingObject.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}
func (m *Resource_ServiceAppliance) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceAppliance != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceAppliance.Size()))
		n60, err := m.ServiceAppliance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}
func (m *Resource_ServiceApplianceSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceApplianceSet != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceApplianceSet.Size()))
		n61, err := m.ServiceApplianceSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}
func (m *Resource_ServiceConnectionModule) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceConnectionModule != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceConnectionModule.Size()))
		n62, err := m.ServiceConnectionModule.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}
func (m *Resource_ServiceEndpoint) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceEndpoint != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceEndpoint.Size()))
		n63, err := m.ServiceEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}
func (m *Resource_ServiceGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceGroup != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceGroup.Size()))
		n64, err := m.ServiceGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}
func (m *Resource_ServiceHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceHealthCheck != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceHealthCheck.Size()))
		n65, err := m.ServiceHealthCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}
func (m *Resource_ServiceInstance) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceInstance != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceInstance.Size()))
		n66, err := m.ServiceInstance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	return i, nil
}
func (m *Resource_ServiceObject) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceObject != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceObject.Size()))
		n67, err := m.ServiceObject.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}
func (m *Resource_ServiceTemplate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ServiceTemplate != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceTemplate.Size()))
		n68, err := m.ServiceTemplate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}
func (m *Resource_Subnet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Subnet != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Subnet.Size()))
		n69, err := m.Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}
func (m *Resource_Tag) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Tag != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Tag.Size()))
		n70, err := m.Tag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}
func (m *Resource_TagType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TagType != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.TagType.Size()))
		n71, err := m.TagType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}
func (m *Resource_User) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.User != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.User.Size()))
		n72, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	return i, nil
}
func (m *Resource_Virtual_DNSRecord) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Virtual_DNSRecord != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Virtual_DNSRecord.Size()))
		n73, err := m.Virtual_DNSRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}
func (m *Resource_Virtual_DNS) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Virtual_DNS != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Virtual_DNS.Size()))
		n74, err := m.Virtual_DNS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	return i, nil
}
func (m *Resource_VirtualIp) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VirtualIp != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualIp.Size()))
		n75, err := m.VirtualIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	return i, nil
}
func (m *Resource_VirtualMachineInterface) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VirtualMachineInterface != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachineInterface.Size()))
		n76, err := m.VirtualMachineInterface.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}
func (m *Resource_VirtualMachine) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VirtualMachine != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachine.Size()))
		n77, err := m.VirtualMachine.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	return i, nil
}
func (m *Resource_VirtualNetwork) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VirtualNetwork != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualNetwork.Size()))
		n78, err := m.VirtualNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}
func (m *Resource_VirtualRouter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VirtualRouter != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualRouter.Size()))
		n79, err := m.VirtualRouter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	return i, nil
}
func (m *Resource_AppformixNodeRole) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AppformixNodeRole != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AppformixNodeRole.Size()))
		n80, err := m.AppformixNodeRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}
func (m *Resource_BaremetalNode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BaremetalNode != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.BaremetalNode.Size()))
		n81, err := m.BaremetalNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	return i, nil
}
func (m *Resource_BaremetalPort) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BaremetalPort != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.BaremetalPort.Size()))
		n82, err := m.BaremetalPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	return i, nil
}
func (m *Resource_ContrailAnalyticsDatabaseNodeRole) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ContrailAnalyticsDatabaseNodeRole != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ContrailAnalyticsDatabaseNodeRole.Size()))
		n83, err := m.ContrailAnalyticsDatabaseNodeRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}
func (m *Resource_ContrailAnalyticsNode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ContrailAnalyticsNode != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ContrailAnalyticsNode.Size()))
		n84, err := m.ContrailAnalyticsNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	return i, nil
}
func (m *Resource_ContrailCluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ContrailCluster != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ContrailCluster.Size()))
		n85, err := m.ContrailCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	return i, nil
}
func (m *Resource_ContrailControllerNodeRole) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ContrailControllerNodeRole != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ContrailControllerNodeRole.Size()))
		n86, err := m.ContrailControllerNodeRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	return i, nil
}
func (m *Resource_ControllerNodeRole) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ControllerNodeRole != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ControllerNodeRole.Size()))
		n87, err := m.ControllerNodeRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	return i, nil
}
func (m *Resource_Dashboard) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dashboard != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Dashboard.Size()))
		n88, err := m.Dashboard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	return i, nil
}
func (m *Resource_Keypair) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Keypair != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Keypair.Size()))
		n89, err := m.Keypair.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	return i, nil
}
func (m *Resource_KubernetesCluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.KubernetesCluster != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.KubernetesCluster.Size()))
		n90, err := m.KubernetesCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	return i, nil
}
func (m *Resource_KubernetesNode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.KubernetesNode != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.KubernetesNode.Size()))
		n91, err := m.KubernetesNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	return i, nil
}
func (m *Resource_Location) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Location != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Location.Size()))
		n92, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	return i, nil
}
func (m *Resource_Node) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Node != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Node.Size()))
		n93, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	return i, nil
}
func (m *Resource_OpenstackCluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OpenstackCluster != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.OpenstackCluster.Size()))
		n94, err := m.OpenstackCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	return i, nil
}
func (m *Resource_OpenstackComputeNodeRole) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OpenstackComputeNodeRole != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.OpenstackComputeNodeRole.Size()))
		n95, err := m.OpenstackComputeNodeRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	return i, nil
}
func (m *Resource_OpenstackStorageNodeRole) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OpenstackStorageNodeRole != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.OpenstackStorageNodeRole.Size()))
		n96, err := m.OpenstackStorageNodeRole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	return i, nil
}
func (m *Resource_VpnGroup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VpnGroup != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VpnGroup.Size()))
		n97, err := m.VpnGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	return i, nil
}
func (m *Resource_Widget) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Widget != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Widget.Size()))
		n98, err := m.Widget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	return i, nil
}
func (m *AccessControlList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessControlList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n99, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n100, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n100
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n101, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	if len(m.AccessControlListHash) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AccessControlListHash)))
		i += copy(dAtA[i:], m.AccessControlListHash)
	}
	if m.AccessControlListEntries != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AccessControlListEntries.Size()))
		n102, err := m.AccessControlListEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n102
	}
	return i, nil
}

func (m *AddressGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n103, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n104, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n105, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	if m.AddressGroupPrefix != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AddressGroupPrefix.Size()))
		n106, err := m.AddressGroupPrefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	return i, nil
}

func (m *Alarm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alarm) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n107, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n107
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n108, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n108
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n109, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n109
	}
	if m.AlarmRules != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AlarmRules.Size()))
		n110, err := m.AlarmRules.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	if m.UveKeys != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.UveKeys.Size()))
		n111, err := m.UveKeys.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	if m.AlarmSeverity != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AlarmSeverity))
	}
	return i, nil
}

func (m *AliasIPPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliasIPPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n112, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n112
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n113, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n113
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n114, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n114
	}
	return i, nil
}

func (m *AliasIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliasIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n115, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n116, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n117, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n117
	}
	if len(m.AliasIpAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AliasIpAddress)))
		i += copy(dAtA[i:], m.AliasIpAddress)
	}
	if len(m.AliasIpAddressFamily) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AliasIpAddressFamily)))
		i += copy(dAtA[i:], m.AliasIpAddressFamily)
	}
	return i, nil
}

func (m *AnalyticsNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyticsNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n118, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n118
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n119, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n119
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n120, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n120
	}
	if len(m.AnalyticsNodeIpAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AnalyticsNodeIpAddress)))
		i += copy(dAtA[i:], m.AnalyticsNodeIpAddress)
	}
	return i, nil
}

func (m *APIAccessList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *APIAccessList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n121, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n121
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n122, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n122
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n123, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n123
	}
	if m.ApiAccessListEntries != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ApiAccessListEntries.Size()))
		n124, err := m.ApiAccessListEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n124
	}
	return i, nil
}

func (m *ApplicationPolicySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationPolicySet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n125, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n125
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n126, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n126
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n127, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n127
	}
	if m.AllApplications {
		dAtA[i] = 0x48
		i++
		if m.AllApplications {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BGPAsAService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPAsAService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n128, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n128
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n129, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n129
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n130, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n130
	}
	if m.BgpaasShared {
		dAtA[i] = 0x48
		i++
		if m.BgpaasShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.BgpaasSessionAttributes) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.BgpaasSessionAttributes)))
		i += copy(dAtA[i:], m.BgpaasSessionAttributes)
	}
	if m.BgpaasSuppressRouteAdvertisement {
		dAtA[i] = 0x58
		i++
		if m.BgpaasSuppressRouteAdvertisement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BgpaasIpv4MappedIpv6Nexthop {
		dAtA[i] = 0x60
		i++
		if m.BgpaasIpv4MappedIpv6Nexthop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.BgpaasIpAddress) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.BgpaasIpAddress)))
		i += copy(dAtA[i:], m.BgpaasIpAddress)
	}
	if m.AutonomousSystem != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AutonomousSystem))
	}
	return i, nil
}

func (m *BGPRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRouter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n131, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n131
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n132, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n132
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n133, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n133
	}
	return i, nil
}

func (m *BGPVPN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPVPN) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n134, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n134
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n135, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n135
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n136, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n136
	}
	if m.RouteTargetList != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RouteTargetList.Size()))
		n137, err := m.RouteTargetList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n137
	}
	if m.ImportRouteTargetList != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ImportRouteTargetList.Size()))
		n138, err := m.ImportRouteTargetList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n138
	}
	if m.ExportRouteTargetList != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ExportRouteTargetList.Size()))
		n139, err := m.ExportRouteTargetList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n139
	}
	if len(m.BgpvpnType) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.BgpvpnType)))
		i += copy(dAtA[i:], m.BgpvpnType)
	}
	return i, nil
}

func (m *BridgeDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BridgeDomain) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n140, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n140
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n141, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n141
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n142, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n142
	}
	if m.MacAgingTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacAgingTime))
	}
	if m.Isid != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Isid))
	}
	if m.MacLearningEnabled {
		dAtA[i] = 0x58
		i++
		if m.MacLearningEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MacMoveControl != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacMoveControl.Size()))
		n143, err := m.MacMoveControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n143
	}
	if m.MacLimitControl != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacLimitControl.Size()))
		n144, err := m.MacLimitControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n144
	}
	return i, nil
}

func (m *ConfigNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n145, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n145
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n146, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n146
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n147, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n147
	}
	if len(m.ConfigNodeIpAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ConfigNodeIpAddress)))
		i += copy(dAtA[i:], m.ConfigNodeIpAddress)
	}
	return i, nil
}

func (m *ConfigRoot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigRoot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n148, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n148
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n149, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n149
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n150, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n150
	}
	return i, nil
}

func (m *CustomerAttachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomerAttachment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n151, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n151
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n152, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n152
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n153, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n153
	}
	return i, nil
}

func (m *DatabaseNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n154, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n154
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n155, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n155
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n156, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n156
	}
	if len(m.DatabaseNodeIpAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DatabaseNodeIpAddress)))
		i += copy(dAtA[i:], m.DatabaseNodeIpAddress)
	}
	return i, nil
}

func (m *DiscoveryServiceAssignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveryServiceAssignment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n157, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n157
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n158, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n158
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n159, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n159
	}
	return i, nil
}

func (m *Domain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Domain) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n160, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n160
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n161, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n161
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n162, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n162
	}
	if m.DomainLimits != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DomainLimits.Size()))
		n163, err := m.DomainLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n163
	}
	return i, nil
}

func (m *DsaRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DsaRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n164, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n164
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n165, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n165
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n166, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n166
	}
	if m.DsaRuleEntry != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DsaRuleEntry.Size()))
		n167, err := m.DsaRuleEntry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n167
	}
	return i, nil
}

func (m *E2ServiceProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *E2ServiceProvider) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n168, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n168
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n169, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n169
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n170, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n170
	}
	if m.E2ServiceProviderPromiscuous {
		dAtA[i] = 0x48
		i++
		if m.E2ServiceProviderPromiscuous {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FirewallPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n171, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n171
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n172, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n172
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n173, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n173
	}
	return i, nil
}

func (m *FirewallRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n174, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n174
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n175, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n175
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n176, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n176
	}
	if m.Endpoint_1 != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Endpoint_1.Size()))
		n177, err := m.Endpoint_1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n177
	}
	if m.Endpoint_2 != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Endpoint_2.Size()))
		n178, err := m.Endpoint_2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n178
	}
	if m.ActionList != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ActionList.Size()))
		n179, err := m.ActionList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n179
	}
	if m.Service != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Service.Size()))
		n180, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n180
	}
	if len(m.Direction) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Direction)))
		i += copy(dAtA[i:], m.Direction)
	}
	if m.MatchTagTypes != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MatchTagTypes.Size()))
		n181, err := m.MatchTagTypes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n181
	}
	if m.MatchTags != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MatchTags.Size()))
		n182, err := m.MatchTags.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n182
	}
	return i, nil
}

func (m *FloatingIPPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatingIPPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n183, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n183
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n184, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n184
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n185, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n185
	}
	if m.FloatingIpPoolSubnets != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FloatingIpPoolSubnets.Size()))
		n186, err := m.FloatingIpPoolSubnets.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n186
	}
	return i, nil
}

func (m *FloatingIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatingIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n187, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n187
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n188, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n188
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n189, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n189
	}
	if len(m.FloatingIpAddressFamily) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.FloatingIpAddressFamily)))
		i += copy(dAtA[i:], m.FloatingIpAddressFamily)
	}
	if m.FloatingIpPortMappings != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FloatingIpPortMappings.Size()))
		n190, err := m.FloatingIpPortMappings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n190
	}
	if m.FloatingIpIsVirtualIp {
		dAtA[i] = 0x58
		i++
		if m.FloatingIpIsVirtualIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FloatingIpAddress) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.FloatingIpAddress)))
		i += copy(dAtA[i:], m.FloatingIpAddress)
	}
	if m.FloatingIpPortMappingsEnable {
		dAtA[i] = 0x68
		i++
		if m.FloatingIpPortMappingsEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FloatingIpFixedIpAddress) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.FloatingIpFixedIpAddress)))
		i += copy(dAtA[i:], m.FloatingIpFixedIpAddress)
	}
	if len(m.FloatingIpTrafficDirection) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.FloatingIpTrafficDirection)))
		i += copy(dAtA[i:], m.FloatingIpTrafficDirection)
	}
	return i, nil
}

func (m *ForwardingClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardingClass) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n191, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n191
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n192, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n192
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n193, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n193
	}
	if m.ForwardingClassDscp != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ForwardingClassDscp))
	}
	if m.ForwardingClassVlanPriority != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ForwardingClassVlanPriority))
	}
	if m.ForwardingClassMplsExp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ForwardingClassMplsExp))
	}
	if m.ForwardingClassId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ForwardingClassId))
	}
	return i, nil
}

func (m *GlobalQosConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalQosConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n194, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n194
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n195, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n195
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n196, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n196
	}
	if m.ControlTrafficDscp != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ControlTrafficDscp.Size()))
		n197, err := m.ControlTrafficDscp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n197
	}
	return i, nil
}

func (m *GlobalSystemConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSystemConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n198, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n198
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n199, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n199
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n200, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n200
	}
	if len(m.ConfigVersion) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ConfigVersion)))
		i += copy(dAtA[i:], m.ConfigVersion)
	}
	if m.BgpaasParameters != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.BgpaasParameters.Size()))
		n201, err := m.BgpaasParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n201
	}
	if m.AlarmEnable {
		dAtA[i] = 0x58
		i++
		if m.AlarmEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MacMoveControl != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacMoveControl.Size()))
		n202, err := m.MacMoveControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n202
	}
	if m.PluginTuning != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PluginTuning.Size()))
		n203, err := m.PluginTuning.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n203
	}
	if m.IbgpAutoMesh {
		dAtA[i] = 0x70
		i++
		if m.IbgpAutoMesh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MacAgingTime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacAgingTime))
	}
	if m.BgpAlwaysCompareMed {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.BgpAlwaysCompareMed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserDefinedLogStatistics != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.UserDefinedLogStatistics.Size()))
		n204, err := m.UserDefinedLogStatistics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n204
	}
	if m.GracefulRestartParameters != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.GracefulRestartParameters.Size()))
		n205, err := m.GracefulRestartParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n205
	}
	if m.IpFabricSubnets != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IpFabricSubnets.Size()))
		n206, err := m.IpFabricSubnets.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n206
	}
	if m.AutonomousSystem != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AutonomousSystem))
	}
	if m.MacLimitControl != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacLimitControl.Size()))
		n207, err := m.MacLimitControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n207
	}
	return i, nil
}

func (m *GlobalVrouterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalVrouterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n208, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n208
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n209, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n209
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n210, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n210
	}
	if m.EcmpHashingIncludeFields != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.EcmpHashingIncludeFields.Size()))
		n211, err := m.EcmpHashingIncludeFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n211
	}
	if m.FlowAgingTimeoutList != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FlowAgingTimeoutList.Size()))
		n212, err := m.FlowAgingTimeoutList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n212
	}
	if len(m.ForwardingMode) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ForwardingMode)))
		i += copy(dAtA[i:], m.ForwardingMode)
	}
	if m.FlowExportRate != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FlowExportRate))
	}
	if m.LinklocalServices != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LinklocalServices.Size()))
		n213, err := m.LinklocalServices.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n213
	}
	if m.EncapsulationPriorities != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.EncapsulationPriorities.Size()))
		n214, err := m.EncapsulationPriorities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n214
	}
	if len(m.VxlanNetworkIdentifierMode) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VxlanNetworkIdentifierMode)))
		i += copy(dAtA[i:], m.VxlanNetworkIdentifierMode)
	}
	if m.EnableSecurityLogging {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.EnableSecurityLogging {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InstanceIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n215, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n215
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n216, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n216
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n217, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n217
	}
	if m.ServiceHealthCheckIp {
		dAtA[i] = 0x48
		i++
		if m.ServiceHealthCheckIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SecondaryIpTrackingIp != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecondaryIpTrackingIp.Size()))
		n218, err := m.SecondaryIpTrackingIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n218
	}
	if len(m.InstanceIpAddress) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.InstanceIpAddress)))
		i += copy(dAtA[i:], m.InstanceIpAddress)
	}
	if len(m.InstanceIpMode) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.InstanceIpMode)))
		i += copy(dAtA[i:], m.InstanceIpMode)
	}
	if len(m.SubnetUuid) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SubnetUuid)))
		i += copy(dAtA[i:], m.SubnetUuid)
	}
	if len(m.InstanceIpFamily) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.InstanceIpFamily)))
		i += copy(dAtA[i:], m.InstanceIpFamily)
	}
	if m.ServiceInstanceIp {
		dAtA[i] = 0x78
		i++
		if m.ServiceInstanceIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InstanceIpLocalIp {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.InstanceIpLocalIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InstanceIpSecondary {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.InstanceIpSecondary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InterfaceRouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceRouteTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n219, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n219
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n220, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n220
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n221, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n221
	}
	if m.InterfaceRouteTableRoutes != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.InterfaceRouteTableRoutes.Size()))
		n222, err := m.InterfaceRouteTableRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n222
	}
	return i, nil
}

func (m *LoadbalancerHealthmonitor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerHealthmonitor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n223, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n223
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n224, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n224
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n225, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n225
	}
	if m.LoadbalancerHealthmonitorProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerHealthmonitorProperties.Size()))
		n226, err := m.LoadbalancerHealthmonitorProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n226
	}
	return i, nil
}

func (m *LoadbalancerListener) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerListener) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n227, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n227
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n228, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n228
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n229, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n229
	}
	if m.LoadbalancerListenerProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerListenerProperties.Size()))
		n230, err := m.LoadbalancerListenerProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n230
	}
	return i, nil
}

func (m *LoadbalancerMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n231, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n231
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n232, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n232
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n233, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n233
	}
	if m.LoadbalancerMemberProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerMemberProperties.Size()))
		n234, err := m.LoadbalancerMemberProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n234
	}
	return i, nil
}

func (m *LoadbalancerPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n235, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n235
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n236, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n236
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n237, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n237
	}
	if m.LoadbalancerPoolProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerPoolProperties.Size()))
		n238, err := m.LoadbalancerPoolProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n238
	}
	if m.LoadbalancerPoolCustomAttributes != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerPoolCustomAttributes.Size()))
		n239, err := m.LoadbalancerPoolCustomAttributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n239
	}
	if len(m.LoadbalancerPoolProvider) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LoadbalancerPoolProvider)))
		i += copy(dAtA[i:], m.LoadbalancerPoolProvider)
	}
	return i, nil
}

func (m *Loadbalancer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Loadbalancer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n240, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n240
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n241, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n241
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n242, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n242
	}
	if m.LoadbalancerProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerProperties.Size()))
		n243, err := m.LoadbalancerProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n243
	}
	if len(m.LoadbalancerProvider) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LoadbalancerProvider)))
		i += copy(dAtA[i:], m.LoadbalancerProvider)
	}
	return i, nil
}

func (m *LogicalInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalInterface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n244, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n244
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n245, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n245
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n246, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n246
	}
	if m.LogicalInterfaceVlanTag != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LogicalInterfaceVlanTag))
	}
	if len(m.LogicalInterfaceType) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LogicalInterfaceType)))
		i += copy(dAtA[i:], m.LogicalInterfaceType)
	}
	return i, nil
}

func (m *LogicalRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalRouter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n247, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n247
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n248, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n248
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n249, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n249
	}
	if len(m.VxlanNetworkIdentifier) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VxlanNetworkIdentifier)))
		i += copy(dAtA[i:], m.VxlanNetworkIdentifier)
	}
	if m.ConfiguredRouteTargetList != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ConfiguredRouteTargetList.Size()))
		n250, err := m.ConfiguredRouteTargetList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n250
	}
	return i, nil
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n251, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n251
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n252, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n252
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n253, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n253
	}
	if m.NamespaceCidr != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NamespaceCidr.Size()))
		n254, err := m.NamespaceCidr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n254
	}
	return i, nil
}

func (m *NetworkDeviceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkDeviceConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n255, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n255
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n256, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n256
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n257, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n257
	}
	return i, nil
}

func (m *NetworkIpam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkIpam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n258, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n258
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n259, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n259
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n260, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n260
	}
	if m.NetworkIpamMgmt != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NetworkIpamMgmt.Size()))
		n261, err := m.NetworkIpamMgmt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n261
	}
	if m.IpamSubnets != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IpamSubnets.Size()))
		n262, err := m.IpamSubnets.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n262
	}
	if len(m.IpamSubnetMethod) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpamSubnetMethod)))
		i += copy(dAtA[i:], m.IpamSubnetMethod)
	}
	return i, nil
}

func (m *NetworkPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n263, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n263
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n264, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n264
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n265, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n265
	}
	if m.NetworkPolicyEntries != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NetworkPolicyEntries.Size()))
		n266, err := m.NetworkPolicyEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n266
	}
	return i, nil
}

func (m *PeeringPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeeringPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n267, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n267
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n268, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n268
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n269, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n269
	}
	if len(m.PeeringService) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PeeringService)))
		i += copy(dAtA[i:], m.PeeringService)
	}
	return i, nil
}

func (m *PhysicalInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalInterface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n270, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n270
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n271, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n271
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n272, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n272
	}
	if len(m.EthernetSegmentIdentifier) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.EthernetSegmentIdentifier)))
		i += copy(dAtA[i:], m.EthernetSegmentIdentifier)
	}
	return i, nil
}

func (m *PhysicalRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalRouter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n273, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n273
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n274, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n274
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n275, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n275
	}
	if len(m.PhysicalRouterManagementIp) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PhysicalRouterManagementIp)))
		i += copy(dAtA[i:], m.PhysicalRouterManagementIp)
	}
	if m.PhysicalRouterSnmpCredentials != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PhysicalRouterSnmpCredentials.Size()))
		n276, err := m.PhysicalRouterSnmpCredentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n276
	}
	if len(m.PhysicalRouterRole) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PhysicalRouterRole)))
		i += copy(dAtA[i:], m.PhysicalRouterRole)
	}
	if m.PhysicalRouterUserCredentials != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PhysicalRouterUserCredentials.Size()))
		n277, err := m.PhysicalRouterUserCredentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n277
	}
	if len(m.PhysicalRouterVendorName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PhysicalRouterVendorName)))
		i += copy(dAtA[i:], m.PhysicalRouterVendorName)
	}
	if m.PhysicalRouterVncManaged {
		dAtA[i] = 0x70
		i++
		if m.PhysicalRouterVncManaged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PhysicalRouterProductName) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PhysicalRouterProductName)))
		i += copy(dAtA[i:], m.PhysicalRouterProductName)
	}
	if m.PhysicalRouterLldp {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.PhysicalRouterLldp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PhysicalRouterLoopbackIp) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PhysicalRouterLoopbackIp)))
		i += copy(dAtA[i:], m.PhysicalRouterLoopbackIp)
	}
	if len(m.PhysicalRouterImageUri) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PhysicalRouterImageUri)))
		i += copy(dAtA[i:], m.PhysicalRouterImageUri)
	}
	if m.TelemetryInfo != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.TelemetryInfo.Size()))
		n278, err := m.TelemetryInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n278
	}
	if m.PhysicalRouterSnmp {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.PhysicalRouterSnmp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PhysicalRouterDataplaneIp) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PhysicalRouterDataplaneIp)))
		i += copy(dAtA[i:], m.PhysicalRouterDataplaneIp)
	}
	if m.PhysicalRouterJunosServicePorts != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PhysicalRouterJunosServicePorts.Size()))
		n279, err := m.PhysicalRouterJunosServicePorts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n279
	}
	return i, nil
}

func (m *PolicyManagement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyManagement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n280, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n280
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n281, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n281
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n282, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n282
	}
	return i, nil
}

func (m *PortTuple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortTuple) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n283, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n283
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n284, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n284
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n285, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n285
	}
	return i, nil
}

func (m *Project) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Project) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n286, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n286
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n287, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n287
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n288, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n288
	}
	if m.VxlanRouting {
		dAtA[i] = 0x48
		i++
		if m.VxlanRouting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AlarmEnable {
		dAtA[i] = 0x50
		i++
		if m.AlarmEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Quota != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Quota.Size()))
		n289, err := m.Quota.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n289
	}
	return i, nil
}

func (m *ProviderAttachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderAttachment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n290, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n290
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n291, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n291
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n292, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n292
	}
	return i, nil
}

func (m *QosConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n293, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n293
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n294, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n294
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n295, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n295
	}
	if len(m.QosConfigType) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.QosConfigType)))
		i += copy(dAtA[i:], m.QosConfigType)
	}
	if m.MplsExpEntries != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MplsExpEntries.Size()))
		n296, err := m.MplsExpEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n296
	}
	if m.VlanPriorityEntries != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VlanPriorityEntries.Size()))
		n297, err := m.VlanPriorityEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n297
	}
	if m.DefaultForwardingClassId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DefaultForwardingClassId))
	}
	if m.DscpEntries != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DscpEntries.Size()))
		n298, err := m.DscpEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n298
	}
	return i, nil
}

func (m *QosQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosQueue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n299, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n299
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n300, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n300
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n301, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n301
	}
	if m.QosQueueIdentifier != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.QosQueueIdentifier))
	}
	if m.MaxBandwidth != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MaxBandwidth))
	}
	if m.MinBandwidth != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MinBandwidth))
	}
	return i, nil
}

func (m *RouteAggregate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAggregate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n302, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n302
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n303, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n303
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n304, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n304
	}
	return i, nil
}

func (m *RouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n305, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n305
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n306, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n306
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n307, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n307
	}
	if m.Routes != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Routes.Size()))
		n308, err := m.Routes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n308
	}
	return i, nil
}

func (m *RouteTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTarget) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n309, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n309
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n310, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n310
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n311, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n311
	}
	return i, nil
}

func (m *RoutingInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingInstance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n312, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n312
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n313, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n313
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n314, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n314
	}
	return i, nil
}

func (m *RoutingPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n315, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n315
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n316, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n316
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n317, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n317
	}
	return i, nil
}

func (m *SecurityGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n318, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n318
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n319, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n319
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n320, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n320
	}
	if m.SecurityGroupEntries != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityGroupEntries.Size()))
		n321, err := m.SecurityGroupEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n321
	}
	if m.ConfiguredSecurityGroupId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ConfiguredSecurityGroupId))
	}
	if m.SecurityGroupId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityGroupId))
	}
	return i, nil
}

func (m *SecurityLoggingObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityLoggingObject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n322, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n322
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n323, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n323
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n324, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n324
	}
	if m.SecurityLoggingObjectRules != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityLoggingObjectRules.Size()))
		n325, err := m.SecurityLoggingObjectRules.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n325
	}
	if m.SecurityLoggingObjectRate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityLoggingObjectRate))
	}
	return i, nil
}

func (m *ServiceAppliance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceAppliance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n326, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n326
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n327, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n327
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n328, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n328
	}
	if m.ServiceApplianceUserCredentials != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceApplianceUserCredentials.Size()))
		n329, err := m.ServiceApplianceUserCredentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n329
	}
	if len(m.ServiceApplianceIpAddress) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceApplianceIpAddress)))
		i += copy(dAtA[i:], m.ServiceApplianceIpAddress)
	}
	if m.ServiceApplianceProperties != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceApplianceProperties.Size()))
		n330, err := m.ServiceApplianceProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n330
	}
	return i, nil
}

func (m *ServiceApplianceSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceApplianceSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n331, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n331
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n332, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n332
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n333, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n333
	}
	if m.ServiceApplianceSetProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceApplianceSetProperties.Size()))
		n334, err := m.ServiceApplianceSetProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n334
	}
	if len(m.ServiceApplianceHaMode) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceApplianceHaMode)))
		i += copy(dAtA[i:], m.ServiceApplianceHaMode)
	}
	if len(m.ServiceApplianceDriver) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceApplianceDriver)))
		i += copy(dAtA[i:], m.ServiceApplianceDriver)
	}
	return i, nil
}

func (m *ServiceConnectionModule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConnectionModule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n335, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n335
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n336, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n336
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n337, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n337
	}
	if len(m.ServiceType) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceType)))
		i += copy(dAtA[i:], m.ServiceType)
	}
	if len(m.E2Service) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.E2Service)))
		i += copy(dAtA[i:], m.E2Service)
	}
	return i, nil
}

func (m *ServiceEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceEndpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n338, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n338
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n339, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n339
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n340, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n340
	}
	return i, nil
}

func (m *ServiceGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n341, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n341
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n342, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n342
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n343, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n343
	}
	if m.ServiceGroupFirewallServiceList != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceGroupFirewallServiceList.Size()))
		n344, err := m.ServiceGroupFirewallServiceList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n344
	}
	return i, nil
}

func (m *ServiceHealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n345, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n345
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n346, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n346
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n347, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n347
	}
	if m.ServiceHealthCheckProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceHealthCheckProperties.Size()))
		n348, err := m.ServiceHealthCheckProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n348
	}
	return i, nil
}

func (m *ServiceInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceInstance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n349, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n349
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n350, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n350
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n351, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n351
	}
	if m.ServiceInstanceBindings != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceInstanceBindings.Size()))
		n352, err := m.ServiceInstanceBindings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n352
	}
	if m.ServiceInstanceProperties != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceInstanceProperties.Size()))
		n353, err := m.ServiceInstanceProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n353
	}
	return i, nil
}

func (m *ServiceObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceObject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n354, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n354
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n355, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n355
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n356, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n356
	}
	return i, nil
}

func (m *ServiceTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceTemplate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n357, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n357
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n358, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n358
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n359, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n359
	}
	if m.ServiceTemplateProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceTemplateProperties.Size()))
		n360, err := m.ServiceTemplateProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n360
	}
	return i, nil
}

func (m *Subnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subnet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n361, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n361
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n362, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n362
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n363, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n363
	}
	if m.SubnetIpPrefix != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SubnetIpPrefix.Size()))
		n364, err := m.SubnetIpPrefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n364
	}
	return i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n365, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n365
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n366, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n366
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n367, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n367
	}
	if len(m.TagTypeName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.TagTypeName)))
		i += copy(dAtA[i:], m.TagTypeName)
	}
	if len(m.TagId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.TagId)))
		i += copy(dAtA[i:], m.TagId)
	}
	if len(m.TagValue) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.TagValue)))
		i += copy(dAtA[i:], m.TagValue)
	}
	return i, nil
}

func (m *TagType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n368, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n368
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n369, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n369
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n370, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n370
	}
	if len(m.TagTypeId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.TagTypeId)))
		i += copy(dAtA[i:], m.TagTypeId)
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n371, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n371
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n372, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n372
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n373, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n373
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *VirtualDNSRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualDNSRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n374, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n374
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n375, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n375
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n376, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n376
	}
	if m.Virtual_DNSRecordData != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Virtual_DNSRecordData.Size()))
		n377, err := m.Virtual_DNSRecordData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n377
	}
	return i, nil
}

func (m *VirtualDNS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualDNS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n378, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n378
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n379, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n379
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n380, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n380
	}
	if m.Virtual_DNSData != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Virtual_DNSData.Size()))
		n381, err := m.Virtual_DNSData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n381
	}
	return i, nil
}

func (m *VirtualIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n382, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n382
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n383, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n383
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n384, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n384
	}
	if m.VirtualIpProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualIpProperties.Size()))
		n385, err := m.VirtualIpProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n385
	}
	return i, nil
}

func (m *VirtualMachineInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualMachineInterface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n386, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n386
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n387, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n387
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n388, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n388
	}
	if m.EcmpHashingIncludeFields != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.EcmpHashingIncludeFields.Size()))
		n389, err := m.EcmpHashingIncludeFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n389
	}
	if m.VirtualMachineInterfaceHostRoutes != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachineInterfaceHostRoutes.Size()))
		n390, err := m.VirtualMachineInterfaceHostRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n390
	}
	if m.VirtualMachineInterfaceMacAddresses != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachineInterfaceMacAddresses.Size()))
		n391, err := m.VirtualMachineInterfaceMacAddresses.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n391
	}
	if m.VirtualMachineInterfaceDhcpOptionList != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachineInterfaceDhcpOptionList.Size()))
		n392, err := m.VirtualMachineInterfaceDhcpOptionList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n392
	}
	if m.VirtualMachineInterfaceBindings != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachineInterfaceBindings.Size()))
		n393, err := m.VirtualMachineInterfaceBindings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n393
	}
	if m.VirtualMachineInterfaceDisablePolicy {
		dAtA[i] = 0x70
		i++
		if m.VirtualMachineInterfaceDisablePolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VirtualMachineInterfaceAllowedAddressPairs != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachineInterfaceAllowedAddressPairs.Size()))
		n394, err := m.VirtualMachineInterfaceAllowedAddressPairs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n394
	}
	if m.VirtualMachineInterfaceFatFlowProtocols != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachineInterfaceFatFlowProtocols.Size()))
		n395, err := m.VirtualMachineInterfaceFatFlowProtocols.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n395
	}
	if m.VlanTagBasedBridgeDomain {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.VlanTagBasedBridgeDomain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VirtualMachineInterfaceDeviceOwner) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VirtualMachineInterfaceDeviceOwner)))
		i += copy(dAtA[i:], m.VirtualMachineInterfaceDeviceOwner)
	}
	if m.VrfAssignTable != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VrfAssignTable.Size()))
		n396, err := m.VrfAssignTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n396
	}
	if m.PortSecurityEnabled {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.PortSecurityEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VirtualMachineInterfaceProperties != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachineInterfaceProperties.Size()))
		n397, err := m.VirtualMachineInterfaceProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n397
	}
	return i, nil
}

func (m *VirtualMachine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualMachine) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n398, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n398
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n399, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n399
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n400, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n400
	}
	return i, nil
}

func (m *VirtualNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n401, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n401
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n402, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n402
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n403, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n403
	}
	if m.VirtualNetworkProperties != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualNetworkProperties.Size()))
		n404, err := m.VirtualNetworkProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n404
	}
	if m.EcmpHashingIncludeFields != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.EcmpHashingIncludeFields.Size()))
		n405, err := m.EcmpHashingIncludeFields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n405
	}
	if m.VirtualNetworkNetworkId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualNetworkNetworkId))
	}
	if len(m.AddressAllocationMode) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AddressAllocationMode)))
		i += copy(dAtA[i:], m.AddressAllocationMode)
	}
	if m.PbbEvpnEnable {
		dAtA[i] = 0x68
		i++
		if m.PbbEvpnEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RouterExternal {
		dAtA[i] = 0x70
		i++
		if m.RouterExternal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ImportRouteTargetList != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ImportRouteTargetList.Size()))
		n406, err := m.ImportRouteTargetList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n406
	}
	if m.MacAgingTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacAgingTime))
	}
	if m.ProviderProperties != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProviderProperties.Size()))
		n407, err := m.ProviderProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n407
	}
	if m.RouteTargetList != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RouteTargetList.Size()))
		n408, err := m.RouteTargetList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n408
	}
	if m.MacLearningEnabled {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.MacLearningEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExportRouteTargetList != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ExportRouteTargetList.Size()))
		n409, err := m.ExportRouteTargetList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n409
	}
	if m.FloodUnknownUnicast {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.FloodUnknownUnicast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PbbEtreeEnable {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.PbbEtreeEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Layer2ControlWord {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.Layer2ControlWord {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExternalIpam {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.ExternalIpam {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PortSecurityEnabled {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if m.PortSecurityEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MacMoveControl != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacMoveControl.Size()))
		n410, err := m.MacMoveControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n410
	}
	if m.MultiPolicyServiceChainsEnabled {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.MultiPolicyServiceChainsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MacLimitControl != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacLimitControl.Size()))
		n411, err := m.MacLimitControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n411
	}
	if m.IsShared {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		if m.IsShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *VirtualRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualRouter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n412, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n412
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n413, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n413
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n414, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n414
	}
	if m.VirtualRouterDpdkEnabled {
		dAtA[i] = 0x48
		i++
		if m.VirtualRouterDpdkEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VirtualRouterType) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VirtualRouterType)))
		i += copy(dAtA[i:], m.VirtualRouterType)
	}
	if len(m.VirtualRouterIpAddress) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VirtualRouterIpAddress)))
		i += copy(dAtA[i:], m.VirtualRouterIpAddress)
	}
	return i, nil
}

func (m *AppformixNodeRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppformixNodeRole) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n415, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n415
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n416, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n416
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n417, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n417
	}
	return i, nil
}

func (m *BaremetalNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaremetalNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n418, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n418
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n419, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n419
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n420, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n420
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.IpmiAddress) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpmiAddress)))
		i += copy(dAtA[i:], m.IpmiAddress)
	}
	if len(m.IpmiUsername) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpmiUsername)))
		i += copy(dAtA[i:], m.IpmiUsername)
	}
	if len(m.IpmiPassword) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpmiPassword)))
		i += copy(dAtA[i:], m.IpmiPassword)
	}
	if m.CpuCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.CpuCount))
	}
	if len(m.CpuArch) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.CpuArch)))
		i += copy(dAtA[i:], m.CpuArch)
	}
	if m.DiskGb != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DiskGb))
	}
	if m.MemoryMb != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MemoryMb))
	}
	if len(m.DeployKernel) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DeployKernel)))
		i += copy(dAtA[i:], m.DeployKernel)
	}
	if len(m.DeployRamdisk) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DeployRamdisk)))
		i += copy(dAtA[i:], m.DeployRamdisk)
	}
	return i, nil
}

func (m *BaremetalPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaremetalPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n421, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n421
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n422, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n422
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n423, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n423
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.Node) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.SwitchId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SwitchId)))
		i += copy(dAtA[i:], m.SwitchId)
	}
	if len(m.PortId) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PortId)))
		i += copy(dAtA[i:], m.PortId)
	}
	if len(m.SwitchInfo) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SwitchInfo)))
		i += copy(dAtA[i:], m.SwitchInfo)
	}
	if m.PxeEnabled {
		dAtA[i] = 0x70
		i++
		if m.PxeEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ContrailAnalyticsDatabaseNodeRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContrailAnalyticsDatabaseNodeRole) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n424, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n424
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n425, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n425
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n426, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n426
	}
	return i, nil
}

func (m *ContrailAnalyticsNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContrailAnalyticsNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n427, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n427
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n428, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n428
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n429, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n429
	}
	return i, nil
}

func (m *ContrailCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContrailCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n430, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n430
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n431, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n431
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n432, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n432
	}
	if len(m.ConfigAuditTtl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ConfigAuditTtl)))
		i += copy(dAtA[i:], m.ConfigAuditTtl)
	}
	if len(m.ContrailWebui) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ContrailWebui)))
		i += copy(dAtA[i:], m.ContrailWebui)
	}
	if len(m.DataTtl) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DataTtl)))
		i += copy(dAtA[i:], m.DataTtl)
	}
	if len(m.DefaultGateway) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultGateway)))
		i += copy(dAtA[i:], m.DefaultGateway)
	}
	if len(m.DefaultVrouterBondInterface) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultVrouterBondInterface)))
		i += copy(dAtA[i:], m.DefaultVrouterBondInterface)
	}
	if len(m.DefaultVrouterBondInterfaceMembers) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultVrouterBondInterfaceMembers)))
		i += copy(dAtA[i:], m.DefaultVrouterBondInterfaceMembers)
	}
	if len(m.FlowTtl) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.FlowTtl)))
		i += copy(dAtA[i:], m.FlowTtl)
	}
	if len(m.StatisticsTtl) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.StatisticsTtl)))
		i += copy(dAtA[i:], m.StatisticsTtl)
	}
	return i, nil
}

func (m *ContrailControllerNodeRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContrailControllerNodeRole) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n433, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n433
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n434, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n434
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n435, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n435
	}
	return i, nil
}

func (m *ControllerNodeRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerNodeRole) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n436, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n436
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n437, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n437
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n438, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n438
	}
	if len(m.CapacityDrives) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.CapacityDrives)))
		i += copy(dAtA[i:], m.CapacityDrives)
	}
	if len(m.InternalapiBondInterfaceMembers) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.InternalapiBondInterfaceMembers)))
		i += copy(dAtA[i:], m.InternalapiBondInterfaceMembers)
	}
	if len(m.PerformanceDrives) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PerformanceDrives)))
		i += copy(dAtA[i:], m.PerformanceDrives)
	}
	if len(m.StorageManagementBondInterfaceMembers) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.StorageManagementBondInterfaceMembers)))
		i += copy(dAtA[i:], m.StorageManagementBondInterfaceMembers)
	}
	return i, nil
}

func (m *Dashboard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dashboard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n439, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n439
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n440, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n440
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n441, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n441
	}
	if len(m.ContainerConfig) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ContainerConfig)))
		i += copy(dAtA[i:], m.ContainerConfig)
	}
	return i, nil
}

func (m *Keypair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keypair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n442, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n442
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n443, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n443
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n444, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n444
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	return i, nil
}

func (m *KubernetesCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n445, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n445
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n446, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n446
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n447, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n447
	}
	if len(m.ContrailClusterId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ContrailClusterId)))
		i += copy(dAtA[i:], m.ContrailClusterId)
	}
	if len(m.KuberunetesDashboard) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.KuberunetesDashboard)))
		i += copy(dAtA[i:], m.KuberunetesDashboard)
	}
	return i, nil
}

func (m *KubernetesNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n448, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n448
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n449, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n449
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n450, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n450
	}
	return i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n451, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n451
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n452, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n452
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n453, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n453
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.PrivateDnsServers) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateDnsServers)))
		i += copy(dAtA[i:], m.PrivateDnsServers)
	}
	if len(m.PrivateNtpHosts) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateNtpHosts)))
		i += copy(dAtA[i:], m.PrivateNtpHosts)
	}
	if len(m.PrivateOspdPackageUrl) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateOspdPackageUrl)))
		i += copy(dAtA[i:], m.PrivateOspdPackageUrl)
	}
	if len(m.PrivateOspdUserName) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateOspdUserName)))
		i += copy(dAtA[i:], m.PrivateOspdUserName)
	}
	if len(m.PrivateOspdUserPassword) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateOspdUserPassword)))
		i += copy(dAtA[i:], m.PrivateOspdUserPassword)
	}
	if len(m.PrivateOspdVmDiskGb) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateOspdVmDiskGb)))
		i += copy(dAtA[i:], m.PrivateOspdVmDiskGb)
	}
	if len(m.PrivateOspdVmName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateOspdVmName)))
		i += copy(dAtA[i:], m.PrivateOspdVmName)
	}
	if len(m.PrivateOspdVmRamMb) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateOspdVmRamMb)))
		i += copy(dAtA[i:], m.PrivateOspdVmRamMb)
	}
	if len(m.PrivateOspdVmVcpus) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateOspdVmVcpus)))
		i += copy(dAtA[i:], m.PrivateOspdVmVcpus)
	}
	if len(m.PrivateRedhatPoolId) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateRedhatPoolId)))
		i += copy(dAtA[i:], m.PrivateRedhatPoolId)
	}
	if len(m.PrivateRedhatSubscriptionKey) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateRedhatSubscriptionKey)))
		i += copy(dAtA[i:], m.PrivateRedhatSubscriptionKey)
	}
	if len(m.PrivateRedhatSubscriptionPasword) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateRedhatSubscriptionPasword)))
		i += copy(dAtA[i:], m.PrivateRedhatSubscriptionPasword)
	}
	if len(m.PrivateRedhatSubscriptionUser) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateRedhatSubscriptionUser)))
		i += copy(dAtA[i:], m.PrivateRedhatSubscriptionUser)
	}
	if len(m.GcpAccountInfo) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.GcpAccountInfo)))
		i += copy(dAtA[i:], m.GcpAccountInfo)
	}
	if m.GcpAsn != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.GcpAsn))
	}
	if len(m.GcpRegion) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.GcpRegion)))
		i += copy(dAtA[i:], m.GcpRegion)
	}
	if len(m.GcpSubnet) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.GcpSubnet)))
		i += copy(dAtA[i:], m.GcpSubnet)
	}
	if len(m.AwsAccessKey) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AwsAccessKey)))
		i += copy(dAtA[i:], m.AwsAccessKey)
	}
	if len(m.AwsRegion) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AwsRegion)))
		i += copy(dAtA[i:], m.AwsRegion)
	}
	if len(m.AwsSecretKey) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AwsSecretKey)))
		i += copy(dAtA[i:], m.AwsSecretKey)
	}
	if len(m.AwsSubnet) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AwsSubnet)))
		i += copy(dAtA[i:], m.AwsSubnet)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n454, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n454
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n455, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n455
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n456, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n456
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.SshKey) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SshKey)))
		i += copy(dAtA[i:], m.SshKey)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.AwsAmi) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AwsAmi)))
		i += copy(dAtA[i:], m.AwsAmi)
	}
	if len(m.AwsInstanceType) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AwsInstanceType)))
		i += copy(dAtA[i:], m.AwsInstanceType)
	}
	if len(m.GcpImage) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.GcpImage)))
		i += copy(dAtA[i:], m.GcpImage)
	}
	if len(m.GcpMachineType) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.GcpMachineType)))
		i += copy(dAtA[i:], m.GcpMachineType)
	}
	if len(m.PrivateMachineProperties) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateMachineProperties)))
		i += copy(dAtA[i:], m.PrivateMachineProperties)
	}
	if len(m.PrivateMachineState) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivateMachineState)))
		i += copy(dAtA[i:], m.PrivateMachineState)
	}
	if len(m.PrivatePowerManagementIp) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivatePowerManagementIp)))
		i += copy(dAtA[i:], m.PrivatePowerManagementIp)
	}
	if len(m.PrivatePowerManagementPassword) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivatePowerManagementPassword)))
		i += copy(dAtA[i:], m.PrivatePowerManagementPassword)
	}
	if len(m.PrivatePowerManagementUsername) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PrivatePowerManagementUsername)))
		i += copy(dAtA[i:], m.PrivatePowerManagementUsername)
	}
	return i, nil
}

func (m *OpenstackCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenstackCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n457, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n457
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n458, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n458
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n459, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n459
	}
	if len(m.AdminPassword) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AdminPassword)))
		i += copy(dAtA[i:], m.AdminPassword)
	}
	if len(m.ContrailClusterId) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ContrailClusterId)))
		i += copy(dAtA[i:], m.ContrailClusterId)
	}
	if len(m.DefaultCapacityDrives) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultCapacityDrives)))
		i += copy(dAtA[i:], m.DefaultCapacityDrives)
	}
	if len(m.DefaultJournalDrives) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultJournalDrives)))
		i += copy(dAtA[i:], m.DefaultJournalDrives)
	}
	if len(m.DefaultOsdDrives) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultOsdDrives)))
		i += copy(dAtA[i:], m.DefaultOsdDrives)
	}
	if len(m.DefaultPerformanceDrives) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultPerformanceDrives)))
		i += copy(dAtA[i:], m.DefaultPerformanceDrives)
	}
	if len(m.DefaultStorageAccessBondInterfaceMembers) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultStorageAccessBondInterfaceMembers)))
		i += copy(dAtA[i:], m.DefaultStorageAccessBondInterfaceMembers)
	}
	if len(m.DefaultStorageBackendBondInterfaceMembers) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultStorageBackendBondInterfaceMembers)))
		i += copy(dAtA[i:], m.DefaultStorageBackendBondInterfaceMembers)
	}
	if len(m.ExternalAllocationPoolEnd) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ExternalAllocationPoolEnd)))
		i += copy(dAtA[i:], m.ExternalAllocationPoolEnd)
	}
	if len(m.ExternalAllocationPoolStart) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ExternalAllocationPoolStart)))
		i += copy(dAtA[i:], m.ExternalAllocationPoolStart)
	}
	if len(m.ExternalNetCidr) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ExternalNetCidr)))
		i += copy(dAtA[i:], m.ExternalNetCidr)
	}
	if len(m.OpenstackWebui) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.OpenstackWebui)))
		i += copy(dAtA[i:], m.OpenstackWebui)
	}
	if len(m.PublicGateway) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PublicGateway)))
		i += copy(dAtA[i:], m.PublicGateway)
	}
	if len(m.PublicIp) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PublicIp)))
		i += copy(dAtA[i:], m.PublicIp)
	}
	return i, nil
}

func (m *OpenstackComputeNodeRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenstackComputeNodeRole) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n460, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n460
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n461, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n461
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n462, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n462
	}
	if len(m.DefaultGateway) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultGateway)))
		i += copy(dAtA[i:], m.DefaultGateway)
	}
	if len(m.VrouterBondInterface) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VrouterBondInterface)))
		i += copy(dAtA[i:], m.VrouterBondInterface)
	}
	if len(m.VrouterBondInterfaceMembers) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VrouterBondInterfaceMembers)))
		i += copy(dAtA[i:], m.VrouterBondInterfaceMembers)
	}
	if len(m.VrouterType) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VrouterType)))
		i += copy(dAtA[i:], m.VrouterType)
	}
	return i, nil
}

func (m *OpenstackStorageNodeRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenstackStorageNodeRole) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n463, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n463
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n464, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n464
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n465, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n465
	}
	if len(m.JournalDrives) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.JournalDrives)))
		i += copy(dAtA[i:], m.JournalDrives)
	}
	if len(m.OsdDrives) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.OsdDrives)))
		i += copy(dAtA[i:], m.OsdDrives)
	}
	if len(m.StorageAccessBondInterfaceMembers) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.StorageAccessBondInterfaceMembers)))
		i += copy(dAtA[i:], m.StorageAccessBondInterfaceMembers)
	}
	if len(m.StorageBackendBondInterfaceMembers) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.StorageBackendBondInterfaceMembers)))
		i += copy(dAtA[i:], m.StorageBackendBondInterfaceMembers)
	}
	return i, nil
}

func (m *VPNGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPNGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProvisioningLog) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningLog)))
		i += copy(dAtA[i:], m.ProvisioningLog)
	}
	if m.ProvisioningProgress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProvisioningProgress))
	}
	if len(m.ProvisioningProgressStage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningProgressStage)))
		i += copy(dAtA[i:], m.ProvisioningProgressStage)
	}
	if len(m.ProvisioningStartTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStartTime)))
		i += copy(dAtA[i:], m.ProvisioningStartTime)
	}
	if len(m.ProvisioningState) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningState)))
		i += copy(dAtA[i:], m.ProvisioningState)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n466, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n466
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n467, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n467
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n468, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n468
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *Widget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Widget) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.ParentUuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentUuid)))
		i += copy(dAtA[i:], m.ParentUuid)
	}
	if len(m.ParentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ParentType)))
		i += copy(dAtA[i:], m.ParentType)
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IdPerms != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IdPerms.Size()))
		n469, err := m.IdPerms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n469
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.Annotations != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Annotations.Size()))
		n470, err := m.Annotations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n470
	}
	if m.Perms2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Perms2.Size()))
		n471, err := m.Perms2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n471
	}
	if len(m.ContainerConfig) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ContainerConfig)))
		i += copy(dAtA[i:], m.ContainerConfig)
	}
	if len(m.ContentConfig) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ContentConfig)))
		i += copy(dAtA[i:], m.ContentConfig)
	}
	if len(m.LayoutConfig) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LayoutConfig)))
		i += copy(dAtA[i:], m.LayoutConfig)
	}
	return i, nil
}

func (m *PermType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PermType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Owner)))
		i += copy(dAtA[i:], m.Owner)
	}
	if m.OwnerAccess != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.OwnerAccess))
	}
	if m.OtherAccess != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.OtherAccess))
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if m.GroupAccess != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.GroupAccess))
	}
	return i, nil
}

func (m *LoadbalancerHealthmonitorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerHealthmonitorType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Delay != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Delay))
	}
	if len(m.ExpectedCodes) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ExpectedCodes)))
		i += copy(dAtA[i:], m.ExpectedCodes)
	}
	if m.MaxRetries != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MaxRetries))
	}
	if len(m.HttpMethod) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.HttpMethod)))
		i += copy(dAtA[i:], m.HttpMethod)
	}
	if m.AdminState {
		dAtA[i] = 0x28
		i++
		if m.AdminState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Timeout))
	}
	if len(m.UrlPath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.UrlPath)))
		i += copy(dAtA[i:], m.UrlPath)
	}
	if len(m.MonitorType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.MonitorType)))
		i += copy(dAtA[i:], m.MonitorType)
	}
	return i, nil
}

func (m *SNMPCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SNMPCredentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.V3PrivacyProtocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3PrivacyProtocol)))
		i += copy(dAtA[i:], m.V3PrivacyProtocol)
	}
	if m.Retries != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Retries))
	}
	if len(m.V3AuthenticationPassword) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3AuthenticationPassword)))
		i += copy(dAtA[i:], m.V3AuthenticationPassword)
	}
	if m.V3EngineTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.V3EngineTime))
	}
	if len(m.V3EngineId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3EngineId)))
		i += copy(dAtA[i:], m.V3EngineId)
	}
	if m.LocalPort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LocalPort))
	}
	if len(m.V3SecurityLevel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3SecurityLevel)))
		i += copy(dAtA[i:], m.V3SecurityLevel)
	}
	if len(m.V3Context) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3Context)))
		i += copy(dAtA[i:], m.V3Context)
	}
	if len(m.V3SecurityName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3SecurityName)))
		i += copy(dAtA[i:], m.V3SecurityName)
	}
	if len(m.V3AuthenticationProtocol) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3AuthenticationProtocol)))
		i += copy(dAtA[i:], m.V3AuthenticationProtocol)
	}
	if len(m.V2Community) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V2Community)))
		i += copy(dAtA[i:], m.V2Community)
	}
	if len(m.V3SecurityEngineId) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3SecurityEngineId)))
		i += copy(dAtA[i:], m.V3SecurityEngineId)
	}
	if len(m.V3ContextEngineId) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3ContextEngineId)))
		i += copy(dAtA[i:], m.V3ContextEngineId)
	}
	if m.Version != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Version))
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Timeout))
	}
	if len(m.V3PrivacyPassword) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.V3PrivacyPassword)))
		i += copy(dAtA[i:], m.V3PrivacyPassword)
	}
	if m.V3EngineBoots != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.V3EngineBoots))
	}
	return i, nil
}

func (m *PolicyBasedForwardingRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyBasedForwardingRuleType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DstMac) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DstMac)))
		i += copy(dAtA[i:], m.DstMac)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.Ipv6ServiceChainAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Ipv6ServiceChainAddress)))
		i += copy(dAtA[i:], m.Ipv6ServiceChainAddress)
	}
	if len(m.Direction) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Direction)))
		i += copy(dAtA[i:], m.Direction)
	}
	if m.MplsLabel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MplsLabel))
	}
	if m.VlanTag != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VlanTag))
	}
	if len(m.SrcMac) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SrcMac)))
		i += copy(dAtA[i:], m.SrcMac)
	}
	if len(m.ServiceChainAddress) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceChainAddress)))
		i += copy(dAtA[i:], m.ServiceChainAddress)
	}
	return i, nil
}

func (m *VirtualMachineInterfacePropertiesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualMachineInterfacePropertiesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubInterfaceVlanTag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SubInterfaceVlanTag))
	}
	if m.LocalPreference != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LocalPreference))
	}
	if m.InterfaceMirror != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.InterfaceMirror.Size()))
		n472, err := m.InterfaceMirror.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n472
	}
	if len(m.ServiceInterfaceType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceInterfaceType)))
		i += copy(dAtA[i:], m.ServiceInterfaceType)
	}
	return i, nil
}

func (m *VirtualNetworkPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualNetworkPolicyType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Timer.Size()))
		n473, err := m.Timer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n473
	}
	if m.Sequence != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Sequence.Size()))
		n474, err := m.Sequence.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n474
	}
	return i, nil
}

func (m *ShareType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TenantAccess != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.TenantAccess))
	}
	if len(m.Tenant) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Tenant)))
		i += copy(dAtA[i:], m.Tenant)
	}
	return i, nil
}

func (m *StaticMirrorNhType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticMirrorNhType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VtepDstIpAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VtepDstIpAddress)))
		i += copy(dAtA[i:], m.VtepDstIpAddress)
	}
	if len(m.VtepDstMacAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VtepDstMacAddress)))
		i += copy(dAtA[i:], m.VtepDstMacAddress)
	}
	if m.Vni != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Vni))
	}
	return i, nil
}

func (m *FirewallRuleMatchTagsTypeIdList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallRuleMatchTagsTypeIdList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TagType) > 0 {
		dAtA476 := make([]byte, len(m.TagType)*10)
		var j475 int
		for _, num1 := range m.TagType {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA476[j475] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j475++
			}
			dAtA476[j475] = uint8(num)
			j475++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(j475))
		i += copy(dAtA[i:], dAtA476[:j475])
	}
	return i, nil
}

func (m *CommunityAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommunityAttributes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommunityAttribute) > 0 {
		for _, b := range m.CommunityAttribute {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *IpAddressesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpAddressesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	return i, nil
}

func (m *ServiceTemplateInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceTemplateInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StaticRouteEnable {
		dAtA[i] = 0x8
		i++
		if m.StaticRouteEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SharedIp {
		dAtA[i] = 0x10
		i++
		if m.SharedIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ServiceInterfaceType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceInterfaceType)))
		i += copy(dAtA[i:], m.ServiceInterfaceType)
	}
	return i, nil
}

func (m *IdPermsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdPermsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enable {
		dAtA[i] = 0x8
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.Creator) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Creator)))
		i += copy(dAtA[i:], m.Creator)
	}
	if m.UserVisible {
		dAtA[i] = 0x28
		i++
		if m.UserVisible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.LastModified) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LastModified)))
		i += copy(dAtA[i:], m.LastModified)
	}
	if m.Permissions != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Permissions.Size()))
		n477, err := m.Permissions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n477
	}
	return i, nil
}

func (m *RbacPermType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RbacPermType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoleCrud) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RoleCrud)))
		i += copy(dAtA[i:], m.RoleCrud)
	}
	if len(m.RoleName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RoleName)))
		i += copy(dAtA[i:], m.RoleName)
	}
	return i, nil
}

func (m *FlowAgingTimeoutList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowAgingTimeoutList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FlowAgingTimeout) > 0 {
		for _, msg := range m.FlowAgingTimeout {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UveKeysType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UveKeysType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UveKey) > 0 {
		for _, s := range m.UveKey {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DiscoveryServiceAssignmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveryServiceAssignmentType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subscriber) > 0 {
		for _, msg := range m.Subscriber {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Publisher != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Publisher.Size()))
		n478, err := m.Publisher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n478
	}
	return i, nil
}

func (m *GracefulRestartParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GracefulRestartParametersType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enable {
		dAtA[i] = 0x8
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EndOfRibTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.EndOfRibTimeout))
	}
	if m.BgpHelperEnable {
		dAtA[i] = 0x18
		i++
		if m.BgpHelperEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XmppHelperEnable {
		dAtA[i] = 0x20
		i++
		if m.XmppHelperEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RestartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RestartTime))
	}
	if m.LongLivedRestartTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LongLivedRestartTime))
	}
	return i, nil
}

func (m *ServiceInterfaceTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceInterfaceTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InterfaceType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.InterfaceType)))
		i += copy(dAtA[i:], m.InterfaceType)
	}
	return i, nil
}

func (m *AllocationPoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocationPoolType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VrouterSpecificPool {
		dAtA[i] = 0x8
		i++
		if m.VrouterSpecificPool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Start) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	return i, nil
}

func (m *PolicyRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyRuleType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Direction) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Direction)))
		i += copy(dAtA[i:], m.Direction)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.DstAddresses) > 0 {
		for _, msg := range m.DstAddresses {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ActionList != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ActionList.Size()))
		n479, err := m.ActionList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n479
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.RuleUuid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RuleUuid)))
		i += copy(dAtA[i:], m.RuleUuid)
	}
	if len(m.DstPorts) > 0 {
		for _, msg := range m.DstPorts {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Application) > 0 {
		for _, s := range m.Application {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.LastModified) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LastModified)))
		i += copy(dAtA[i:], m.LastModified)
	}
	if len(m.Ethertype) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Ethertype)))
		i += copy(dAtA[i:], m.Ethertype)
	}
	if len(m.SrcAddresses) > 0 {
		for _, msg := range m.SrcAddresses {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RuleSequence != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RuleSequence.Size()))
		n480, err := m.RuleSequence.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n480
	}
	if len(m.SrcPorts) > 0 {
		for _, msg := range m.SrcPorts {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VirtualDnsRecordType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualDnsRecordType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RecordName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RecordName)))
		i += copy(dAtA[i:], m.RecordName)
	}
	if len(m.RecordClass) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RecordClass)))
		i += copy(dAtA[i:], m.RecordClass)
	}
	if len(m.RecordData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RecordData)))
		i += copy(dAtA[i:], m.RecordData)
	}
	if len(m.RecordType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RecordType)))
		i += copy(dAtA[i:], m.RecordType)
	}
	if m.RecordTtlSeconds != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RecordTtlSeconds))
	}
	if m.RecordMxPreference != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RecordMxPreference))
	}
	return i, nil
}

func (m *AlarmExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlarmExpression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Operation) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Operation)))
		i += copy(dAtA[i:], m.Operation)
	}
	if len(m.Operand1) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Operand1)))
		i += copy(dAtA[i:], m.Operand1)
	}
	if len(m.Variables) > 0 {
		for _, s := range m.Variables {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Operand2 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Operand2.Size()))
		n481, err := m.Operand2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n481
	}
	return i, nil
}

func (m *FirewallServiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallServiceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.DstPorts != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DstPorts.Size()))
		n482, err := m.DstPorts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n482
	}
	if m.SrcPorts != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SrcPorts.Size()))
		n483, err := m.SrcPorts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n483
	}
	if m.ProtocolId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProtocolId))
	}
	return i, nil
}

func (m *RoutingPolicyServiceInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutingPolicyServiceInstanceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RightSequence) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RightSequence)))
		i += copy(dAtA[i:], m.RightSequence)
	}
	if len(m.LeftSequence) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LeftSequence)))
		i += copy(dAtA[i:], m.LeftSequence)
	}
	return i, nil
}

func (m *TimerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimerType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StartTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.OffInterval) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.OffInterval)))
		i += copy(dAtA[i:], m.OffInterval)
	}
	if len(m.OnInterval) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.OnInterval)))
		i += copy(dAtA[i:], m.OnInterval)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	return i, nil
}

func (m *FirewallRuleEndpointType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallRuleEndpointType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AddressGroup) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AddressGroup)))
		i += copy(dAtA[i:], m.AddressGroup)
	}
	if m.Subnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Subnet.Size()))
		n484, err := m.Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n484
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TagIds) > 0 {
		dAtA486 := make([]byte, len(m.TagIds)*10)
		var j485 int
		for _, num1 := range m.TagIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA486[j485] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j485++
			}
			dAtA486[j485] = uint8(num)
			j485++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(j485))
		i += copy(dAtA[i:], dAtA486[:j485])
	}
	if len(m.VirtualNetwork) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VirtualNetwork)))
		i += copy(dAtA[i:], m.VirtualNetwork)
	}
	if m.Any {
		dAtA[i] = 0x30
		i++
		if m.Any {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InterfaceMirrorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceMirrorType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TrafficDirection) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.TrafficDirection)))
		i += copy(dAtA[i:], m.TrafficDirection)
	}
	if m.MirrorTo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MirrorTo.Size()))
		n487, err := m.MirrorTo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n487
	}
	return i, nil
}

func (m *VirtualNetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualNetworkType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ForwardingMode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ForwardingMode)))
		i += copy(dAtA[i:], m.ForwardingMode)
	}
	if m.AllowTransit {
		dAtA[i] = 0x10
		i++
		if m.AllowTransit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NetworkId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NetworkId))
	}
	if m.MirrorDestination {
		dAtA[i] = 0x20
		i++
		if m.MirrorDestination {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VxlanNetworkIdentifier != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VxlanNetworkIdentifier))
	}
	if len(m.Rpf) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Rpf)))
		i += copy(dAtA[i:], m.Rpf)
	}
	return i, nil
}

func (m *PortType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EndPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.EndPort))
	}
	if m.StartPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.StartPort))
	}
	return i, nil
}

func (m *PortMappings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMappings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PortMappings) > 0 {
		for _, msg := range m.PortMappings {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceInstanceInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceInstanceInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VirtualNetwork) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VirtualNetwork)))
		i += copy(dAtA[i:], m.VirtualNetwork)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if m.AllowedAddressPairs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AllowedAddressPairs.Size()))
		n488, err := m.AllowedAddressPairs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n488
	}
	if m.StaticRoutes != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.StaticRoutes.Size()))
		n489, err := m.StaticRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n489
	}
	return i, nil
}

func (m *SequenceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Major != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Major))
	}
	if m.Minor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Minor))
	}
	return i, nil
}

func (m *SecurityLoggingObjectRuleEntryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityLoggingObjectRuleEntryType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RuleUuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RuleUuid)))
		i += copy(dAtA[i:], m.RuleUuid)
	}
	if m.Rate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Rate))
	}
	return i, nil
}

func (m *SubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpPrefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpPrefix)))
		i += copy(dAtA[i:], m.IpPrefix)
	}
	if m.IpPrefixLen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IpPrefixLen))
	}
	return i, nil
}

func (m *RouteTargetList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTargetList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RouteTarget) > 0 {
		for _, s := range m.RouteTarget {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LinklocalServiceEntryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinklocalServiceEntryType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpFabricServiceIp) > 0 {
		for _, s := range m.IpFabricServiceIp {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.LinklocalServiceName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LinklocalServiceName)))
		i += copy(dAtA[i:], m.LinklocalServiceName)
	}
	if len(m.LinklocalServiceIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LinklocalServiceIp)))
		i += copy(dAtA[i:], m.LinklocalServiceIp)
	}
	if m.IpFabricServicePort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IpFabricServicePort))
	}
	if len(m.IpFabric_DNSServiceName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpFabric_DNSServiceName)))
		i += copy(dAtA[i:], m.IpFabric_DNSServiceName)
	}
	if m.LinklocalServicePort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LinklocalServicePort))
	}
	return i, nil
}

func (m *IpamSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpamSubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subnet != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Subnet.Size()))
		n490, err := m.Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n490
	}
	if m.AddrFromStart {
		dAtA[i] = 0x10
		i++
		if m.AddrFromStart {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableDhcp {
		dAtA[i] = 0x18
		i++
		if m.EnableDhcp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DefaultGateway) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultGateway)))
		i += copy(dAtA[i:], m.DefaultGateway)
	}
	if m.AllocUnit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AllocUnit))
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.DnsNameservers) > 0 {
		for _, s := range m.DnsNameservers {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DhcpOptionList != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DhcpOptionList.Size()))
		n491, err := m.DhcpOptionList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n491
	}
	if len(m.SubnetUuid) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SubnetUuid)))
		i += copy(dAtA[i:], m.SubnetUuid)
	}
	if len(m.AllocationPools) > 0 {
		for _, msg := range m.AllocationPools {
			dAtA[i] = 0x52
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LastModified) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LastModified)))
		i += copy(dAtA[i:], m.LastModified)
	}
	if m.HostRoutes != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.HostRoutes.Size()))
		n492, err := m.HostRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n492
	}
	if len(m.DnsServerAddress) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DnsServerAddress)))
		i += copy(dAtA[i:], m.DnsServerAddress)
	}
	if len(m.SubnetName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SubnetName)))
		i += copy(dAtA[i:], m.SubnetName)
	}
	return i, nil
}

func (m *QuotaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuotaType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VirtualRouter != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualRouter))
	}
	if m.NetworkPolicy != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NetworkPolicy))
	}
	if m.LoadbalancerPool != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerPool))
	}
	if m.RouteTable != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.RouteTable))
	}
	if m.Subnet != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Subnet))
	}
	if m.NetworkIpam != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NetworkIpam))
	}
	if m.Virtual_DNSRecord != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Virtual_DNSRecord))
	}
	if m.LogicalRouter != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LogicalRouter))
	}
	if m.SecurityGroupRule != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityGroupRule))
	}
	if m.Virtual_DNS != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Virtual_DNS))
	}
	if m.ServiceInstance != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceInstance))
	}
	if m.ServiceTemplate != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServiceTemplate))
	}
	if m.BgpRouter != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.BgpRouter))
	}
	if m.FloatingIp != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FloatingIp))
	}
	if m.FloatingIpPool != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.FloatingIpPool))
	}
	if m.LoadbalancerMember != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerMember))
	}
	if m.AccessControlList != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.AccessControlList))
	}
	if m.VirtualMachineInterface != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualMachineInterface))
	}
	if m.InstanceIp != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.InstanceIp))
	}
	if m.GlobalVrouterConfig != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.GlobalVrouterConfig))
	}
	if m.SecurityLoggingObject != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityLoggingObject))
	}
	if m.LoadbalancerHealthmonitor != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.LoadbalancerHealthmonitor))
	}
	if m.VirtualIp != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualIp))
	}
	if m.Defaults != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Defaults))
	}
	if m.SecurityGroup != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityGroup))
	}
	if m.VirtualNetwork != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualNetwork))
	}
	return i, nil
}

func (m *KeyValuePairs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValuePairs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeyValuePair) > 0 {
		for _, msg := range m.KeyValuePair {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TelemetryStateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryStateInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for _, msg := range m.Resource {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ServerPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ServerPort))
	}
	if len(m.ServerIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServerIp)))
		i += copy(dAtA[i:], m.ServerIp)
	}
	return i, nil
}

func (m *FirewallRuleMatchTagsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallRuleMatchTagsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TagList) > 0 {
		for _, s := range m.TagList {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LinklocalServicesTypes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinklocalServicesTypes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LinklocalServiceEntry) > 0 {
		for _, msg := range m.LinklocalServiceEntry {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RouteTableType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTableType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Route) > 0 {
		for _, msg := range m.Route {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MacAddressesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MacAddressesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		for _, s := range m.MacAddress {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *VrfAssignRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VrfAssignRuleType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoutingInstance) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RoutingInstance)))
		i += copy(dAtA[i:], m.RoutingInstance)
	}
	if m.MatchCondition != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MatchCondition.Size()))
		n493, err := m.MatchCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n493
	}
	if m.VlanTag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VlanTag))
	}
	if m.IgnoreAcl {
		dAtA[i] = 0x20
		i++
		if m.IgnoreAcl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ActionListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GatewayName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.GatewayName)))
		i += copy(dAtA[i:], m.GatewayName)
	}
	if m.Log {
		dAtA[i] = 0x10
		i++
		if m.Log {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Alert {
		dAtA[i] = 0x18
		i++
		if m.Alert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.QosAction) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.QosAction)))
		i += copy(dAtA[i:], m.QosAction)
	}
	if len(m.AssignRoutingInstance) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AssignRoutingInstance)))
		i += copy(dAtA[i:], m.AssignRoutingInstance)
	}
	if m.MirrorTo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MirrorTo.Size()))
		n494, err := m.MirrorTo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n494
	}
	if len(m.SimpleAction) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SimpleAction)))
		i += copy(dAtA[i:], m.SimpleAction)
	}
	if len(m.ApplyService) > 0 {
		for _, s := range m.ApplyService {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AclEntriesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclEntriesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dynamic {
		dAtA[i] = 0x8
		i++
		if m.Dynamic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AclRule) > 0 {
		for _, msg := range m.AclRule {
			dAtA[i] = 0x12
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VirtualIpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualIpType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.StatusDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.StatusDescription)))
		i += copy(dAtA[i:], m.StatusDescription)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.SubnetId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SubnetId)))
		i += copy(dAtA[i:], m.SubnetId)
	}
	if len(m.PersistenceCookieName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PersistenceCookieName)))
		i += copy(dAtA[i:], m.PersistenceCookieName)
	}
	if m.ConnectionLimit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ConnectionLimit))
	}
	if len(m.PersistenceType) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PersistenceType)))
		i += copy(dAtA[i:], m.PersistenceType)
	}
	if m.AdminState {
		dAtA[i] = 0x40
		i++
		if m.AdminState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.ProtocolPort != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProtocolPort))
	}
	return i, nil
}

func (m *RouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if len(m.NextHop) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.NextHop)))
		i += copy(dAtA[i:], m.NextHop)
	}
	if m.CommunityAttributes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.CommunityAttributes.Size()))
		n495, err := m.CommunityAttributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n495
	}
	if len(m.NextHopType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.NextHopType)))
		i += copy(dAtA[i:], m.NextHopType)
	}
	return i, nil
}

func (m *LoadbalancerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.ProvisioningStatus) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ProvisioningStatus)))
		i += copy(dAtA[i:], m.ProvisioningStatus)
	}
	if m.AdminState {
		dAtA[i] = 0x18
		i++
		if m.AdminState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VipAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VipAddress)))
		i += copy(dAtA[i:], m.VipAddress)
	}
	if len(m.VipSubnetId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VipSubnetId)))
		i += copy(dAtA[i:], m.VipSubnetId)
	}
	if len(m.OperatingStatus) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.OperatingStatus)))
		i += copy(dAtA[i:], m.OperatingStatus)
	}
	return i, nil
}

func (m *ProtocolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *ServiceInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceInstanceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RightVirtualNetwork) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RightVirtualNetwork)))
		i += copy(dAtA[i:], m.RightVirtualNetwork)
	}
	if len(m.RightIpAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RightIpAddress)))
		i += copy(dAtA[i:], m.RightIpAddress)
	}
	if len(m.AvailabilityZone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AvailabilityZone)))
		i += copy(dAtA[i:], m.AvailabilityZone)
	}
	if len(m.ManagementVirtualNetwork) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ManagementVirtualNetwork)))
		i += copy(dAtA[i:], m.ManagementVirtualNetwork)
	}
	if m.ScaleOut != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ScaleOut.Size()))
		n496, err := m.ScaleOut.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n496
	}
	if len(m.HaMode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.HaMode)))
		i += copy(dAtA[i:], m.HaMode)
	}
	if len(m.VirtualRouterId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VirtualRouterId)))
		i += copy(dAtA[i:], m.VirtualRouterId)
	}
	if len(m.InterfaceList) > 0 {
		for _, msg := range m.InterfaceList {
			dAtA[i] = 0x42
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LeftIpAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LeftIpAddress)))
		i += copy(dAtA[i:], m.LeftIpAddress)
	}
	if len(m.LeftVirtualNetwork) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LeftVirtualNetwork)))
		i += copy(dAtA[i:], m.LeftVirtualNetwork)
	}
	if m.AutoPolicy {
		dAtA[i] = 0x58
		i++
		if m.AutoPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MatchConditionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchConditionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcPort != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SrcPort.Size()))
		n497, err := m.SrcPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n497
	}
	if m.SrcAddress != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SrcAddress.Size()))
		n498, err := m.SrcAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n498
	}
	if len(m.Ethertype) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Ethertype)))
		i += copy(dAtA[i:], m.Ethertype)
	}
	if m.DstAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DstAddress.Size()))
		n499, err := m.DstAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n499
	}
	if m.DstPort != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DstPort.Size()))
		n500, err := m.DstPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n500
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	return i, nil
}

func (m *LoadbalancerMemberType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerMemberType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.StatusDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.StatusDescription)))
		i += copy(dAtA[i:], m.StatusDescription)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Weight))
	}
	if m.AdminState {
		dAtA[i] = 0x20
		i++
		if m.AdminState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.ProtocolPort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProtocolPort))
	}
	return i, nil
}

func (m *UserCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCredentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *AllowedAddressPairs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowedAddressPairs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllowedAddressPair) > 0 {
		for _, msg := range m.AllowedAddressPair {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TelemetryResourceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryResourceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Rate) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Rate)))
		i += copy(dAtA[i:], m.Rate)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *ControlTrafficDscpType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlTrafficDscpType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Control != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Control))
	}
	if m.Analytics != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Analytics))
	}
	if m.Dns != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Dns))
	}
	return i, nil
}

func (m *UserDefinedLogStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDefinedLogStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pattern) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *LoadbalancerPoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerPoolType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.SubnetId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SubnetId)))
		i += copy(dAtA[i:], m.SubnetId)
	}
	if len(m.SessionPersistence) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SessionPersistence)))
		i += copy(dAtA[i:], m.SessionPersistence)
	}
	if m.AdminState {
		dAtA[i] = 0x28
		i++
		if m.AdminState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PersistenceCookieName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PersistenceCookieName)))
		i += copy(dAtA[i:], m.PersistenceCookieName)
	}
	if len(m.StatusDescription) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.StatusDescription)))
		i += copy(dAtA[i:], m.StatusDescription)
	}
	if len(m.LoadbalancerMethod) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.LoadbalancerMethod)))
		i += copy(dAtA[i:], m.LoadbalancerMethod)
	}
	return i, nil
}

func (m *KeyValuePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValuePair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *IpamSubnets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpamSubnets) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subnets) > 0 {
		for _, msg := range m.Subnets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LoadbalancerListenerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerListenerType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DefaultTlsContainer) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DefaultTlsContainer)))
		i += copy(dAtA[i:], m.DefaultTlsContainer)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.ConnectionLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ConnectionLimit))
	}
	if m.AdminState {
		dAtA[i] = 0x20
		i++
		if m.AdminState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SniContainers) > 0 {
		for _, s := range m.SniContainers {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ProtocolPort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProtocolPort))
	}
	return i, nil
}

func (m *BridgeDomainMembershipType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BridgeDomainMembershipType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VlanTag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VlanTag))
	}
	return i, nil
}

func (m *VnSubnetsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VnSubnetsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpamSubnets) > 0 {
		for _, msg := range m.IpamSubnets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HostRoutes != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.HostRoutes.Size()))
		n501, err := m.HostRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n501
	}
	return i, nil
}

func (m *ServiceApplianceInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceApplianceInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InterfaceType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.InterfaceType)))
		i += copy(dAtA[i:], m.InterfaceType)
	}
	return i, nil
}

func (m *SubnetListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		for _, msg := range m.Subnet {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPaaServiceParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPaaServiceParametersType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortStart != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PortStart))
	}
	if m.PortEnd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.PortEnd))
	}
	return i, nil
}

func (m *IpamDnsAddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpamDnsAddressType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TenantDnsServerAddress != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.TenantDnsServerAddress.Size()))
		n502, err := m.TenantDnsServerAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n502
	}
	if len(m.VirtualDnsServerName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VirtualDnsServerName)))
		i += copy(dAtA[i:], m.VirtualDnsServerName)
	}
	return i, nil
}

func (m *DhcpOptionsListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DhcpOptionsListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DhcpOption) > 0 {
		for _, msg := range m.DhcpOption {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MACLimitControlType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MACLimitControlType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MacLimit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacLimit))
	}
	if len(m.MacLimitAction) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.MacLimitAction)))
		i += copy(dAtA[i:], m.MacLimitAction)
	}
	return i, nil
}

func (m *UserDefinedLogStatList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDefinedLogStatList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Statlist) > 0 {
		for _, msg := range m.Statlist {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EcmpHashingIncludeFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EcmpHashingIncludeFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DestinationIp {
		dAtA[i] = 0x8
		i++
		if m.DestinationIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IpProtocol {
		dAtA[i] = 0x10
		i++
		if m.IpProtocol {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SourceIp {
		dAtA[i] = 0x18
		i++
		if m.SourceIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HashingConfigured {
		dAtA[i] = 0x20
		i++
		if m.HashingConfigured {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SourcePort {
		dAtA[i] = 0x28
		i++
		if m.SourcePort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DestinationPort {
		dAtA[i] = 0x30
		i++
		if m.DestinationPort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *EncapsulationPrioritiesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncapsulationPrioritiesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Encapsulation) > 0 {
		for _, b := range m.Encapsulation {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *VirtualRouterNetworkIpamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualRouterNetworkIpamType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		for _, msg := range m.Subnet {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AllocationPools) > 0 {
		for _, msg := range m.AllocationPools {
			dAtA[i] = 0x12
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VirtualDnsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualDnsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FloatingIpRecord) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.FloatingIpRecord)))
		i += copy(dAtA[i:], m.FloatingIpRecord)
	}
	if len(m.DomainName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DomainName)))
		i += copy(dAtA[i:], m.DomainName)
	}
	if m.ExternalVisible {
		dAtA[i] = 0x18
		i++
		if m.ExternalVisible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.NextVirtual_DNS) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.NextVirtual_DNS)))
		i += copy(dAtA[i:], m.NextVirtual_DNS)
	}
	if m.DynamicRecordsFromClient {
		dAtA[i] = 0x28
		i++
		if m.DynamicRecordsFromClient {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReverseResolution {
		dAtA[i] = 0x30
		i++
		if m.ReverseResolution {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultTtlSeconds != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DefaultTtlSeconds))
	}
	if len(m.RecordOrder) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RecordOrder)))
		i += copy(dAtA[i:], m.RecordOrder)
	}
	return i, nil
}

func (m *FirewallSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallSequence) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sequence) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Sequence)))
		i += copy(dAtA[i:], m.Sequence)
	}
	return i, nil
}

func (m *MirrorActionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorActionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NicAssistedMirroringVlan != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.NicAssistedMirroringVlan))
	}
	if len(m.AnalyzerName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AnalyzerName)))
		i += copy(dAtA[i:], m.AnalyzerName)
	}
	if len(m.NhMode) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.NhMode)))
		i += copy(dAtA[i:], m.NhMode)
	}
	if m.JuniperHeader {
		dAtA[i] = 0x20
		i++
		if m.JuniperHeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UdpPort != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.UdpPort))
	}
	if len(m.RoutingInstance) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RoutingInstance)))
		i += copy(dAtA[i:], m.RoutingInstance)
	}
	if m.StaticNhHeader != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.StaticNhHeader.Size()))
		n503, err := m.StaticNhHeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n503
	}
	if len(m.AnalyzerIpAddress) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AnalyzerIpAddress)))
		i += copy(dAtA[i:], m.AnalyzerIpAddress)
	}
	if len(m.Encapsulation) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Encapsulation)))
		i += copy(dAtA[i:], m.Encapsulation)
	}
	if len(m.AnalyzerMacAddress) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AnalyzerMacAddress)))
		i += copy(dAtA[i:], m.AnalyzerMacAddress)
	}
	if m.NicAssistedMirroring {
		dAtA[i] = 0x58
		i++
		if m.NicAssistedMirroring {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *IpamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpamType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpamMethod) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpamMethod)))
		i += copy(dAtA[i:], m.IpamMethod)
	}
	if len(m.IpamDnsMethod) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.IpamDnsMethod)))
		i += copy(dAtA[i:], m.IpamDnsMethod)
	}
	if m.IpamDnsServer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.IpamDnsServer.Size()))
		n504, err := m.IpamDnsServer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n504
	}
	if m.DhcpOptionList != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DhcpOptionList.Size()))
		n505, err := m.DhcpOptionList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n505
	}
	if m.HostRoutes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.HostRoutes.Size()))
		n506, err := m.HostRoutes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n506
	}
	if m.CidrBlock != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.CidrBlock.Size()))
		n507, err := m.CidrBlock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n507
	}
	return i, nil
}

func (m *JunosServicePorts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JunosServicePorts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServicePort) > 0 {
		for _, s := range m.ServicePort {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AlarmOperand2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlarmOperand2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UveAttribute) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.UveAttribute)))
		i += copy(dAtA[i:], m.UveAttribute)
	}
	if len(m.JsonValue) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.JsonValue)))
		i += copy(dAtA[i:], m.JsonValue)
	}
	return i, nil
}

func (m *RbacRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RbacRuleType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RuleObject) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RuleObject)))
		i += copy(dAtA[i:], m.RuleObject)
	}
	if len(m.RulePerms) > 0 {
		for _, msg := range m.RulePerms {
			dAtA[i] = 0x12
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RuleField) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RuleField)))
		i += copy(dAtA[i:], m.RuleField)
	}
	return i, nil
}

func (m *DomainLimitsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainLimitsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProjectLimit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ProjectLimit))
	}
	if m.VirtualNetworkLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.VirtualNetworkLimit))
	}
	if m.SecurityGroupLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SecurityGroupLimit))
	}
	return i, nil
}

func (m *PolicyEntriesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyEntriesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PolicyRule) > 0 {
		for _, msg := range m.PolicyRule {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceHealthCheckType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceHealthCheckType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DelayUsecs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DelayUsecs))
	}
	if m.TimeoutUsecs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.TimeoutUsecs))
	}
	if m.Enabled {
		dAtA[i] = 0x18
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Delay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Delay))
	}
	if len(m.ExpectedCodes) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ExpectedCodes)))
		i += copy(dAtA[i:], m.ExpectedCodes)
	}
	if m.MaxRetries != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MaxRetries))
	}
	if len(m.HealthCheckType) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.HealthCheckType)))
		i += copy(dAtA[i:], m.HealthCheckType)
	}
	if len(m.HttpMethod) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.HttpMethod)))
		i += copy(dAtA[i:], m.HttpMethod)
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Timeout))
	}
	if len(m.UrlPath) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.UrlPath)))
		i += copy(dAtA[i:], m.UrlPath)
	}
	if len(m.MonitorType) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.MonitorType)))
		i += copy(dAtA[i:], m.MonitorType)
	}
	return i, nil
}

func (m *AddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SecurityGroup) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.SecurityGroup)))
		i += copy(dAtA[i:], m.SecurityGroup)
	}
	if m.Subnet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Subnet.Size()))
		n508, err := m.Subnet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n508
	}
	if len(m.NetworkPolicy) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.NetworkPolicy)))
		i += copy(dAtA[i:], m.NetworkPolicy)
	}
	if len(m.SubnetList) > 0 {
		for _, msg := range m.SubnetList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VirtualNetwork) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VirtualNetwork)))
		i += copy(dAtA[i:], m.VirtualNetwork)
	}
	return i, nil
}

func (m *FlowAgingTimeout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowAgingTimeout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeoutInSeconds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.TimeoutInSeconds))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *QosIdForwardingClassPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosIdForwardingClassPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Key))
	}
	if m.ForwardingClassId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ForwardingClassId))
	}
	return i, nil
}

func (m *RbacRuleEntriesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RbacRuleEntriesType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RbacRule) > 0 {
		for _, msg := range m.RbacRule {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FloatingIpPoolSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatingIpPoolSubnetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetUuid) > 0 {
		for _, s := range m.SubnetUuid {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ServiceTemplateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceTemplateType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AvailabilityZoneEnable {
		dAtA[i] = 0x8
		i++
		if m.AvailabilityZoneEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.InstanceData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.InstanceData)))
		i += copy(dAtA[i:], m.InstanceData)
	}
	if m.OrderedInterfaces {
		dAtA[i] = 0x18
		i++
		if m.OrderedInterfaces {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ServiceVirtualizationType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceVirtualizationType)))
		i += copy(dAtA[i:], m.ServiceVirtualizationType)
	}
	if len(m.InterfaceType) > 0 {
		for _, msg := range m.InterfaceType {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImageName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ImageName)))
		i += copy(dAtA[i:], m.ImageName)
	}
	if len(m.ServiceMode) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceMode)))
		i += copy(dAtA[i:], m.ServiceMode)
	}
	if m.Version != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Version))
	}
	if len(m.ServiceType) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.ServiceType)))
		i += copy(dAtA[i:], m.ServiceType)
	}
	if len(m.Flavor) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Flavor)))
		i += copy(dAtA[i:], m.Flavor)
	}
	if m.ServiceScaling {
		dAtA[i] = 0x58
		i++
		if m.ServiceScaling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VrouterInstanceType) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.VrouterInstanceType)))
		i += copy(dAtA[i:], m.VrouterInstanceType)
	}
	return i, nil
}

func (m *FatFlowProtocols) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FatFlowProtocols) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FatFlowProtocol) > 0 {
		for _, msg := range m.FatFlowProtocol {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MACMoveLimitControlType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MACMoveLimitControlType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MacMoveTimeWindow != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacMoveTimeWindow))
	}
	if m.MacMoveLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MacMoveLimit))
	}
	if len(m.MacMoveLimitAction) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.MacMoveLimitAction)))
		i += copy(dAtA[i:], m.MacMoveLimitAction)
	}
	return i, nil
}

func (m *DiscoveryPubSubEndPointType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveryPubSubEndPointType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EpVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.EpVersion)))
		i += copy(dAtA[i:], m.EpVersion)
	}
	if len(m.EpId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.EpId)))
		i += copy(dAtA[i:], m.EpId)
	}
	if len(m.EpType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.EpType)))
		i += copy(dAtA[i:], m.EpType)
	}
	if m.EpPrefix != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.EpPrefix.Size()))
		n509, err := m.EpPrefix.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n509
	}
	return i, nil
}

func (m *AclRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclRuleType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RuleUuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.RuleUuid)))
		i += copy(dAtA[i:], m.RuleUuid)
	}
	if m.MatchCondition != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MatchCondition.Size()))
		n510, err := m.MatchCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n510
	}
	if len(m.Direction) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Direction)))
		i += copy(dAtA[i:], m.Direction)
	}
	if m.ActionList != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.ActionList.Size()))
		n511, err := m.ActionList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n511
	}
	return i, nil
}

func (m *PluginProperty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginProperty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Property) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Property)))
		i += copy(dAtA[i:], m.Property)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *SecurityLoggingObjectRuleListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityLoggingObjectRuleListType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rule) > 0 {
		for _, msg := range m.Rule {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FirewallServiceGroupType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirewallServiceGroupType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FirewallService) > 0 {
		for _, msg := range m.FirewallService {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VrfAssignTableType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VrfAssignTableType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VrfAssignRule) > 0 {
		for _, msg := range m.VrfAssignRule {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MemberType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	return i, nil
}

func (m *AlarmAndList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlarmAndList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AndList) > 0 {
		for _, msg := range m.AndList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PortMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SrcPort))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.DstPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.DstPort))
	}
	return i, nil
}

func (m *ProviderDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SegmentationId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.SegmentationId))
	}
	if len(m.PhysicalNetwork) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.PhysicalNetwork)))
		i += copy(dAtA[i:], m.PhysicalNetwork)
	}
	return i, nil
}

func (m *PermType2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PermType2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Owner)))
		i += copy(dAtA[i:], m.Owner)
	}
	if m.OwnerAccess != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.OwnerAccess))
	}
	if m.GlobalAccess != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.GlobalAccess))
	}
	if len(m.Share) > 0 {
		for _, msg := range m.Share {
			dAtA[i] = 0x22
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DhcpOptionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DhcpOptionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DhcpOptionValue) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DhcpOptionValue)))
		i += copy(dAtA[i:], m.DhcpOptionValue)
	}
	if len(m.DhcpOptionValueBytes) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DhcpOptionValueBytes)))
		i += copy(dAtA[i:], m.DhcpOptionValueBytes)
	}
	if len(m.DhcpOptionName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.DhcpOptionName)))
		i += copy(dAtA[i:], m.DhcpOptionName)
	}
	return i, nil
}

func (m *QosIdForwardingClassPairs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosIdForwardingClassPairs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QosIdForwardingClassPair) > 0 {
		for _, msg := range m.QosIdForwardingClassPair {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PluginProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PluginProperty) > 0 {
		for _, msg := range m.PluginProperty {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AlarmOrList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlarmOrList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrList) > 0 {
		for _, msg := range m.OrList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintContrail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceScaleOutType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceScaleOutType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AutoScale {
		dAtA[i] = 0x8
		i++
		if m.AutoScale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxInstances != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.MaxInstances))
	}
	return i, nil
}

func (m *AllowedAddressPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowedAddressPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ip != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContrail(dAtA, i, uint64(m.Ip.Size()))
		n512, err := m.Ip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n512
	}
	if len(m.Mac) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.Mac)))
		i += copy(dAtA[i:], m.Mac)
	}
	if len(m.AddressMode) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContrail(dAtA, i, uint64(len(m.AddressMode)))
		i += copy(dAtA[i:], m.AddressMode)
	}
	return i, nil
}

func encodeVarintContrail(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ResourceRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for _, e := range m.Resource {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *ResourceResponse) Size() (n int) {
	var l int
	_ = l
	if m.ResponseType != 0 {
		n += 1 + sovContrail(uint64(m.ResponseType))
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.Uuid) > 0 {
		for _, s := range m.Uuid {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *DeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ResponseType != 0 {
		n += 1 + sovContrail(uint64(m.ResponseType))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ListRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovContrail(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovContrail(uint64(m.Offset))
	}
	if m.Detail {
		n += 2
	}
	if m.Count {
		n += 2
	}
	if m.Shared {
		n += 2
	}
	if m.ExcludeHrefs {
		n += 2
	}
	if len(m.ParentFqName) > 0 {
		for _, s := range m.ParentFqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.ParentUuids) > 0 {
		for _, s := range m.ParentUuids {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if len(m.BackrefUuids) > 0 {
		for _, s := range m.BackrefUuids {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if len(m.ObjectUuids) > 0 {
		for _, s := range m.ObjectUuids {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *Resource) Size() (n int) {
	var l int
	_ = l
	if m.ResourceOneof != nil {
		n += m.ResourceOneof.Size()
	}
	return n
}

func (m *Resource_AccessControlList) Size() (n int) {
	var l int
	_ = l
	if m.AccessControlList != nil {
		l = m.AccessControlList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_AddressGroup) Size() (n int) {
	var l int
	_ = l
	if m.AddressGroup != nil {
		l = m.AddressGroup.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Alarm) Size() (n int) {
	var l int
	_ = l
	if m.Alarm != nil {
		l = m.Alarm.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_AliasIpPool) Size() (n int) {
	var l int
	_ = l
	if m.AliasIpPool != nil {
		l = m.AliasIpPool.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_AliasIp) Size() (n int) {
	var l int
	_ = l
	if m.AliasIp != nil {
		l = m.AliasIp.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_AnalyticsNode) Size() (n int) {
	var l int
	_ = l
	if m.AnalyticsNode != nil {
		l = m.AnalyticsNode.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ApiAccessList) Size() (n int) {
	var l int
	_ = l
	if m.ApiAccessList != nil {
		l = m.ApiAccessList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ApplicationPolicySet) Size() (n int) {
	var l int
	_ = l
	if m.ApplicationPolicySet != nil {
		l = m.ApplicationPolicySet.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_BgpAsAService) Size() (n int) {
	var l int
	_ = l
	if m.BgpAsAService != nil {
		l = m.BgpAsAService.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_BgpRouter) Size() (n int) {
	var l int
	_ = l
	if m.BgpRouter != nil {
		l = m.BgpRouter.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Bgpvpn) Size() (n int) {
	var l int
	_ = l
	if m.Bgpvpn != nil {
		l = m.Bgpvpn.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_BridgeDomain) Size() (n int) {
	var l int
	_ = l
	if m.BridgeDomain != nil {
		l = m.BridgeDomain.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ConfigNode) Size() (n int) {
	var l int
	_ = l
	if m.ConfigNode != nil {
		l = m.ConfigNode.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ConfigRoot) Size() (n int) {
	var l int
	_ = l
	if m.ConfigRoot != nil {
		l = m.ConfigRoot.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_CustomerAttachment) Size() (n int) {
	var l int
	_ = l
	if m.CustomerAttachment != nil {
		l = m.CustomerAttachment.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_DatabaseNode) Size() (n int) {
	var l int
	_ = l
	if m.DatabaseNode != nil {
		l = m.DatabaseNode.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_DiscoveryServiceAssignment) Size() (n int) {
	var l int
	_ = l
	if m.DiscoveryServiceAssignment != nil {
		l = m.DiscoveryServiceAssignment.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Domain) Size() (n int) {
	var l int
	_ = l
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_DsaRule) Size() (n int) {
	var l int
	_ = l
	if m.DsaRule != nil {
		l = m.DsaRule.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_E2ServiceProvider) Size() (n int) {
	var l int
	_ = l
	if m.E2ServiceProvider != nil {
		l = m.E2ServiceProvider.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_FirewallPolicy) Size() (n int) {
	var l int
	_ = l
	if m.FirewallPolicy != nil {
		l = m.FirewallPolicy.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_FirewallRule) Size() (n int) {
	var l int
	_ = l
	if m.FirewallRule != nil {
		l = m.FirewallRule.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_FloatingIpPool) Size() (n int) {
	var l int
	_ = l
	if m.FloatingIpPool != nil {
		l = m.FloatingIpPool.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_FloatingIp) Size() (n int) {
	var l int
	_ = l
	if m.FloatingIp != nil {
		l = m.FloatingIp.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ForwardingClass) Size() (n int) {
	var l int
	_ = l
	if m.ForwardingClass != nil {
		l = m.ForwardingClass.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_GlobalQosConfig) Size() (n int) {
	var l int
	_ = l
	if m.GlobalQosConfig != nil {
		l = m.GlobalQosConfig.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_GlobalSystemConfig) Size() (n int) {
	var l int
	_ = l
	if m.GlobalSystemConfig != nil {
		l = m.GlobalSystemConfig.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_GlobalVrouterConfig) Size() (n int) {
	var l int
	_ = l
	if m.GlobalVrouterConfig != nil {
		l = m.GlobalVrouterConfig.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_InstanceIp) Size() (n int) {
	var l int
	_ = l
	if m.InstanceIp != nil {
		l = m.InstanceIp.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_InterfaceRouteTable) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceRouteTable != nil {
		l = m.InterfaceRouteTable.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_LoadbalancerHealthmonitor) Size() (n int) {
	var l int
	_ = l
	if m.LoadbalancerHealthmonitor != nil {
		l = m.LoadbalancerHealthmonitor.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_LoadbalancerListener) Size() (n int) {
	var l int
	_ = l
	if m.LoadbalancerListener != nil {
		l = m.LoadbalancerListener.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_LoadbalancerMember) Size() (n int) {
	var l int
	_ = l
	if m.LoadbalancerMember != nil {
		l = m.LoadbalancerMember.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_LoadbalancerPool) Size() (n int) {
	var l int
	_ = l
	if m.LoadbalancerPool != nil {
		l = m.LoadbalancerPool.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Loadbalancer) Size() (n int) {
	var l int
	_ = l
	if m.Loadbalancer != nil {
		l = m.Loadbalancer.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_LogicalInterface) Size() (n int) {
	var l int
	_ = l
	if m.LogicalInterface != nil {
		l = m.LogicalInterface.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_LogicalRouter) Size() (n int) {
	var l int
	_ = l
	if m.LogicalRouter != nil {
		l = m.LogicalRouter.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Namespace) Size() (n int) {
	var l int
	_ = l
	if m.Namespace != nil {
		l = m.Namespace.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_NetworkDeviceConfig) Size() (n int) {
	var l int
	_ = l
	if m.NetworkDeviceConfig != nil {
		l = m.NetworkDeviceConfig.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_NetworkIpam) Size() (n int) {
	var l int
	_ = l
	if m.NetworkIpam != nil {
		l = m.NetworkIpam.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_NetworkPolicy) Size() (n int) {
	var l int
	_ = l
	if m.NetworkPolicy != nil {
		l = m.NetworkPolicy.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_PeeringPolicy) Size() (n int) {
	var l int
	_ = l
	if m.PeeringPolicy != nil {
		l = m.PeeringPolicy.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_PhysicalInterface) Size() (n int) {
	var l int
	_ = l
	if m.PhysicalInterface != nil {
		l = m.PhysicalInterface.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_PhysicalRouter) Size() (n int) {
	var l int
	_ = l
	if m.PhysicalRouter != nil {
		l = m.PhysicalRouter.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_PolicyManagement) Size() (n int) {
	var l int
	_ = l
	if m.PolicyManagement != nil {
		l = m.PolicyManagement.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_PortTuple) Size() (n int) {
	var l int
	_ = l
	if m.PortTuple != nil {
		l = m.PortTuple.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Project) Size() (n int) {
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ProviderAttachment) Size() (n int) {
	var l int
	_ = l
	if m.ProviderAttachment != nil {
		l = m.ProviderAttachment.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_QosConfig) Size() (n int) {
	var l int
	_ = l
	if m.QosConfig != nil {
		l = m.QosConfig.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_QosQueue) Size() (n int) {
	var l int
	_ = l
	if m.QosQueue != nil {
		l = m.QosQueue.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_RouteAggregate) Size() (n int) {
	var l int
	_ = l
	if m.RouteAggregate != nil {
		l = m.RouteAggregate.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_RouteTable) Size() (n int) {
	var l int
	_ = l
	if m.RouteTable != nil {
		l = m.RouteTable.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_RouteTarget) Size() (n int) {
	var l int
	_ = l
	if m.RouteTarget != nil {
		l = m.RouteTarget.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_RoutingInstance) Size() (n int) {
	var l int
	_ = l
	if m.RoutingInstance != nil {
		l = m.RoutingInstance.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_RoutingPolicy) Size() (n int) {
	var l int
	_ = l
	if m.RoutingPolicy != nil {
		l = m.RoutingPolicy.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_SecurityGroup) Size() (n int) {
	var l int
	_ = l
	if m.SecurityGroup != nil {
		l = m.SecurityGroup.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_SecurityLoggingObject) Size() (n int) {
	var l int
	_ = l
	if m.SecurityLoggingObject != nil {
		l = m.SecurityLoggingObject.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ServiceAppliance) Size() (n int) {
	var l int
	_ = l
	if m.ServiceAppliance != nil {
		l = m.ServiceAppliance.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ServiceApplianceSet) Size() (n int) {
	var l int
	_ = l
	if m.ServiceApplianceSet != nil {
		l = m.ServiceApplianceSet.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ServiceConnectionModule) Size() (n int) {
	var l int
	_ = l
	if m.ServiceConnectionModule != nil {
		l = m.ServiceConnectionModule.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ServiceEndpoint) Size() (n int) {
	var l int
	_ = l
	if m.ServiceEndpoint != nil {
		l = m.ServiceEndpoint.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ServiceGroup) Size() (n int) {
	var l int
	_ = l
	if m.ServiceGroup != nil {
		l = m.ServiceGroup.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ServiceHealthCheck) Size() (n int) {
	var l int
	_ = l
	if m.ServiceHealthCheck != nil {
		l = m.ServiceHealthCheck.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ServiceInstance) Size() (n int) {
	var l int
	_ = l
	if m.ServiceInstance != nil {
		l = m.ServiceInstance.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ServiceObject) Size() (n int) {
	var l int
	_ = l
	if m.ServiceObject != nil {
		l = m.ServiceObject.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ServiceTemplate) Size() (n int) {
	var l int
	_ = l
	if m.ServiceTemplate != nil {
		l = m.ServiceTemplate.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Subnet) Size() (n int) {
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Tag) Size() (n int) {
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_TagType) Size() (n int) {
	var l int
	_ = l
	if m.TagType != nil {
		l = m.TagType.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_User) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Virtual_DNSRecord) Size() (n int) {
	var l int
	_ = l
	if m.Virtual_DNSRecord != nil {
		l = m.Virtual_DNSRecord.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Virtual_DNS) Size() (n int) {
	var l int
	_ = l
	if m.Virtual_DNS != nil {
		l = m.Virtual_DNS.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_VirtualIp) Size() (n int) {
	var l int
	_ = l
	if m.VirtualIp != nil {
		l = m.VirtualIp.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_VirtualMachineInterface) Size() (n int) {
	var l int
	_ = l
	if m.VirtualMachineInterface != nil {
		l = m.VirtualMachineInterface.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_VirtualMachine) Size() (n int) {
	var l int
	_ = l
	if m.VirtualMachine != nil {
		l = m.VirtualMachine.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_VirtualNetwork) Size() (n int) {
	var l int
	_ = l
	if m.VirtualNetwork != nil {
		l = m.VirtualNetwork.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_VirtualRouter) Size() (n int) {
	var l int
	_ = l
	if m.VirtualRouter != nil {
		l = m.VirtualRouter.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_AppformixNodeRole) Size() (n int) {
	var l int
	_ = l
	if m.AppformixNodeRole != nil {
		l = m.AppformixNodeRole.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_BaremetalNode) Size() (n int) {
	var l int
	_ = l
	if m.BaremetalNode != nil {
		l = m.BaremetalNode.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_BaremetalPort) Size() (n int) {
	var l int
	_ = l
	if m.BaremetalPort != nil {
		l = m.BaremetalPort.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ContrailAnalyticsDatabaseNodeRole) Size() (n int) {
	var l int
	_ = l
	if m.ContrailAnalyticsDatabaseNodeRole != nil {
		l = m.ContrailAnalyticsDatabaseNodeRole.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ContrailAnalyticsNode) Size() (n int) {
	var l int
	_ = l
	if m.ContrailAnalyticsNode != nil {
		l = m.ContrailAnalyticsNode.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ContrailCluster) Size() (n int) {
	var l int
	_ = l
	if m.ContrailCluster != nil {
		l = m.ContrailCluster.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ContrailControllerNodeRole) Size() (n int) {
	var l int
	_ = l
	if m.ContrailControllerNodeRole != nil {
		l = m.ContrailControllerNodeRole.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_ControllerNodeRole) Size() (n int) {
	var l int
	_ = l
	if m.ControllerNodeRole != nil {
		l = m.ControllerNodeRole.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Dashboard) Size() (n int) {
	var l int
	_ = l
	if m.Dashboard != nil {
		l = m.Dashboard.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Keypair) Size() (n int) {
	var l int
	_ = l
	if m.Keypair != nil {
		l = m.Keypair.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_KubernetesCluster) Size() (n int) {
	var l int
	_ = l
	if m.KubernetesCluster != nil {
		l = m.KubernetesCluster.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_KubernetesNode) Size() (n int) {
	var l int
	_ = l
	if m.KubernetesNode != nil {
		l = m.KubernetesNode.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Location) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Node) Size() (n int) {
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_OpenstackCluster) Size() (n int) {
	var l int
	_ = l
	if m.OpenstackCluster != nil {
		l = m.OpenstackCluster.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_OpenstackComputeNodeRole) Size() (n int) {
	var l int
	_ = l
	if m.OpenstackComputeNodeRole != nil {
		l = m.OpenstackComputeNodeRole.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_OpenstackStorageNodeRole) Size() (n int) {
	var l int
	_ = l
	if m.OpenstackStorageNodeRole != nil {
		l = m.OpenstackStorageNodeRole.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_VpnGroup) Size() (n int) {
	var l int
	_ = l
	if m.VpnGroup != nil {
		l = m.VpnGroup.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *Resource_Widget) Size() (n int) {
	var l int
	_ = l
	if m.Widget != nil {
		l = m.Widget.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}
func (m *AccessControlList) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AccessControlListHash)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AccessControlListEntries != nil {
		l = m.AccessControlListEntries.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *AddressGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AddressGroupPrefix != nil {
		l = m.AddressGroupPrefix.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Alarm) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AlarmRules != nil {
		l = m.AlarmRules.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.UveKeys != nil {
		l = m.UveKeys.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AlarmSeverity != 0 {
		n += 1 + sovContrail(uint64(m.AlarmSeverity))
	}
	return n
}

func (m *AliasIPPool) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *AliasIP) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AliasIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AliasIpAddressFamily)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *AnalyticsNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AnalyticsNodeIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *APIAccessList) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ApiAccessListEntries != nil {
		l = m.ApiAccessListEntries.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ApplicationPolicySet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AllApplications {
		n += 2
	}
	return n
}

func (m *BGPAsAService) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.BgpaasShared {
		n += 2
	}
	l = len(m.BgpaasSessionAttributes)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.BgpaasSuppressRouteAdvertisement {
		n += 2
	}
	if m.BgpaasIpv4MappedIpv6Nexthop {
		n += 2
	}
	l = len(m.BgpaasIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AutonomousSystem != 0 {
		n += 1 + sovContrail(uint64(m.AutonomousSystem))
	}
	return n
}

func (m *BGPRouter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *BGPVPN) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.RouteTargetList != nil {
		l = m.RouteTargetList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ImportRouteTargetList != nil {
		l = m.ImportRouteTargetList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ExportRouteTargetList != nil {
		l = m.ExportRouteTargetList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.BgpvpnType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *BridgeDomain) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MacAgingTime != 0 {
		n += 1 + sovContrail(uint64(m.MacAgingTime))
	}
	if m.Isid != 0 {
		n += 1 + sovContrail(uint64(m.Isid))
	}
	if m.MacLearningEnabled {
		n += 2
	}
	if m.MacMoveControl != nil {
		l = m.MacMoveControl.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MacLimitControl != nil {
		l = m.MacLimitControl.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ConfigNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ConfigNodeIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ConfigRoot) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *CustomerAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *DatabaseNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DatabaseNodeIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *DiscoveryServiceAssignment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Domain) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DomainLimits != nil {
		l = m.DomainLimits.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *DsaRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DsaRuleEntry != nil {
		l = m.DsaRuleEntry.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *E2ServiceProvider) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.E2ServiceProviderPromiscuous {
		n += 2
	}
	return n
}

func (m *FirewallPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FirewallRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Endpoint_1 != nil {
		l = m.Endpoint_1.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Endpoint_2 != nil {
		l = m.Endpoint_2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ActionList != nil {
		l = m.ActionList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MatchTagTypes != nil {
		l = m.MatchTagTypes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MatchTags != nil {
		l = m.MatchTags.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FloatingIPPool) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.FloatingIpPoolSubnets != nil {
		l = m.FloatingIpPoolSubnets.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FloatingIP) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.FloatingIpAddressFamily)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.FloatingIpPortMappings != nil {
		l = m.FloatingIpPortMappings.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.FloatingIpIsVirtualIp {
		n += 2
	}
	l = len(m.FloatingIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.FloatingIpPortMappingsEnable {
		n += 2
	}
	l = len(m.FloatingIpFixedIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.FloatingIpTrafficDirection)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ForwardingClass) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ForwardingClassDscp != 0 {
		n += 1 + sovContrail(uint64(m.ForwardingClassDscp))
	}
	if m.ForwardingClassVlanPriority != 0 {
		n += 1 + sovContrail(uint64(m.ForwardingClassVlanPriority))
	}
	if m.ForwardingClassMplsExp != 0 {
		n += 1 + sovContrail(uint64(m.ForwardingClassMplsExp))
	}
	if m.ForwardingClassId != 0 {
		n += 1 + sovContrail(uint64(m.ForwardingClassId))
	}
	return n
}

func (m *GlobalQosConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ControlTrafficDscp != nil {
		l = m.ControlTrafficDscp.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *GlobalSystemConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ConfigVersion)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.BgpaasParameters != nil {
		l = m.BgpaasParameters.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AlarmEnable {
		n += 2
	}
	if m.MacMoveControl != nil {
		l = m.MacMoveControl.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.PluginTuning != nil {
		l = m.PluginTuning.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.IbgpAutoMesh {
		n += 2
	}
	if m.MacAgingTime != 0 {
		n += 1 + sovContrail(uint64(m.MacAgingTime))
	}
	if m.BgpAlwaysCompareMed {
		n += 3
	}
	if m.UserDefinedLogStatistics != nil {
		l = m.UserDefinedLogStatistics.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.GracefulRestartParameters != nil {
		l = m.GracefulRestartParameters.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.IpFabricSubnets != nil {
		l = m.IpFabricSubnets.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.AutonomousSystem != 0 {
		n += 2 + sovContrail(uint64(m.AutonomousSystem))
	}
	if m.MacLimitControl != nil {
		l = m.MacLimitControl.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *GlobalVrouterConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.EcmpHashingIncludeFields != nil {
		l = m.EcmpHashingIncludeFields.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.FlowAgingTimeoutList != nil {
		l = m.FlowAgingTimeoutList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ForwardingMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.FlowExportRate != 0 {
		n += 1 + sovContrail(uint64(m.FlowExportRate))
	}
	if m.LinklocalServices != nil {
		l = m.LinklocalServices.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.EncapsulationPriorities != nil {
		l = m.EncapsulationPriorities.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.VxlanNetworkIdentifierMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.EnableSecurityLogging {
		n += 3
	}
	return n
}

func (m *InstanceIP) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceHealthCheckIp {
		n += 2
	}
	if m.SecondaryIpTrackingIp != nil {
		l = m.SecondaryIpTrackingIp.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.InstanceIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.InstanceIpMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SubnetUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.InstanceIpFamily)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceInstanceIp {
		n += 2
	}
	if m.InstanceIpLocalIp {
		n += 3
	}
	if m.InstanceIpSecondary {
		n += 3
	}
	return n
}

func (m *InterfaceRouteTable) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.InterfaceRouteTableRoutes != nil {
		l = m.InterfaceRouteTableRoutes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *LoadbalancerHealthmonitor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.LoadbalancerHealthmonitorProperties != nil {
		l = m.LoadbalancerHealthmonitorProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *LoadbalancerListener) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.LoadbalancerListenerProperties != nil {
		l = m.LoadbalancerListenerProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *LoadbalancerMember) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.LoadbalancerMemberProperties != nil {
		l = m.LoadbalancerMemberProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *LoadbalancerPool) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.LoadbalancerPoolProperties != nil {
		l = m.LoadbalancerPoolProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.LoadbalancerPoolCustomAttributes != nil {
		l = m.LoadbalancerPoolCustomAttributes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.LoadbalancerPoolProvider)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Loadbalancer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.LoadbalancerProperties != nil {
		l = m.LoadbalancerProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.LoadbalancerProvider)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *LogicalInterface) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.LogicalInterfaceVlanTag != 0 {
		n += 1 + sovContrail(uint64(m.LogicalInterfaceVlanTag))
	}
	l = len(m.LogicalInterfaceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *LogicalRouter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.VxlanNetworkIdentifier)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ConfiguredRouteTargetList != nil {
		l = m.ConfiguredRouteTargetList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Namespace) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.NamespaceCidr != nil {
		l = m.NamespaceCidr.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *NetworkDeviceConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *NetworkIpam) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.NetworkIpamMgmt != nil {
		l = m.NetworkIpamMgmt.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.IpamSubnets != nil {
		l = m.IpamSubnets.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.IpamSubnetMethod)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *NetworkPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.NetworkPolicyEntries != nil {
		l = m.NetworkPolicyEntries.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PeeringPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PeeringService)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PhysicalInterface) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.EthernetSegmentIdentifier)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PhysicalRouter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PhysicalRouterManagementIp)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.PhysicalRouterSnmpCredentials != nil {
		l = m.PhysicalRouterSnmpCredentials.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PhysicalRouterRole)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.PhysicalRouterUserCredentials != nil {
		l = m.PhysicalRouterUserCredentials.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PhysicalRouterVendorName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.PhysicalRouterVncManaged {
		n += 2
	}
	l = len(m.PhysicalRouterProductName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.PhysicalRouterLldp {
		n += 3
	}
	l = len(m.PhysicalRouterLoopbackIp)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PhysicalRouterImageUri)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.TelemetryInfo != nil {
		l = m.TelemetryInfo.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.PhysicalRouterSnmp {
		n += 3
	}
	l = len(m.PhysicalRouterDataplaneIp)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.PhysicalRouterJunosServicePorts != nil {
		l = m.PhysicalRouterJunosServicePorts.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PolicyManagement) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PortTuple) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Project) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VxlanRouting {
		n += 2
	}
	if m.AlarmEnable {
		n += 2
	}
	if m.Quota != nil {
		l = m.Quota.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ProviderAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *QosConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.QosConfigType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MplsExpEntries != nil {
		l = m.MplsExpEntries.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VlanPriorityEntries != nil {
		l = m.VlanPriorityEntries.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DefaultForwardingClassId != 0 {
		n += 1 + sovContrail(uint64(m.DefaultForwardingClassId))
	}
	if m.DscpEntries != nil {
		l = m.DscpEntries.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *QosQueue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.QosQueueIdentifier != 0 {
		n += 1 + sovContrail(uint64(m.QosQueueIdentifier))
	}
	if m.MaxBandwidth != 0 {
		n += 1 + sovContrail(uint64(m.MaxBandwidth))
	}
	if m.MinBandwidth != 0 {
		n += 1 + sovContrail(uint64(m.MinBandwidth))
	}
	return n
}

func (m *RouteAggregate) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *RouteTable) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Routes != nil {
		l = m.Routes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *RouteTarget) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *RoutingInstance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *RoutingPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *SecurityGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.SecurityGroupEntries != nil {
		l = m.SecurityGroupEntries.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ConfiguredSecurityGroupId != 0 {
		n += 1 + sovContrail(uint64(m.ConfiguredSecurityGroupId))
	}
	if m.SecurityGroupId != 0 {
		n += 1 + sovContrail(uint64(m.SecurityGroupId))
	}
	return n
}

func (m *SecurityLoggingObject) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.SecurityLoggingObjectRules != nil {
		l = m.SecurityLoggingObjectRules.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.SecurityLoggingObjectRate != 0 {
		n += 1 + sovContrail(uint64(m.SecurityLoggingObjectRate))
	}
	return n
}

func (m *ServiceAppliance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceApplianceUserCredentials != nil {
		l = m.ServiceApplianceUserCredentials.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ServiceApplianceIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceApplianceProperties != nil {
		l = m.ServiceApplianceProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceApplianceSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceApplianceSetProperties != nil {
		l = m.ServiceApplianceSetProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ServiceApplianceHaMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ServiceApplianceDriver)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceConnectionModule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.E2Service)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceEndpoint) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceGroupFirewallServiceList != nil {
		l = m.ServiceGroupFirewallServiceList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceHealthCheck) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceHealthCheckProperties != nil {
		l = m.ServiceHealthCheckProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceInstance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceInstanceBindings != nil {
		l = m.ServiceInstanceBindings.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceInstanceProperties != nil {
		l = m.ServiceInstanceProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceObject) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceTemplate) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceTemplateProperties != nil {
		l = m.ServiceTemplateProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Subnet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.SubnetIpPrefix != nil {
		l = m.SubnetIpPrefix.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Tag) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.TagTypeName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.TagId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.TagValue)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *TagType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.TagTypeId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VirtualDNSRecord) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Virtual_DNSRecordData != nil {
		l = m.Virtual_DNSRecordData.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VirtualDNS) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Virtual_DNSData != nil {
		l = m.Virtual_DNSData.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VirtualIP) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualIpProperties != nil {
		l = m.VirtualIpProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VirtualMachineInterface) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.EcmpHashingIncludeFields != nil {
		l = m.EcmpHashingIncludeFields.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualMachineInterfaceHostRoutes != nil {
		l = m.VirtualMachineInterfaceHostRoutes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualMachineInterfaceMacAddresses != nil {
		l = m.VirtualMachineInterfaceMacAddresses.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualMachineInterfaceDhcpOptionList != nil {
		l = m.VirtualMachineInterfaceDhcpOptionList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualMachineInterfaceBindings != nil {
		l = m.VirtualMachineInterfaceBindings.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualMachineInterfaceDisablePolicy {
		n += 2
	}
	if m.VirtualMachineInterfaceAllowedAddressPairs != nil {
		l = m.VirtualMachineInterfaceAllowedAddressPairs.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualMachineInterfaceFatFlowProtocols != nil {
		l = m.VirtualMachineInterfaceFatFlowProtocols.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.VlanTagBasedBridgeDomain {
		n += 3
	}
	l = len(m.VirtualMachineInterfaceDeviceOwner)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.VrfAssignTable != nil {
		l = m.VrfAssignTable.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.PortSecurityEnabled {
		n += 3
	}
	if m.VirtualMachineInterfaceProperties != nil {
		l = m.VirtualMachineInterfaceProperties.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VirtualMachine) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VirtualNetwork) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualNetworkProperties != nil {
		l = m.VirtualNetworkProperties.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.EcmpHashingIncludeFields != nil {
		l = m.EcmpHashingIncludeFields.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualNetworkNetworkId != 0 {
		n += 1 + sovContrail(uint64(m.VirtualNetworkNetworkId))
	}
	l = len(m.AddressAllocationMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.PbbEvpnEnable {
		n += 2
	}
	if m.RouterExternal {
		n += 2
	}
	if m.ImportRouteTargetList != nil {
		l = m.ImportRouteTargetList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MacAgingTime != 0 {
		n += 2 + sovContrail(uint64(m.MacAgingTime))
	}
	if m.ProviderProperties != nil {
		l = m.ProviderProperties.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.RouteTargetList != nil {
		l = m.RouteTargetList.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.MacLearningEnabled {
		n += 3
	}
	if m.ExportRouteTargetList != nil {
		l = m.ExportRouteTargetList.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.FloodUnknownUnicast {
		n += 3
	}
	if m.PbbEtreeEnable {
		n += 3
	}
	if m.Layer2ControlWord {
		n += 3
	}
	if m.ExternalIpam {
		n += 3
	}
	if m.PortSecurityEnabled {
		n += 3
	}
	if m.MacMoveControl != nil {
		l = m.MacMoveControl.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.MultiPolicyServiceChainsEnabled {
		n += 3
	}
	if m.MacLimitControl != nil {
		l = m.MacLimitControl.Size()
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.IsShared {
		n += 3
	}
	return n
}

func (m *VirtualRouter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VirtualRouterDpdkEnabled {
		n += 2
	}
	l = len(m.VirtualRouterType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.VirtualRouterIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *AppformixNodeRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *BaremetalNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.IpmiAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.IpmiUsername)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.IpmiPassword)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.CpuCount != 0 {
		n += 1 + sovContrail(uint64(m.CpuCount))
	}
	l = len(m.CpuArch)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DiskGb != 0 {
		n += 1 + sovContrail(uint64(m.DiskGb))
	}
	if m.MemoryMb != 0 {
		n += 2 + sovContrail(uint64(m.MemoryMb))
	}
	l = len(m.DeployKernel)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.DeployRamdisk)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *BaremetalPort) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SwitchId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SwitchInfo)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.PxeEnabled {
		n += 2
	}
	return n
}

func (m *ContrailAnalyticsDatabaseNodeRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ContrailAnalyticsNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ContrailCluster) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ConfigAuditTtl)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ContrailWebui)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DataTtl)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultGateway)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultVrouterBondInterface)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultVrouterBondInterfaceMembers)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.FlowTtl)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.StatisticsTtl)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ContrailControllerNodeRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ControllerNodeRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.CapacityDrives)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.InternalapiBondInterfaceMembers)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PerformanceDrives)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.StorageManagementBondInterfaceMembers)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Dashboard) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ContainerConfig)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Keypair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *KubernetesCluster) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ContrailClusterId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.KuberunetesDashboard)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *KubernetesNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateDnsServers)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateNtpHosts)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateOspdPackageUrl)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateOspdUserName)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateOspdUserPassword)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateOspdVmDiskGb)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateOspdVmName)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateOspdVmRamMb)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateOspdVmVcpus)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateRedhatPoolId)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateRedhatSubscriptionKey)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateRedhatSubscriptionPasword)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateRedhatSubscriptionUser)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.GcpAccountInfo)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.GcpAsn != 0 {
		n += 2 + sovContrail(uint64(m.GcpAsn))
	}
	l = len(m.GcpRegion)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.GcpSubnet)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.AwsAccessKey)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.AwsRegion)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.AwsSecretKey)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.AwsSubnet)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AwsAmi)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.AwsInstanceType)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.GcpImage)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.GcpMachineType)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateMachineProperties)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivateMachineState)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivatePowerManagementIp)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivatePowerManagementPassword)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PrivatePowerManagementUsername)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *OpenstackCluster) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AdminPassword)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ContrailClusterId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultCapacityDrives)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultJournalDrives)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultOsdDrives)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultPerformanceDrives)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultStorageAccessBondInterfaceMembers)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultStorageBackendBondInterfaceMembers)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.ExternalAllocationPoolEnd)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.ExternalAllocationPoolStart)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.ExternalNetCidr)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.OpenstackWebui)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PublicGateway)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.PublicIp)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *OpenstackComputeNodeRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DefaultGateway)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.VrouterBondInterface)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.VrouterBondInterfaceMembers)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.VrouterType)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *OpenstackStorageNodeRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.JournalDrives)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.OsdDrives)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.StorageAccessBondInterfaceMembers)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	l = len(m.StorageBackendBondInterfaceMembers)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VPNGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProvisioningLog)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProvisioningProgress != 0 {
		n += 1 + sovContrail(uint64(m.ProvisioningProgress))
	}
	l = len(m.ProvisioningProgressStage)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *Widget) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ParentType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.FqName) > 0 {
		for _, s := range m.FqName {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.IdPerms != nil {
		l = m.IdPerms.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Perms2 != nil {
		l = m.Perms2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ContainerConfig)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ContentConfig)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.LayoutConfig)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PermType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.OwnerAccess != 0 {
		n += 1 + sovContrail(uint64(m.OwnerAccess))
	}
	if m.OtherAccess != 0 {
		n += 1 + sovContrail(uint64(m.OtherAccess))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.GroupAccess != 0 {
		n += 1 + sovContrail(uint64(m.GroupAccess))
	}
	return n
}

func (m *LoadbalancerHealthmonitorType) Size() (n int) {
	var l int
	_ = l
	if m.Delay != 0 {
		n += 1 + sovContrail(uint64(m.Delay))
	}
	l = len(m.ExpectedCodes)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MaxRetries != 0 {
		n += 1 + sovContrail(uint64(m.MaxRetries))
	}
	l = len(m.HttpMethod)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AdminState {
		n += 2
	}
	if m.Timeout != 0 {
		n += 1 + sovContrail(uint64(m.Timeout))
	}
	l = len(m.UrlPath)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.MonitorType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *SNMPCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.V3PrivacyProtocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Retries != 0 {
		n += 1 + sovContrail(uint64(m.Retries))
	}
	l = len(m.V3AuthenticationPassword)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.V3EngineTime != 0 {
		n += 1 + sovContrail(uint64(m.V3EngineTime))
	}
	l = len(m.V3EngineId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.LocalPort != 0 {
		n += 1 + sovContrail(uint64(m.LocalPort))
	}
	l = len(m.V3SecurityLevel)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.V3Context)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.V3SecurityName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.V3AuthenticationProtocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.V2Community)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.V3SecurityEngineId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.V3ContextEngineId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovContrail(uint64(m.Version))
	}
	if m.Timeout != 0 {
		n += 1 + sovContrail(uint64(m.Timeout))
	}
	l = len(m.V3PrivacyPassword)
	if l > 0 {
		n += 2 + l + sovContrail(uint64(l))
	}
	if m.V3EngineBoots != 0 {
		n += 2 + sovContrail(uint64(m.V3EngineBoots))
	}
	return n
}

func (m *PolicyBasedForwardingRuleType) Size() (n int) {
	var l int
	_ = l
	l = len(m.DstMac)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Ipv6ServiceChainAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MplsLabel != 0 {
		n += 1 + sovContrail(uint64(m.MplsLabel))
	}
	if m.VlanTag != 0 {
		n += 1 + sovContrail(uint64(m.VlanTag))
	}
	l = len(m.SrcMac)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ServiceChainAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VirtualMachineInterfacePropertiesType) Size() (n int) {
	var l int
	_ = l
	if m.SubInterfaceVlanTag != 0 {
		n += 1 + sovContrail(uint64(m.SubInterfaceVlanTag))
	}
	if m.LocalPreference != 0 {
		n += 1 + sovContrail(uint64(m.LocalPreference))
	}
	if m.InterfaceMirror != nil {
		l = m.InterfaceMirror.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ServiceInterfaceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VirtualNetworkPolicyType) Size() (n int) {
	var l int
	_ = l
	if m.Timer != nil {
		l = m.Timer.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Sequence != nil {
		l = m.Sequence.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ShareType) Size() (n int) {
	var l int
	_ = l
	if m.TenantAccess != 0 {
		n += 1 + sovContrail(uint64(m.TenantAccess))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *StaticMirrorNhType) Size() (n int) {
	var l int
	_ = l
	l = len(m.VtepDstIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.VtepDstMacAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Vni != 0 {
		n += 1 + sovContrail(uint64(m.Vni))
	}
	return n
}

func (m *FirewallRuleMatchTagsTypeIdList) Size() (n int) {
	var l int
	_ = l
	if len(m.TagType) > 0 {
		l = 0
		for _, e := range m.TagType {
			l += sovContrail(uint64(e))
		}
		n += 1 + sovContrail(uint64(l)) + l
	}
	return n
}

func (m *CommunityAttributes) Size() (n int) {
	var l int
	_ = l
	if len(m.CommunityAttribute) > 0 {
		for _, b := range m.CommunityAttribute {
			l = len(b)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *IpAddressesType) Size() (n int) {
	var l int
	_ = l
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceTemplateInterfaceType) Size() (n int) {
	var l int
	_ = l
	if m.StaticRouteEnable {
		n += 2
	}
	if m.SharedIp {
		n += 2
	}
	l = len(m.ServiceInterfaceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *IdPermsType) Size() (n int) {
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.UserVisible {
		n += 2
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *RbacPermType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoleCrud)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.RoleName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FlowAgingTimeoutList) Size() (n int) {
	var l int
	_ = l
	if len(m.FlowAgingTimeout) > 0 {
		for _, e := range m.FlowAgingTimeout {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *UveKeysType) Size() (n int) {
	var l int
	_ = l
	if len(m.UveKey) > 0 {
		for _, s := range m.UveKey {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *DiscoveryServiceAssignmentType) Size() (n int) {
	var l int
	_ = l
	if len(m.Subscriber) > 0 {
		for _, e := range m.Subscriber {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.Publisher != nil {
		l = m.Publisher.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *GracefulRestartParametersType) Size() (n int) {
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	if m.EndOfRibTimeout != 0 {
		n += 1 + sovContrail(uint64(m.EndOfRibTimeout))
	}
	if m.BgpHelperEnable {
		n += 2
	}
	if m.XmppHelperEnable {
		n += 2
	}
	if m.RestartTime != 0 {
		n += 1 + sovContrail(uint64(m.RestartTime))
	}
	if m.LongLivedRestartTime != 0 {
		n += 1 + sovContrail(uint64(m.LongLivedRestartTime))
	}
	return n
}

func (m *ServiceInterfaceTag) Size() (n int) {
	var l int
	_ = l
	l = len(m.InterfaceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *AllocationPoolType) Size() (n int) {
	var l int
	_ = l
	if m.VrouterSpecificPool {
		n += 2
	}
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PolicyRuleType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.DstAddresses) > 0 {
		for _, e := range m.DstAddresses {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.ActionList != nil {
		l = m.ActionList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.RuleUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.DstPorts) > 0 {
		for _, e := range m.DstPorts {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if len(m.Application) > 0 {
		for _, s := range m.Application {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Ethertype)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.SrcAddresses) > 0 {
		for _, e := range m.SrcAddresses {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.RuleSequence != nil {
		l = m.RuleSequence.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.SrcPorts) > 0 {
		for _, e := range m.SrcPorts {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *VirtualDnsRecordType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RecordName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.RecordClass)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.RecordData)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.RecordType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.RecordTtlSeconds != 0 {
		n += 1 + sovContrail(uint64(m.RecordTtlSeconds))
	}
	if m.RecordMxPreference != 0 {
		n += 1 + sovContrail(uint64(m.RecordMxPreference))
	}
	return n
}

func (m *AlarmExpression) Size() (n int) {
	var l int
	_ = l
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Operand1)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.Variables) > 0 {
		for _, s := range m.Variables {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.Operand2 != nil {
		l = m.Operand2.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FirewallServiceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DstPorts != nil {
		l = m.DstPorts.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.SrcPorts != nil {
		l = m.SrcPorts.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProtocolId != 0 {
		n += 1 + sovContrail(uint64(m.ProtocolId))
	}
	return n
}

func (m *RoutingPolicyServiceInstanceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RightSequence)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.LeftSequence)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *TimerType) Size() (n int) {
	var l int
	_ = l
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.OffInterval)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.OnInterval)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FirewallRuleEndpointType) Size() (n int) {
	var l int
	_ = l
	l = len(m.AddressGroup)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if len(m.TagIds) > 0 {
		l = 0
		for _, e := range m.TagIds {
			l += sovContrail(uint64(e))
		}
		n += 1 + sovContrail(uint64(l)) + l
	}
	l = len(m.VirtualNetwork)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Any {
		n += 2
	}
	return n
}

func (m *InterfaceMirrorType) Size() (n int) {
	var l int
	_ = l
	l = len(m.TrafficDirection)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MirrorTo != nil {
		l = m.MirrorTo.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *VirtualNetworkType) Size() (n int) {
	var l int
	_ = l
	l = len(m.ForwardingMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AllowTransit {
		n += 2
	}
	if m.NetworkId != 0 {
		n += 1 + sovContrail(uint64(m.NetworkId))
	}
	if m.MirrorDestination {
		n += 2
	}
	if m.VxlanNetworkIdentifier != 0 {
		n += 1 + sovContrail(uint64(m.VxlanNetworkIdentifier))
	}
	l = len(m.Rpf)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PortType) Size() (n int) {
	var l int
	_ = l
	if m.EndPort != 0 {
		n += 1 + sovContrail(uint64(m.EndPort))
	}
	if m.StartPort != 0 {
		n += 1 + sovContrail(uint64(m.StartPort))
	}
	return n
}

func (m *PortMappings) Size() (n int) {
	var l int
	_ = l
	if len(m.PortMappings) > 0 {
		for _, e := range m.PortMappings {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *ServiceInstanceInterfaceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.VirtualNetwork)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AllowedAddressPairs != nil {
		l = m.AllowedAddressPairs.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.StaticRoutes != nil {
		l = m.StaticRoutes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *SequenceType) Size() (n int) {
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovContrail(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovContrail(uint64(m.Minor))
	}
	return n
}

func (m *SecurityLoggingObjectRuleEntryType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RuleUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Rate != 0 {
		n += 1 + sovContrail(uint64(m.Rate))
	}
	return n
}

func (m *SubnetType) Size() (n int) {
	var l int
	_ = l
	l = len(m.IpPrefix)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.IpPrefixLen != 0 {
		n += 1 + sovContrail(uint64(m.IpPrefixLen))
	}
	return n
}

func (m *RouteTargetList) Size() (n int) {
	var l int
	_ = l
	if len(m.RouteTarget) > 0 {
		for _, s := range m.RouteTarget {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *LinklocalServiceEntryType) Size() (n int) {
	var l int
	_ = l
	if len(m.IpFabricServiceIp) > 0 {
		for _, s := range m.IpFabricServiceIp {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	l = len(m.LinklocalServiceName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.LinklocalServiceIp)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.IpFabricServicePort != 0 {
		n += 1 + sovContrail(uint64(m.IpFabricServicePort))
	}
	l = len(m.IpFabric_DNSServiceName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.LinklocalServicePort != 0 {
		n += 1 + sovContrail(uint64(m.LinklocalServicePort))
	}
	return n
}

func (m *IpamSubnetType) Size() (n int) {
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AddrFromStart {
		n += 2
	}
	if m.EnableDhcp {
		n += 2
	}
	l = len(m.DefaultGateway)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AllocUnit != 0 {
		n += 1 + sovContrail(uint64(m.AllocUnit))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.DnsNameservers) > 0 {
		for _, s := range m.DnsNameservers {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.DhcpOptionList != nil {
		l = m.DhcpOptionList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SubnetUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.AllocationPools) > 0 {
		for _, e := range m.AllocationPools {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.HostRoutes != nil {
		l = m.HostRoutes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DnsServerAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *QuotaType) Size() (n int) {
	var l int
	_ = l
	if m.VirtualRouter != 0 {
		n += 1 + sovContrail(uint64(m.VirtualRouter))
	}
	if m.NetworkPolicy != 0 {
		n += 1 + sovContrail(uint64(m.NetworkPolicy))
	}
	if m.LoadbalancerPool != 0 {
		n += 1 + sovContrail(uint64(m.LoadbalancerPool))
	}
	if m.RouteTable != 0 {
		n += 1 + sovContrail(uint64(m.RouteTable))
	}
	if m.Subnet != 0 {
		n += 1 + sovContrail(uint64(m.Subnet))
	}
	if m.NetworkIpam != 0 {
		n += 1 + sovContrail(uint64(m.NetworkIpam))
	}
	if m.Virtual_DNSRecord != 0 {
		n += 1 + sovContrail(uint64(m.Virtual_DNSRecord))
	}
	if m.LogicalRouter != 0 {
		n += 1 + sovContrail(uint64(m.LogicalRouter))
	}
	if m.SecurityGroupRule != 0 {
		n += 1 + sovContrail(uint64(m.SecurityGroupRule))
	}
	if m.Virtual_DNS != 0 {
		n += 1 + sovContrail(uint64(m.Virtual_DNS))
	}
	if m.ServiceInstance != 0 {
		n += 1 + sovContrail(uint64(m.ServiceInstance))
	}
	if m.ServiceTemplate != 0 {
		n += 1 + sovContrail(uint64(m.ServiceTemplate))
	}
	if m.BgpRouter != 0 {
		n += 1 + sovContrail(uint64(m.BgpRouter))
	}
	if m.FloatingIp != 0 {
		n += 1 + sovContrail(uint64(m.FloatingIp))
	}
	if m.FloatingIpPool != 0 {
		n += 1 + sovContrail(uint64(m.FloatingIpPool))
	}
	if m.LoadbalancerMember != 0 {
		n += 2 + sovContrail(uint64(m.LoadbalancerMember))
	}
	if m.AccessControlList != 0 {
		n += 2 + sovContrail(uint64(m.AccessControlList))
	}
	if m.VirtualMachineInterface != 0 {
		n += 2 + sovContrail(uint64(m.VirtualMachineInterface))
	}
	if m.InstanceIp != 0 {
		n += 2 + sovContrail(uint64(m.InstanceIp))
	}
	if m.GlobalVrouterConfig != 0 {
		n += 2 + sovContrail(uint64(m.GlobalVrouterConfig))
	}
	if m.SecurityLoggingObject != 0 {
		n += 2 + sovContrail(uint64(m.SecurityLoggingObject))
	}
	if m.LoadbalancerHealthmonitor != 0 {
		n += 2 + sovContrail(uint64(m.LoadbalancerHealthmonitor))
	}
	if m.VirtualIp != 0 {
		n += 2 + sovContrail(uint64(m.VirtualIp))
	}
	if m.Defaults != 0 {
		n += 2 + sovContrail(uint64(m.Defaults))
	}
	if m.SecurityGroup != 0 {
		n += 2 + sovContrail(uint64(m.SecurityGroup))
	}
	if m.VirtualNetwork != 0 {
		n += 2 + sovContrail(uint64(m.VirtualNetwork))
	}
	return n
}

func (m *KeyValuePairs) Size() (n int) {
	var l int
	_ = l
	if len(m.KeyValuePair) > 0 {
		for _, e := range m.KeyValuePair {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *TelemetryStateInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for _, e := range m.Resource {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.ServerPort != 0 {
		n += 1 + sovContrail(uint64(m.ServerPort))
	}
	l = len(m.ServerIp)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FirewallRuleMatchTagsType) Size() (n int) {
	var l int
	_ = l
	if len(m.TagList) > 0 {
		for _, s := range m.TagList {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *LinklocalServicesTypes) Size() (n int) {
	var l int
	_ = l
	if len(m.LinklocalServiceEntry) > 0 {
		for _, e := range m.LinklocalServiceEntry {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *RouteTableType) Size() (n int) {
	var l int
	_ = l
	if len(m.Route) > 0 {
		for _, e := range m.Route {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *MacAddressesType) Size() (n int) {
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		for _, s := range m.MacAddress {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *VrfAssignRuleType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoutingInstance)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MatchCondition != nil {
		l = m.MatchCondition.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.VlanTag != 0 {
		n += 1 + sovContrail(uint64(m.VlanTag))
	}
	if m.IgnoreAcl {
		n += 2
	}
	return n
}

func (m *ActionListType) Size() (n int) {
	var l int
	_ = l
	l = len(m.GatewayName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Log {
		n += 2
	}
	if m.Alert {
		n += 2
	}
	l = len(m.QosAction)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AssignRoutingInstance)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MirrorTo != nil {
		l = m.MirrorTo.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SimpleAction)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.ApplyService) > 0 {
		for _, s := range m.ApplyService {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *AclEntriesType) Size() (n int) {
	var l int
	_ = l
	if m.Dynamic {
		n += 2
	}
	if len(m.AclRule) > 0 {
		for _, e := range m.AclRule {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *VirtualIpType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.StatusDescription)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.PersistenceCookieName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ConnectionLimit != 0 {
		n += 1 + sovContrail(uint64(m.ConnectionLimit))
	}
	l = len(m.PersistenceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AdminState {
		n += 2
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProtocolPort != 0 {
		n += 1 + sovContrail(uint64(m.ProtocolPort))
	}
	return n
}

func (m *RouteType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.NextHop)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.CommunityAttributes != nil {
		l = m.CommunityAttributes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.NextHopType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *LoadbalancerType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ProvisioningStatus)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AdminState {
		n += 2
	}
	l = len(m.VipAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.VipSubnetId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.OperatingStatus)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ProtocolType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovContrail(uint64(m.Port))
	}
	return n
}

func (m *ServiceInstanceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RightVirtualNetwork)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.RightIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ManagementVirtualNetwork)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ScaleOut != nil {
		l = m.ScaleOut.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.HaMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.VirtualRouterId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.InterfaceList) > 0 {
		for _, e := range m.InterfaceList {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	l = len(m.LeftIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.LeftVirtualNetwork)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AutoPolicy {
		n += 2
	}
	return n
}

func (m *MatchConditionType) Size() (n int) {
	var l int
	_ = l
	if m.SrcPort != nil {
		l = m.SrcPort.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.SrcAddress != nil {
		l = m.SrcAddress.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Ethertype)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DstAddress != nil {
		l = m.DstAddress.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DstPort != nil {
		l = m.DstPort.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *LoadbalancerMemberType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.StatusDescription)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovContrail(uint64(m.Weight))
	}
	if m.AdminState {
		n += 2
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ProtocolPort != 0 {
		n += 1 + sovContrail(uint64(m.ProtocolPort))
	}
	return n
}

func (m *UserCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *AllowedAddressPairs) Size() (n int) {
	var l int
	_ = l
	if len(m.AllowedAddressPair) > 0 {
		for _, e := range m.AllowedAddressPair {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *TelemetryResourceInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Rate)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ControlTrafficDscpType) Size() (n int) {
	var l int
	_ = l
	if m.Control != 0 {
		n += 1 + sovContrail(uint64(m.Control))
	}
	if m.Analytics != 0 {
		n += 1 + sovContrail(uint64(m.Analytics))
	}
	if m.Dns != 0 {
		n += 1 + sovContrail(uint64(m.Dns))
	}
	return n
}

func (m *UserDefinedLogStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *LoadbalancerPoolType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.SessionPersistence)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.AdminState {
		n += 2
	}
	l = len(m.PersistenceCookieName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.StatusDescription)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.LoadbalancerMethod)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *KeyValuePair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *IpamSubnets) Size() (n int) {
	var l int
	_ = l
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *LoadbalancerListenerType) Size() (n int) {
	var l int
	_ = l
	l = len(m.DefaultTlsContainer)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ConnectionLimit != 0 {
		n += 1 + sovContrail(uint64(m.ConnectionLimit))
	}
	if m.AdminState {
		n += 2
	}
	if len(m.SniContainers) > 0 {
		for _, s := range m.SniContainers {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.ProtocolPort != 0 {
		n += 1 + sovContrail(uint64(m.ProtocolPort))
	}
	return n
}

func (m *BridgeDomainMembershipType) Size() (n int) {
	var l int
	_ = l
	if m.VlanTag != 0 {
		n += 1 + sovContrail(uint64(m.VlanTag))
	}
	return n
}

func (m *VnSubnetsType) Size() (n int) {
	var l int
	_ = l
	if len(m.IpamSubnets) > 0 {
		for _, e := range m.IpamSubnets {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if m.HostRoutes != nil {
		l = m.HostRoutes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *ServiceApplianceInterfaceType) Size() (n int) {
	var l int
	_ = l
	l = len(m.InterfaceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *SubnetListType) Size() (n int) {
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		for _, e := range m.Subnet {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *BGPaaServiceParametersType) Size() (n int) {
	var l int
	_ = l
	if m.PortStart != 0 {
		n += 1 + sovContrail(uint64(m.PortStart))
	}
	if m.PortEnd != 0 {
		n += 1 + sovContrail(uint64(m.PortEnd))
	}
	return n
}

func (m *IpamDnsAddressType) Size() (n int) {
	var l int
	_ = l
	if m.TenantDnsServerAddress != nil {
		l = m.TenantDnsServerAddress.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.VirtualDnsServerName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *DhcpOptionsListType) Size() (n int) {
	var l int
	_ = l
	if len(m.DhcpOption) > 0 {
		for _, e := range m.DhcpOption {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *MACLimitControlType) Size() (n int) {
	var l int
	_ = l
	if m.MacLimit != 0 {
		n += 1 + sovContrail(uint64(m.MacLimit))
	}
	l = len(m.MacLimitAction)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *UserDefinedLogStatList) Size() (n int) {
	var l int
	_ = l
	if len(m.Statlist) > 0 {
		for _, e := range m.Statlist {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *EcmpHashingIncludeFields) Size() (n int) {
	var l int
	_ = l
	if m.DestinationIp {
		n += 2
	}
	if m.IpProtocol {
		n += 2
	}
	if m.SourceIp {
		n += 2
	}
	if m.HashingConfigured {
		n += 2
	}
	if m.SourcePort {
		n += 2
	}
	if m.DestinationPort {
		n += 2
	}
	return n
}

func (m *EncapsulationPrioritiesType) Size() (n int) {
	var l int
	_ = l
	if len(m.Encapsulation) > 0 {
		for _, b := range m.Encapsulation {
			l = len(b)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *VirtualRouterNetworkIpamType) Size() (n int) {
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		for _, e := range m.Subnet {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	if len(m.AllocationPools) > 0 {
		for _, e := range m.AllocationPools {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *VirtualDnsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.FloatingIpRecord)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DomainName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ExternalVisible {
		n += 2
	}
	l = len(m.NextVirtual_DNS)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DynamicRecordsFromClient {
		n += 2
	}
	if m.ReverseResolution {
		n += 2
	}
	if m.DefaultTtlSeconds != 0 {
		n += 1 + sovContrail(uint64(m.DefaultTtlSeconds))
	}
	l = len(m.RecordOrder)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FirewallSequence) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sequence)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *MirrorActionType) Size() (n int) {
	var l int
	_ = l
	if m.NicAssistedMirroringVlan != 0 {
		n += 1 + sovContrail(uint64(m.NicAssistedMirroringVlan))
	}
	l = len(m.AnalyzerName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.NhMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.JuniperHeader {
		n += 2
	}
	if m.UdpPort != 0 {
		n += 1 + sovContrail(uint64(m.UdpPort))
	}
	l = len(m.RoutingInstance)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.StaticNhHeader != nil {
		l = m.StaticNhHeader.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AnalyzerIpAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Encapsulation)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AnalyzerMacAddress)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.NicAssistedMirroring {
		n += 2
	}
	return n
}

func (m *IpamType) Size() (n int) {
	var l int
	_ = l
	l = len(m.IpamMethod)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.IpamDnsMethod)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.IpamDnsServer != nil {
		l = m.IpamDnsServer.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DhcpOptionList != nil {
		l = m.DhcpOptionList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.HostRoutes != nil {
		l = m.HostRoutes.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.CidrBlock != nil {
		l = m.CidrBlock.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *JunosServicePorts) Size() (n int) {
	var l int
	_ = l
	if len(m.ServicePort) > 0 {
		for _, s := range m.ServicePort {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *AlarmOperand2) Size() (n int) {
	var l int
	_ = l
	l = len(m.UveAttribute)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.JsonValue)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *RbacRuleType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RuleObject)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.RulePerms) > 0 {
		for _, e := range m.RulePerms {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	l = len(m.RuleField)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *DomainLimitsType) Size() (n int) {
	var l int
	_ = l
	if m.ProjectLimit != 0 {
		n += 1 + sovContrail(uint64(m.ProjectLimit))
	}
	if m.VirtualNetworkLimit != 0 {
		n += 1 + sovContrail(uint64(m.VirtualNetworkLimit))
	}
	if m.SecurityGroupLimit != 0 {
		n += 1 + sovContrail(uint64(m.SecurityGroupLimit))
	}
	return n
}

func (m *PolicyEntriesType) Size() (n int) {
	var l int
	_ = l
	if len(m.PolicyRule) > 0 {
		for _, e := range m.PolicyRule {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *ServiceHealthCheckType) Size() (n int) {
	var l int
	_ = l
	if m.DelayUsecs != 0 {
		n += 1 + sovContrail(uint64(m.DelayUsecs))
	}
	if m.TimeoutUsecs != 0 {
		n += 1 + sovContrail(uint64(m.TimeoutUsecs))
	}
	if m.Enabled {
		n += 2
	}
	if m.Delay != 0 {
		n += 1 + sovContrail(uint64(m.Delay))
	}
	l = len(m.ExpectedCodes)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MaxRetries != 0 {
		n += 1 + sovContrail(uint64(m.MaxRetries))
	}
	l = len(m.HealthCheckType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.HttpMethod)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovContrail(uint64(m.Timeout))
	}
	l = len(m.UrlPath)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.MonitorType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *AddressType) Size() (n int) {
	var l int
	_ = l
	l = len(m.SecurityGroup)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.NetworkPolicy)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.SubnetList) > 0 {
		for _, e := range m.SubnetList {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	l = len(m.VirtualNetwork)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FlowAgingTimeout) Size() (n int) {
	var l int
	_ = l
	if m.TimeoutInSeconds != 0 {
		n += 1 + sovContrail(uint64(m.TimeoutInSeconds))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovContrail(uint64(m.Port))
	}
	return n
}

func (m *QosIdForwardingClassPair) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovContrail(uint64(m.Key))
	}
	if m.ForwardingClassId != 0 {
		n += 1 + sovContrail(uint64(m.ForwardingClassId))
	}
	return n
}

func (m *RbacRuleEntriesType) Size() (n int) {
	var l int
	_ = l
	if len(m.RbacRule) > 0 {
		for _, e := range m.RbacRule {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *FloatingIpPoolSubnetType) Size() (n int) {
	var l int
	_ = l
	if len(m.SubnetUuid) > 0 {
		for _, s := range m.SubnetUuid {
			l = len(s)
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *ServiceTemplateType) Size() (n int) {
	var l int
	_ = l
	if m.AvailabilityZoneEnable {
		n += 2
	}
	l = len(m.InstanceData)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.OrderedInterfaces {
		n += 2
	}
	l = len(m.ServiceVirtualizationType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if len(m.InterfaceType) > 0 {
		for _, e := range m.InterfaceType {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	l = len(m.ImageName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.ServiceMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovContrail(uint64(m.Version))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Flavor)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ServiceScaling {
		n += 2
	}
	l = len(m.VrouterInstanceType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *FatFlowProtocols) Size() (n int) {
	var l int
	_ = l
	if len(m.FatFlowProtocol) > 0 {
		for _, e := range m.FatFlowProtocol {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *MACMoveLimitControlType) Size() (n int) {
	var l int
	_ = l
	if m.MacMoveTimeWindow != 0 {
		n += 1 + sovContrail(uint64(m.MacMoveTimeWindow))
	}
	if m.MacMoveLimit != 0 {
		n += 1 + sovContrail(uint64(m.MacMoveLimit))
	}
	l = len(m.MacMoveLimitAction)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *DiscoveryPubSubEndPointType) Size() (n int) {
	var l int
	_ = l
	l = len(m.EpVersion)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.EpId)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.EpType)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.EpPrefix != nil {
		l = m.EpPrefix.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *AclRuleType) Size() (n int) {
	var l int
	_ = l
	l = len(m.RuleUuid)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.MatchCondition != nil {
		l = m.MatchCondition.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.ActionList != nil {
		l = m.ActionList.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PluginProperty) Size() (n int) {
	var l int
	_ = l
	l = len(m.Property)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *SecurityLoggingObjectRuleListType) Size() (n int) {
	var l int
	_ = l
	if len(m.Rule) > 0 {
		for _, e := range m.Rule {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *FirewallServiceGroupType) Size() (n int) {
	var l int
	_ = l
	if len(m.FirewallService) > 0 {
		for _, e := range m.FirewallService {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *VrfAssignTableType) Size() (n int) {
	var l int
	_ = l
	if len(m.VrfAssignRule) > 0 {
		for _, e := range m.VrfAssignRule {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *MemberType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *AlarmAndList) Size() (n int) {
	var l int
	_ = l
	if len(m.AndList) > 0 {
		for _, e := range m.AndList {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *PortMap) Size() (n int) {
	var l int
	_ = l
	if m.SrcPort != 0 {
		n += 1 + sovContrail(uint64(m.SrcPort))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.DstPort != 0 {
		n += 1 + sovContrail(uint64(m.DstPort))
	}
	return n
}

func (m *ProviderDetails) Size() (n int) {
	var l int
	_ = l
	if m.SegmentationId != 0 {
		n += 1 + sovContrail(uint64(m.SegmentationId))
	}
	l = len(m.PhysicalNetwork)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *PermType2) Size() (n int) {
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	if m.OwnerAccess != 0 {
		n += 1 + sovContrail(uint64(m.OwnerAccess))
	}
	if m.GlobalAccess != 0 {
		n += 1 + sovContrail(uint64(m.GlobalAccess))
	}
	if len(m.Share) > 0 {
		for _, e := range m.Share {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *DhcpOptionType) Size() (n int) {
	var l int
	_ = l
	l = len(m.DhcpOptionValue)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DhcpOptionValueBytes)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.DhcpOptionName)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func (m *QosIdForwardingClassPairs) Size() (n int) {
	var l int
	_ = l
	if len(m.QosIdForwardingClassPair) > 0 {
		for _, e := range m.QosIdForwardingClassPair {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *PluginProperties) Size() (n int) {
	var l int
	_ = l
	if len(m.PluginProperty) > 0 {
		for _, e := range m.PluginProperty {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *AlarmOrList) Size() (n int) {
	var l int
	_ = l
	if len(m.OrList) > 0 {
		for _, e := range m.OrList {
			l = e.Size()
			n += 1 + l + sovContrail(uint64(l))
		}
	}
	return n
}

func (m *ServiceScaleOutType) Size() (n int) {
	var l int
	_ = l
	if m.AutoScale {
		n += 2
	}
	if m.MaxInstances != 0 {
		n += 1 + sovContrail(uint64(m.MaxInstances))
	}
	return n
}

func (m *AllowedAddressPair) Size() (n int) {
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	l = len(m.AddressMode)
	if l > 0 {
		n += 1 + l + sovContrail(uint64(l))
	}
	return n
}

func sovContrail(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozContrail(x uint64) (n int) {
	return sovContrail(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = append(m.Resource, &Resource{})
			if err := m.Resource[len(m.Resource)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseType", wireType)
			}
			m.ResponseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseType |= (ResponseType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &Resource{}
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseType", wireType)
			}
			m.ResponseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseType |= (ResponseType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Detail = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shared = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeHrefs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeHrefs = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentFqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentFqName = append(m.ParentFqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuids = append(m.ParentUuids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackrefUuids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackrefUuids = append(m.BackrefUuids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectUuids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectUuids = append(m.ObjectUuids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessControlList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AccessControlList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_AccessControlList{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_AddressGroup{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alarm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Alarm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Alarm{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasIpPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AliasIPPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_AliasIpPool{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AliasIP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_AliasIp{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyticsNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AnalyticsNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_AnalyticsNode{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiAccessList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &APIAccessList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ApiAccessList{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationPolicySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ApplicationPolicySet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ApplicationPolicySet{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpAsAService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPAsAService{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_BgpAsAService{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPRouter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_BgpRouter{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bgpvpn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPVPN{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Bgpvpn{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BridgeDomain{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_BridgeDomain{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConfigNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ConfigNode{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigRoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConfigRoot{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ConfigRoot{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAttachment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CustomerAttachment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_CustomerAttachment{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DatabaseNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_DatabaseNode{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryServiceAssignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DiscoveryServiceAssignment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_DiscoveryServiceAssignment{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Domain{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Domain{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DsaRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DsaRule{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_DsaRule{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E2ServiceProvider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &E2ServiceProvider{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_E2ServiceProvider{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirewallPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FirewallPolicy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_FirewallPolicy{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirewallRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FirewallRule{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_FirewallRule{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FloatingIPPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_FloatingIpPool{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FloatingIP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_FloatingIp{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ForwardingClass{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ForwardingClass{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalQosConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GlobalQosConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_GlobalQosConfig{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalSystemConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GlobalSystemConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_GlobalSystemConfig{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalVrouterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GlobalVrouterConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_GlobalVrouterConfig{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InstanceIP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_InstanceIp{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceRouteTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InterfaceRouteTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_InterfaceRouteTable{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerHealthmonitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoadbalancerHealthmonitor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_LoadbalancerHealthmonitor{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerListener", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoadbalancerListener{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_LoadbalancerListener{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerMember", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoadbalancerMember{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_LoadbalancerMember{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoadbalancerPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_LoadbalancerPool{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loadbalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Loadbalancer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Loadbalancer{v}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogicalInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_LogicalInterface{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalRouter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogicalRouter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_LogicalRouter{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Namespace{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Namespace{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkDeviceConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkDeviceConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_NetworkDeviceConfig{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkIpam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkIpam{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_NetworkIpam{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkPolicy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_NetworkPolicy{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeeringPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PeeringPolicy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_PeeringPolicy{v}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PhysicalInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_PhysicalInterface{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PhysicalRouter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_PhysicalRouter{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PolicyManagement{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_PolicyManagement{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortTuple", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortTuple{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_PortTuple{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Project{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Project{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAttachment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProviderAttachment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ProviderAttachment{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_QosConfig{v}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QosQueue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_QosQueue{v}
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteAggregate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteAggregate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_RouteAggregate{v}
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_RouteTable{v}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteTarget{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_RouteTarget{v}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingInstance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RoutingInstance{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_RoutingInstance{v}
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RoutingPolicy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_RoutingPolicy{v}
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecurityGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_SecurityGroup{v}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityLoggingObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecurityLoggingObject{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_SecurityLoggingObject{v}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAppliance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceAppliance{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ServiceAppliance{v}
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceApplianceSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceApplianceSet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ServiceApplianceSet{v}
			iNdEx = postIndex
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceConnectionModule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceConnectionModule{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ServiceConnectionModule{v}
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceEndpoint{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ServiceEndpoint{v}
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ServiceGroup{v}
			iNdEx = postIndex
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceHealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceHealthCheck{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ServiceHealthCheck{v}
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInstance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceInstance{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ServiceInstance{v}
			iNdEx = postIndex
		case 68:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceObject{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ServiceObject{v}
			iNdEx = postIndex
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceTemplate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ServiceTemplate{v}
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Subnet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Subnet{v}
			iNdEx = postIndex
		case 71:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tag{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Tag{v}
			iNdEx = postIndex
		case 72:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TagType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_TagType{v}
			iNdEx = postIndex
		case 73:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &User{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_User{v}
			iNdEx = postIndex
		case 74:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual_DNSRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VirtualDNSRecord{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Virtual_DNSRecord{v}
			iNdEx = postIndex
		case 75:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual_DNS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VirtualDNS{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Virtual_DNS{v}
			iNdEx = postIndex
		case 76:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VirtualIP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_VirtualIp{v}
			iNdEx = postIndex
		case 77:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VirtualMachineInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_VirtualMachineInterface{v}
			iNdEx = postIndex
		case 78:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VirtualMachine{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_VirtualMachine{v}
			iNdEx = postIndex
		case 79:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VirtualNetwork{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_VirtualNetwork{v}
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VirtualRouter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_VirtualRouter{v}
			iNdEx = postIndex
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppformixNodeRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppformixNodeRole{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_AppformixNodeRole{v}
			iNdEx = postIndex
		case 82:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaremetalNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BaremetalNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_BaremetalNode{v}
			iNdEx = postIndex
		case 83:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaremetalPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BaremetalPort{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_BaremetalPort{v}
			iNdEx = postIndex
		case 84:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContrailAnalyticsDatabaseNodeRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContrailAnalyticsDatabaseNodeRole{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ContrailAnalyticsDatabaseNodeRole{v}
			iNdEx = postIndex
		case 85:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContrailAnalyticsNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContrailAnalyticsNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ContrailAnalyticsNode{v}
			iNdEx = postIndex
		case 86:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContrailCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContrailCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ContrailCluster{v}
			iNdEx = postIndex
		case 87:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContrailControllerNodeRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContrailControllerNodeRole{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ContrailControllerNodeRole{v}
			iNdEx = postIndex
		case 88:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerNodeRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ControllerNodeRole{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_ControllerNodeRole{v}
			iNdEx = postIndex
		case 89:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dashboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Dashboard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Dashboard{v}
			iNdEx = postIndex
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keypair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Keypair{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Keypair{v}
			iNdEx = postIndex
		case 91:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KubernetesCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_KubernetesCluster{v}
			iNdEx = postIndex
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KubernetesNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_KubernetesNode{v}
			iNdEx = postIndex
		case 93:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Location{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Location{v}
			iNdEx = postIndex
		case 94:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Node{v}
			iNdEx = postIndex
		case 95:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenstackCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OpenstackCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_OpenstackCluster{v}
			iNdEx = postIndex
		case 96:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenstackComputeNodeRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OpenstackComputeNodeRole{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_OpenstackComputeNodeRole{v}
			iNdEx = postIndex
		case 97:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenstackStorageNodeRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OpenstackStorageNodeRole{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_OpenstackStorageNodeRole{v}
			iNdEx = postIndex
		case 98:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpnGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VPNGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_VpnGroup{v}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Widget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Widget{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceOneof = &Resource_Widget{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessControlList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessControlList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessControlList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessControlListHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessControlListHash = append(m.AccessControlListHash[:0], dAtA[iNdEx:postIndex]...)
			if m.AccessControlListHash == nil {
				m.AccessControlListHash = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessControlListEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessControlListEntries == nil {
				m.AccessControlListEntries = &AclEntriesType{}
			}
			if err := m.AccessControlListEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressGroupPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddressGroupPrefix == nil {
				m.AddressGroupPrefix = &SubnetListType{}
			}
			if err := m.AddressGroupPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alarm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alarm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alarm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AlarmRules == nil {
				m.AlarmRules = &AlarmOrList{}
			}
			if err := m.AlarmRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UveKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UveKeys == nil {
				m.UveKeys = &UveKeysType{}
			}
			if err := m.UveKeys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmSeverity", wireType)
			}
			m.AlarmSeverity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmSeverity |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliasIPPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliasIPPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliasIPPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliasIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliasIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliasIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasIpAddressFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasIpAddressFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyticsNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyticsNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyticsNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyticsNodeIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalyticsNodeIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *APIAccessList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: APIAccessList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: APIAccessList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiAccessListEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiAccessListEntries == nil {
				m.ApiAccessListEntries = &RbacRuleEntriesType{}
			}
			if err := m.ApiAccessListEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationPolicySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationPolicySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationPolicySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllApplications", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllApplications = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPAsAService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPAsAService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPAsAService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpaasShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BgpaasShared = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpaasSessionAttributes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpaasSessionAttributes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpaasSuppressRouteAdvertisement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BgpaasSuppressRouteAdvertisement = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpaasIpv4MappedIpv6Nexthop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BgpaasIpv4MappedIpv6Nexthop = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpaasIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpaasIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutonomousSystem", wireType)
			}
			m.AutonomousSystem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutonomousSystem |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPVPN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPVPN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPVPN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTargetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteTargetList == nil {
				m.RouteTargetList = &RouteTargetList{}
			}
			if err := m.RouteTargetList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportRouteTargetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImportRouteTargetList == nil {
				m.ImportRouteTargetList = &RouteTargetList{}
			}
			if err := m.ImportRouteTargetList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportRouteTargetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExportRouteTargetList == nil {
				m.ExportRouteTargetList = &RouteTargetList{}
			}
			if err := m.ExportRouteTargetList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpvpnType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpvpnType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BridgeDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BridgeDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BridgeDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAgingTime", wireType)
			}
			m.MacAgingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAgingTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isid", wireType)
			}
			m.Isid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Isid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacLearningEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MacLearningEnabled = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacMoveControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MacMoveControl == nil {
				m.MacMoveControl = &MACMoveLimitControlType{}
			}
			if err := m.MacMoveControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacLimitControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MacLimitControl == nil {
				m.MacLimitControl = &MACLimitControlType{}
			}
			if err := m.MacLimitControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigNodeIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigNodeIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigRoot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigRoot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigRoot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomerAttachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomerAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomerAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseNodeIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseNodeIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveryServiceAssignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveryServiceAssignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveryServiceAssignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Domain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Domain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Domain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainLimits == nil {
				m.DomainLimits = &DomainLimitsType{}
			}
			if err := m.DomainLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DsaRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DsaRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DsaRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DsaRuleEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DsaRuleEntry == nil {
				m.DsaRuleEntry = &DiscoveryServiceAssignmentType{}
			}
			if err := m.DsaRuleEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *E2ServiceProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: E2ServiceProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: E2ServiceProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E2ServiceProviderPromiscuous", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.E2ServiceProviderPromiscuous = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint_1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint_1 == nil {
				m.Endpoint_1 = &FirewallRuleEndpointType{}
			}
			if err := m.Endpoint_1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint_2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint_2 == nil {
				m.Endpoint_2 = &FirewallRuleEndpointType{}
			}
			if err := m.Endpoint_2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionList == nil {
				m.ActionList = &ActionListType{}
			}
			if err := m.ActionList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &FirewallServiceType{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTagTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchTagTypes == nil {
				m.MatchTagTypes = &FirewallRuleMatchTagsTypeIdList{}
			}
			if err := m.MatchTagTypes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchTags == nil {
				m.MatchTags = &FirewallRuleMatchTagsType{}
			}
			if err := m.MatchTags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatingIPPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatingIPPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatingIPPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpPoolSubnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FloatingIpPoolSubnets == nil {
				m.FloatingIpPoolSubnets = &FloatingIpPoolSubnetType{}
			}
			if err := m.FloatingIpPoolSubnets.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatingIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatingIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatingIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpAddressFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FloatingIpAddressFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpPortMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FloatingIpPortMappings == nil {
				m.FloatingIpPortMappings = &PortMappings{}
			}
			if err := m.FloatingIpPortMappings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpIsVirtualIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FloatingIpIsVirtualIp = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FloatingIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpPortMappingsEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FloatingIpPortMappingsEnable = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpFixedIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FloatingIpFixedIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpTrafficDirection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FloatingIpTrafficDirection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardingClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardingClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardingClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClassDscp", wireType)
			}
			m.ForwardingClassDscp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardingClassDscp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClassVlanPriority", wireType)
			}
			m.ForwardingClassVlanPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardingClassVlanPriority |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClassMplsExp", wireType)
			}
			m.ForwardingClassMplsExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardingClassMplsExp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClassId", wireType)
			}
			m.ForwardingClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardingClassId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalQosConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalQosConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalQosConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlTrafficDscp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlTrafficDscp == nil {
				m.ControlTrafficDscp = &ControlTrafficDscpType{}
			}
			if err := m.ControlTrafficDscp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSystemConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSystemConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSystemConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpaasParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BgpaasParameters == nil {
				m.BgpaasParameters = &BGPaaServiceParametersType{}
			}
			if err := m.BgpaasParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlarmEnable = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacMoveControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MacMoveControl == nil {
				m.MacMoveControl = &MACMoveLimitControlType{}
			}
			if err := m.MacMoveControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PluginTuning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PluginTuning == nil {
				m.PluginTuning = &PluginProperties{}
			}
			if err := m.PluginTuning.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbgpAutoMesh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IbgpAutoMesh = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAgingTime", wireType)
			}
			m.MacAgingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAgingTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpAlwaysCompareMed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BgpAlwaysCompareMed = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefinedLogStatistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserDefinedLogStatistics == nil {
				m.UserDefinedLogStatistics = &UserDefinedLogStatList{}
			}
			if err := m.UserDefinedLogStatistics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracefulRestartParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GracefulRestartParameters == nil {
				m.GracefulRestartParameters = &GracefulRestartParametersType{}
			}
			if err := m.GracefulRestartParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFabricSubnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpFabricSubnets == nil {
				m.IpFabricSubnets = &SubnetListType{}
			}
			if err := m.IpFabricSubnets.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutonomousSystem", wireType)
			}
			m.AutonomousSystem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutonomousSystem |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacLimitControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MacLimitControl == nil {
				m.MacLimitControl = &MACLimitControlType{}
			}
			if err := m.MacLimitControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalVrouterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalVrouterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalVrouterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcmpHashingIncludeFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcmpHashingIncludeFields == nil {
				m.EcmpHashingIncludeFields = &EcmpHashingIncludeFields{}
			}
			if err := m.EcmpHashingIncludeFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowAgingTimeoutList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowAgingTimeoutList == nil {
				m.FlowAgingTimeoutList = &FlowAgingTimeoutList{}
			}
			if err := m.FlowAgingTimeoutList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowExportRate", wireType)
			}
			m.FlowExportRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowExportRate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinklocalServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinklocalServices == nil {
				m.LinklocalServices = &LinklocalServicesTypes{}
			}
			if err := m.LinklocalServices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncapsulationPriorities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncapsulationPriorities == nil {
				m.EncapsulationPriorities = &EncapsulationPrioritiesType{}
			}
			if err := m.EncapsulationPriorities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxlanNetworkIdentifierMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VxlanNetworkIdentifierMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSecurityLogging", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSecurityLogging = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceHealthCheckIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServiceHealthCheckIp = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIpTrackingIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecondaryIpTrackingIp == nil {
				m.SecondaryIpTrackingIp = &SubnetType{}
			}
			if err := m.SecondaryIpTrackingIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceIpMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceIpMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceIpFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceIpFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInstanceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServiceInstanceIp = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceIpLocalIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InstanceIpLocalIp = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceIpSecondary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InstanceIpSecondary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceRouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceRouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceRouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceRouteTableRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceRouteTableRoutes == nil {
				m.InterfaceRouteTableRoutes = &RouteTableType{}
			}
			if err := m.InterfaceRouteTableRoutes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerHealthmonitor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerHealthmonitor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerHealthmonitor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerHealthmonitorProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadbalancerHealthmonitorProperties == nil {
				m.LoadbalancerHealthmonitorProperties = &LoadbalancerHealthmonitorType{}
			}
			if err := m.LoadbalancerHealthmonitorProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerListener) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerListener: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerListener: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerListenerProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadbalancerListenerProperties == nil {
				m.LoadbalancerListenerProperties = &LoadbalancerListenerType{}
			}
			if err := m.LoadbalancerListenerProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerMemberProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadbalancerMemberProperties == nil {
				m.LoadbalancerMemberProperties = &LoadbalancerMemberType{}
			}
			if err := m.LoadbalancerMemberProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerPoolProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadbalancerPoolProperties == nil {
				m.LoadbalancerPoolProperties = &LoadbalancerPoolType{}
			}
			if err := m.LoadbalancerPoolProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerPoolCustomAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadbalancerPoolCustomAttributes == nil {
				m.LoadbalancerPoolCustomAttributes = &KeyValuePairs{}
			}
			if err := m.LoadbalancerPoolCustomAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerPoolProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadbalancerPoolProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Loadbalancer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Loadbalancer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Loadbalancer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadbalancerProperties == nil {
				m.LoadbalancerProperties = &LoadbalancerType{}
			}
			if err := m.LoadbalancerProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadbalancerProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalInterfaceVlanTag", wireType)
			}
			m.LogicalInterfaceVlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogicalInterfaceVlanTag |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalInterfaceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogicalInterfaceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxlanNetworkIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VxlanNetworkIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfiguredRouteTargetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfiguredRouteTargetList == nil {
				m.ConfiguredRouteTargetList = &RouteTargetList{}
			}
			if err := m.ConfiguredRouteTargetList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceCidr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NamespaceCidr == nil {
				m.NamespaceCidr = &SubnetType{}
			}
			if err := m.NamespaceCidr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkDeviceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkDeviceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkDeviceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkIpam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkIpam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkIpam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkIpamMgmt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkIpamMgmt == nil {
				m.NetworkIpamMgmt = &IpamType{}
			}
			if err := m.NetworkIpamMgmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpamSubnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpamSubnets == nil {
				m.IpamSubnets = &IpamSubnets{}
			}
			if err := m.IpamSubnets.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpamSubnetMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpamSubnetMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPolicyEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkPolicyEntries == nil {
				m.NetworkPolicyEntries = &PolicyEntriesType{}
			}
			if err := m.NetworkPolicyEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeeringPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeeringPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeeringPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeeringService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeeringService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetSegmentIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthernetSegmentIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterManagementIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalRouterManagementIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterSnmpCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhysicalRouterSnmpCredentials == nil {
				m.PhysicalRouterSnmpCredentials = &SNMPCredentials{}
			}
			if err := m.PhysicalRouterSnmpCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalRouterRole = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterUserCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhysicalRouterUserCredentials == nil {
				m.PhysicalRouterUserCredentials = &UserCredentials{}
			}
			if err := m.PhysicalRouterUserCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterVendorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalRouterVendorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterVncManaged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhysicalRouterVncManaged = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalRouterProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterLldp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhysicalRouterLldp = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterLoopbackIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalRouterLoopbackIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterImageUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalRouterImageUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelemetryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TelemetryInfo == nil {
				m.TelemetryInfo = &TelemetryStateInfo{}
			}
			if err := m.TelemetryInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterSnmp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhysicalRouterSnmp = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterDataplaneIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalRouterDataplaneIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRouterJunosServicePorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhysicalRouterJunosServicePorts == nil {
				m.PhysicalRouterJunosServicePorts = &JunosServicePorts{}
			}
			if err := m.PhysicalRouterJunosServicePorts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyManagement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyManagement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyManagement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortTuple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortTuple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortTuple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Project) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Project: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Project: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxlanRouting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VxlanRouting = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlarmEnable = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quota", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Quota == nil {
				m.Quota = &QuotaType{}
			}
			if err := m.Quota.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderAttachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosConfigType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosConfigType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MplsExpEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MplsExpEntries == nil {
				m.MplsExpEntries = &QosIdForwardingClassPairs{}
			}
			if err := m.MplsExpEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanPriorityEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VlanPriorityEntries == nil {
				m.VlanPriorityEntries = &QosIdForwardingClassPairs{}
			}
			if err := m.VlanPriorityEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultForwardingClassId", wireType)
			}
			m.DefaultForwardingClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultForwardingClassId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DscpEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DscpEntries == nil {
				m.DscpEntries = &QosIdForwardingClassPairs{}
			}
			if err := m.DscpEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosQueueIdentifier", wireType)
			}
			m.QosQueueIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QosQueueIdentifier |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBandwidth", wireType)
			}
			m.MaxBandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBandwidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBandwidth", wireType)
			}
			m.MinBandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinBandwidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteAggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteAggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routes == nil {
				m.Routes = &RouteTableType{}
			}
			if err := m.Routes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityGroupEntries == nil {
				m.SecurityGroupEntries = &PolicyEntriesType{}
			}
			if err := m.SecurityGroupEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfiguredSecurityGroupId", wireType)
			}
			m.ConfiguredSecurityGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfiguredSecurityGroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupId", wireType)
			}
			m.SecurityGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityGroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityLoggingObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityLoggingObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityLoggingObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityLoggingObjectRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityLoggingObjectRules == nil {
				m.SecurityLoggingObjectRules = &SecurityLoggingObjectRuleListType{}
			}
			if err := m.SecurityLoggingObjectRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityLoggingObjectRate", wireType)
			}
			m.SecurityLoggingObjectRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityLoggingObjectRate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceAppliance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceAppliance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceAppliance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceApplianceUserCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceApplianceUserCredentials == nil {
				m.ServiceApplianceUserCredentials = &UserCredentials{}
			}
			if err := m.ServiceApplianceUserCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceApplianceIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceApplianceIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceApplianceProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceApplianceProperties == nil {
				m.ServiceApplianceProperties = &KeyValuePairs{}
			}
			if err := m.ServiceApplianceProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceApplianceSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceApplianceSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceApplianceSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceApplianceSetProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceApplianceSetProperties == nil {
				m.ServiceApplianceSetProperties = &KeyValuePairs{}
			}
			if err := m.ServiceApplianceSetProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceApplianceHaMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceApplianceHaMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceApplianceDriver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceApplianceDriver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceConnectionModule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConnectionModule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConnectionModule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E2Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.E2Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceGroupFirewallServiceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceGroupFirewallServiceList == nil {
				m.ServiceGroupFirewallServiceList = &FirewallServiceGroupType{}
			}
			if err := m.ServiceGroupFirewallServiceList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceHealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceHealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceHealthCheckProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceHealthCheckProperties == nil {
				m.ServiceHealthCheckProperties = &ServiceHealthCheckType{}
			}
			if err := m.ServiceHealthCheckProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInstanceBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceInstanceBindings == nil {
				m.ServiceInstanceBindings = &KeyValuePairs{}
			}
			if err := m.ServiceInstanceBindings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInstanceProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceInstanceProperties == nil {
				m.ServiceInstanceProperties = &ServiceInstanceType{}
			}
			if err := m.ServiceInstanceProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceTemplateProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceTemplateProperties == nil {
				m.ServiceTemplateProperties = &ServiceTemplateType{}
			}
			if err := m.ServiceTemplateProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetIpPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetIpPrefix == nil {
				m.SubnetIpPrefix = &SubnetType{}
			}
			if err := m.SubnetIpPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagTypeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagTypeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualDNSRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualDNSRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualDNSRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual_DNSRecordData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Virtual_DNSRecordData == nil {
				m.Virtual_DNSRecordData = &VirtualDnsRecordType{}
			}
			if err := m.Virtual_DNSRecordData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualDNS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualDNS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualDNS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual_DNSData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Virtual_DNSData == nil {
				m.Virtual_DNSData = &VirtualDnsType{}
			}
			if err := m.Virtual_DNSData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIpProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualIpProperties == nil {
				m.VirtualIpProperties = &VirtualIpType{}
			}
			if err := m.VirtualIpProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualMachineInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualMachineInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualMachineInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcmpHashingIncludeFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcmpHashingIncludeFields == nil {
				m.EcmpHashingIncludeFields = &EcmpHashingIncludeFields{}
			}
			if err := m.EcmpHashingIncludeFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterfaceHostRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualMachineInterfaceHostRoutes == nil {
				m.VirtualMachineInterfaceHostRoutes = &RouteTableType{}
			}
			if err := m.VirtualMachineInterfaceHostRoutes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterfaceMacAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualMachineInterfaceMacAddresses == nil {
				m.VirtualMachineInterfaceMacAddresses = &MacAddressesType{}
			}
			if err := m.VirtualMachineInterfaceMacAddresses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterfaceDhcpOptionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualMachineInterfaceDhcpOptionList == nil {
				m.VirtualMachineInterfaceDhcpOptionList = &DhcpOptionsListType{}
			}
			if err := m.VirtualMachineInterfaceDhcpOptionList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterfaceBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualMachineInterfaceBindings == nil {
				m.VirtualMachineInterfaceBindings = &KeyValuePairs{}
			}
			if err := m.VirtualMachineInterfaceBindings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterfaceDisablePolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VirtualMachineInterfaceDisablePolicy = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterfaceAllowedAddressPairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualMachineInterfaceAllowedAddressPairs == nil {
				m.VirtualMachineInterfaceAllowedAddressPairs = &AllowedAddressPairs{}
			}
			if err := m.VirtualMachineInterfaceAllowedAddressPairs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterfaceFatFlowProtocols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualMachineInterfaceFatFlowProtocols == nil {
				m.VirtualMachineInterfaceFatFlowProtocols = &FatFlowProtocols{}
			}
			if err := m.VirtualMachineInterfaceFatFlowProtocols.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTagBasedBridgeDomain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VlanTagBasedBridgeDomain = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterfaceDeviceOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualMachineInterfaceDeviceOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfAssignTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfAssignTable == nil {
				m.VrfAssignTable = &VrfAssignTableType{}
			}
			if err := m.VrfAssignTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSecurityEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortSecurityEnabled = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterfaceProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualMachineInterfaceProperties == nil {
				m.VirtualMachineInterfaceProperties = &VirtualMachineInterfacePropertiesType{}
			}
			if err := m.VirtualMachineInterfaceProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualMachine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualMachine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualMachine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetworkProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualNetworkProperties == nil {
				m.VirtualNetworkProperties = &VirtualNetworkType{}
			}
			if err := m.VirtualNetworkProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcmpHashingIncludeFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcmpHashingIncludeFields == nil {
				m.EcmpHashingIncludeFields = &EcmpHashingIncludeFields{}
			}
			if err := m.EcmpHashingIncludeFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetworkNetworkId", wireType)
			}
			m.VirtualNetworkNetworkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualNetworkNetworkId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressAllocationMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressAllocationMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbbEvpnEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PbbEvpnEnable = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterExternal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RouterExternal = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportRouteTargetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImportRouteTargetList == nil {
				m.ImportRouteTargetList = &RouteTargetList{}
			}
			if err := m.ImportRouteTargetList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAgingTime", wireType)
			}
			m.MacAgingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAgingTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderProperties == nil {
				m.ProviderProperties = &ProviderDetails{}
			}
			if err := m.ProviderProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTargetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RouteTargetList == nil {
				m.RouteTargetList = &RouteTargetList{}
			}
			if err := m.RouteTargetList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacLearningEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MacLearningEnabled = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportRouteTargetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExportRouteTargetList == nil {
				m.ExportRouteTargetList = &RouteTargetList{}
			}
			if err := m.ExportRouteTargetList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloodUnknownUnicast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FloodUnknownUnicast = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbbEtreeEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PbbEtreeEnable = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer2ControlWord", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Layer2ControlWord = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIpam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExternalIpam = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSecurityEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortSecurityEnabled = bool(v != 0)
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacMoveControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MacMoveControl == nil {
				m.MacMoveControl = &MACMoveLimitControlType{}
			}
			if err := m.MacMoveControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiPolicyServiceChainsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiPolicyServiceChainsEnabled = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacLimitControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MacLimitControl == nil {
				m.MacLimitControl = &MACLimitControlType{}
			}
			if err := m.MacLimitControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShared = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouterDpdkEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VirtualRouterDpdkEnabled = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualRouterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouterIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualRouterIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppformixNodeRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppformixNodeRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppformixNodeRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaremetalNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaremetalNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaremetalNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpmiAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpmiAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpmiUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpmiUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpmiPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpmiPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCount", wireType)
			}
			m.CpuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuArch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuArch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskGb", wireType)
			}
			m.DiskGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskGb |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryMb", wireType)
			}
			m.MemoryMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryMb |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployKernel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeployKernel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployRamdisk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeployRamdisk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaremetalPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaremetalPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaremetalPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PxeEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PxeEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContrailAnalyticsDatabaseNodeRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContrailAnalyticsDatabaseNodeRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContrailAnalyticsDatabaseNodeRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContrailAnalyticsNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContrailAnalyticsNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContrailAnalyticsNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContrailCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContrailCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContrailCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigAuditTtl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigAuditTtl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContrailWebui", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContrailWebui = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTtl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataTtl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultGateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultVrouterBondInterface", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultVrouterBondInterface = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultVrouterBondInterfaceMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultVrouterBondInterfaceMembers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowTtl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowTtl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatisticsTtl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatisticsTtl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContrailControllerNodeRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContrailControllerNodeRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContrailControllerNodeRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerNodeRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerNodeRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerNodeRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityDrives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapacityDrives = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalapiBondInterfaceMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalapiBondInterfaceMembers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerformanceDrives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerformanceDrives = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageManagementBondInterfaceMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageManagementBondInterfaceMembers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dashboard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dashboard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dashboard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keypair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keypair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keypair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContrailClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContrailClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KuberunetesDashboard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KuberunetesDashboard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateDnsServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateDnsServers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateNtpHosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateNtpHosts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateOspdPackageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateOspdPackageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateOspdUserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateOspdUserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateOspdUserPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateOspdUserPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateOspdVmDiskGb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateOspdVmDiskGb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateOspdVmName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateOspdVmName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateOspdVmRamMb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateOspdVmRamMb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateOspdVmVcpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateOspdVmVcpus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateRedhatPoolId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateRedhatPoolId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateRedhatSubscriptionKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateRedhatSubscriptionKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateRedhatSubscriptionPasword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateRedhatSubscriptionPasword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateRedhatSubscriptionUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateRedhatSubscriptionUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpAccountInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpAccountInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpAsn", wireType)
			}
			m.GcpAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcpAsn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpSubnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpSubnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsSecretKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsSecretKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsSubnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsSubnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAmi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAmi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsInstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsInstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpMachineType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpMachineType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateMachineProperties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateMachineProperties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateMachineState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateMachineState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivatePowerManagementIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivatePowerManagementIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivatePowerManagementPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivatePowerManagementPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivatePowerManagementUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivatePowerManagementUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenstackCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenstackCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenstackCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContrailClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContrailClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultCapacityDrives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultCapacityDrives = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultJournalDrives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultJournalDrives = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultOsdDrives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultOsdDrives = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultPerformanceDrives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultPerformanceDrives = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageAccessBondInterfaceMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultStorageAccessBondInterfaceMembers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageBackendBondInterfaceMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultStorageBackendBondInterfaceMembers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalAllocationPoolEnd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalAllocationPoolEnd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalAllocationPoolStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalAllocationPoolStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalNetCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalNetCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenstackWebui", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenstackWebui = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicGateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicGateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenstackComputeNodeRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenstackComputeNodeRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenstackComputeNodeRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultGateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrouterBondInterface", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrouterBondInterface = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrouterBondInterfaceMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrouterBondInterfaceMembers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrouterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrouterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenstackStorageNodeRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenstackStorageNodeRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenstackStorageNodeRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalDrives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JournalDrives = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsdDrives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsdDrives = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageAccessBondInterfaceMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageAccessBondInterfaceMembers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackendBondInterfaceMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageBackendBondInterfaceMembers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPNGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPNGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPNGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningLog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningLog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgress", wireType)
			}
			m.ProvisioningProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvisioningProgress |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningProgressStage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningProgressStage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Widget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Widget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Widget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FqName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FqName = append(m.FqName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdPerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdPerms == nil {
				m.IdPerms = &IdPermsType{}
			}
			if err := m.IdPerms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &KeyValuePairs{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perms2 == nil {
				m.Perms2 = &PermType2{}
			}
			if err := m.Perms2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayoutConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LayoutConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PermType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PermType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PermType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAccess", wireType)
			}
			m.OwnerAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerAccess |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherAccess", wireType)
			}
			m.OtherAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherAccess |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccess", wireType)
			}
			m.GroupAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupAccess |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerHealthmonitorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerHealthmonitorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerHealthmonitorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			m.Delay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delay |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedCodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedCodes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminState = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonitorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SNMPCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SNMPCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SNMPCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3PrivacyProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3PrivacyProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3AuthenticationPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3AuthenticationPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3EngineTime", wireType)
			}
			m.V3EngineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.V3EngineTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3EngineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3EngineId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPort", wireType)
			}
			m.LocalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3SecurityLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3SecurityLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3Context = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3SecurityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3SecurityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3AuthenticationProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3AuthenticationProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V2Community", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V2Community = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3SecurityEngineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3SecurityEngineId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3ContextEngineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3ContextEngineId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3PrivacyPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V3PrivacyPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3EngineBoots", wireType)
			}
			m.V3EngineBoots = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.V3EngineBoots |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyBasedForwardingRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyBasedForwardingRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyBasedForwardingRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6ServiceChainAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6ServiceChainAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MplsLabel", wireType)
			}
			m.MplsLabel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MplsLabel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTag", wireType)
			}
			m.VlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTag |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceChainAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceChainAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualMachineInterfacePropertiesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualMachineInterfacePropertiesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualMachineInterfacePropertiesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubInterfaceVlanTag", wireType)
			}
			m.SubInterfaceVlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubInterfaceVlanTag |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPreference", wireType)
			}
			m.LocalPreference = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalPreference |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceMirror", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceMirror == nil {
				m.InterfaceMirror = &InterfaceMirrorType{}
			}
			if err := m.InterfaceMirror.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInterfaceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceInterfaceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualNetworkPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualNetworkPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualNetworkPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timer == nil {
				m.Timer = &TimerType{}
			}
			if err := m.Timer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sequence == nil {
				m.Sequence = &SequenceType{}
			}
			if err := m.Sequence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantAccess", wireType)
			}
			m.TenantAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantAccess |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticMirrorNhType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticMirrorNhType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticMirrorNhType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtepDstIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VtepDstIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtepDstMacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VtepDstMacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vni", wireType)
			}
			m.Vni = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vni |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallRuleMatchTagsTypeIdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallRuleMatchTagsTypeIdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallRuleMatchTagsTypeIdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContrail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TagType = append(m.TagType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContrail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthContrail
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContrail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TagType = append(m.TagType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TagType", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommunityAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommunityAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommunityAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityAttribute", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunityAttribute = append(m.CommunityAttribute, make([]byte, postIndex-iNdEx))
			copy(m.CommunityAttribute[len(m.CommunityAttribute)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpAddressesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpAddressesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpAddressesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceTemplateInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceTemplateInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceTemplateInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRouteEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StaticRouteEnable = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SharedIp = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInterfaceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceInterfaceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdPermsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdPermsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdPermsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserVisible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserVisible = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &PermType{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RbacPermType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RbacPermType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RbacPermType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleCrud", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleCrud = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowAgingTimeoutList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowAgingTimeoutList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowAgingTimeoutList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowAgingTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowAgingTimeout = append(m.FlowAgingTimeout, &FlowAgingTimeout{})
			if err := m.FlowAgingTimeout[len(m.FlowAgingTimeout)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UveKeysType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UveKeysType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UveKeysType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UveKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UveKey = append(m.UveKey, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveryServiceAssignmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveryServiceAssignmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveryServiceAssignmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriber", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriber = append(m.Subscriber, &DiscoveryPubSubEndPointType{})
			if err := m.Subscriber[len(m.Subscriber)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Publisher == nil {
				m.Publisher = &DiscoveryPubSubEndPointType{}
			}
			if err := m.Publisher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GracefulRestartParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GracefulRestartParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GracefulRestartParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOfRibTimeout", wireType)
			}
			m.EndOfRibTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOfRibTimeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpHelperEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BgpHelperEnable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XmppHelperEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XmppHelperEnable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartTime", wireType)
			}
			m.RestartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongLivedRestartTime", wireType)
			}
			m.LongLivedRestartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LongLivedRestartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceInterfaceTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceInterfaceTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceInterfaceTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocationPoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocationPoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocationPoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrouterSpecificPool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VrouterSpecificPool = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstAddresses = append(m.DstAddresses, &AddressType{})
			if err := m.DstAddresses[len(m.DstAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionList == nil {
				m.ActionList = &ActionListType{}
			}
			if err := m.ActionList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPorts = append(m.DstPorts, &PortType{})
			if err := m.DstPorts[len(m.DstPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Application", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Application = append(m.Application, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ethertype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ethertype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddresses = append(m.SrcAddresses, &AddressType{})
			if err := m.SrcAddresses[len(m.SrcAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuleSequence == nil {
				m.RuleSequence = &SequenceType{}
			}
			if err := m.RuleSequence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPorts = append(m.SrcPorts, &PortType{})
			if err := m.SrcPorts[len(m.SrcPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualDnsRecordType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualDnsRecordType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualDnsRecordType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordTtlSeconds", wireType)
			}
			m.RecordTtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordTtlSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordMxPreference", wireType)
			}
			m.RecordMxPreference = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordMxPreference |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlarmExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlarmExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlarmExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operand1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operand1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = append(m.Variables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operand2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operand2 == nil {
				m.Operand2 = &AlarmOperand2{}
			}
			if err := m.Operand2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallServiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallServiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallServiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPorts == nil {
				m.DstPorts = &PortType{}
			}
			if err := m.DstPorts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPorts == nil {
				m.SrcPorts = &PortType{}
			}
			if err := m.SrcPorts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolId", wireType)
			}
			m.ProtocolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutingPolicyServiceInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingPolicyServiceInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingPolicyServiceInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightSequence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightSequence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftSequence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftSequence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffInterval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffInterval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnInterval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnInterval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallRuleEndpointType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallRuleEndpointType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallRuleEndpointType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &SubnetType{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContrail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TagIds = append(m.TagIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContrail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthContrail
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContrail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TagIds = append(m.TagIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TagIds", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Any = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceMirrorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceMirrorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceMirrorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficDirection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrafficDirection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MirrorTo == nil {
				m.MirrorTo = &MirrorActionType{}
			}
			if err := m.MirrorTo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualNetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualNetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualNetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowTransit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowTransit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			m.NetworkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorDestination", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MirrorDestination = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxlanNetworkIdentifier", wireType)
			}
			m.VxlanNetworkIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VxlanNetworkIdentifier |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rpf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPort", wireType)
			}
			m.EndPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPort", wireType)
			}
			m.StartPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMappings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMappings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMappings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortMappings = append(m.PortMappings, &PortMap{})
			if err := m.PortMappings[len(m.PortMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceInstanceInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceInstanceInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceInstanceInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedAddressPairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowedAddressPairs == nil {
				m.AllowedAddressPairs = &AllowedAddressPairs{}
			}
			if err := m.AllowedAddressPairs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StaticRoutes == nil {
				m.StaticRoutes = &RouteTableType{}
			}
			if err := m.StaticRoutes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityLoggingObjectRuleEntryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityLoggingObjectRuleEntryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityLoggingObjectRuleEntryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixLen", wireType)
			}
			m.IpPrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPrefixLen |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTargetList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTargetList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTargetList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTarget = append(m.RouteTarget, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinklocalServiceEntryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinklocalServiceEntryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinklocalServiceEntryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFabricServiceIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpFabricServiceIp = append(m.IpFabricServiceIp, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinklocalServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinklocalServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinklocalServiceIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinklocalServiceIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFabricServicePort", wireType)
			}
			m.IpFabricServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpFabricServicePort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFabric_DNSServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpFabric_DNSServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinklocalServicePort", wireType)
			}
			m.LinklocalServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinklocalServicePort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpamSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpamSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpamSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &SubnetType{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrFromStart", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddrFromStart = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDhcp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDhcp = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultGateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocUnit", wireType)
			}
			m.AllocUnit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocUnit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameservers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsNameservers = append(m.DnsNameservers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpOptionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DhcpOptionList == nil {
				m.DhcpOptionList = &DhcpOptionsListType{}
			}
			if err := m.DhcpOptionList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocationPools = append(m.AllocationPools, &AllocationPoolType{})
			if err := m.AllocationPools[len(m.AllocationPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostRoutes == nil {
				m.HostRoutes = &RouteTableType{}
			}
			if err := m.HostRoutes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsServerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsServerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuotaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuotaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuotaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouter", wireType)
			}
			m.VirtualRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualRouter |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPolicy", wireType)
			}
			m.NetworkPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkPolicy |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerPool", wireType)
			}
			m.LoadbalancerPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadbalancerPool |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTable", wireType)
			}
			m.RouteTable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteTable |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			m.Subnet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subnet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkIpam", wireType)
			}
			m.NetworkIpam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkIpam |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual_DNSRecord", wireType)
			}
			m.Virtual_DNSRecord = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Virtual_DNSRecord |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalRouter", wireType)
			}
			m.LogicalRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogicalRouter |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupRule", wireType)
			}
			m.SecurityGroupRule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityGroupRule |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual_DNS", wireType)
			}
			m.Virtual_DNS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Virtual_DNS |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInstance", wireType)
			}
			m.ServiceInstance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceInstance |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceTemplate", wireType)
			}
			m.ServiceTemplate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceTemplate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouter", wireType)
			}
			m.BgpRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BgpRouter |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIp", wireType)
			}
			m.FloatingIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FloatingIp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpPool", wireType)
			}
			m.FloatingIpPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FloatingIpPool |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerMember", wireType)
			}
			m.LoadbalancerMember = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadbalancerMember |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessControlList", wireType)
			}
			m.AccessControlList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessControlList |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualMachineInterface", wireType)
			}
			m.VirtualMachineInterface = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualMachineInterface |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceIp", wireType)
			}
			m.InstanceIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceIp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalVrouterConfig", wireType)
			}
			m.GlobalVrouterConfig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalVrouterConfig |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityLoggingObject", wireType)
			}
			m.SecurityLoggingObject = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityLoggingObject |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerHealthmonitor", wireType)
			}
			m.LoadbalancerHealthmonitor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadbalancerHealthmonitor |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualIp", wireType)
			}
			m.VirtualIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualIp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defaults", wireType)
			}
			m.Defaults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Defaults |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroup", wireType)
			}
			m.SecurityGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityGroup |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			m.VirtualNetwork = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualNetwork |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValuePairs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValuePairs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValuePairs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyValuePair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyValuePair = append(m.KeyValuePair, &KeyValuePair{})
			if err := m.KeyValuePair[len(m.KeyValuePair)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryStateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryStateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryStateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = append(m.Resource, &TelemetryResourceInfo{})
			if err := m.Resource[len(m.Resource)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallRuleMatchTagsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallRuleMatchTagsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallRuleMatchTagsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagList = append(m.TagList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinklocalServicesTypes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinklocalServicesTypes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinklocalServicesTypes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinklocalServiceEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinklocalServiceEntry = append(m.LinklocalServiceEntry, &LinklocalServiceEntryType{})
			if err := m.LinklocalServiceEntry[len(m.LinklocalServiceEntry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTableType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTableType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTableType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = append(m.Route, &RouteType{})
			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MacAddressesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacAddressesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacAddressesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = append(m.MacAddress, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VrfAssignRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VrfAssignRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VrfAssignRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchCondition == nil {
				m.MatchCondition = &MatchConditionType{}
			}
			if err := m.MatchCondition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTag", wireType)
			}
			m.VlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTag |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreAcl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreAcl = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Log = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Alert = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignRoutingInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignRoutingInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MirrorTo == nil {
				m.MirrorTo = &MirrorActionType{}
			}
			if err := m.MirrorTo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SimpleAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplyService = append(m.ApplyService, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclEntriesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclEntriesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclEntriesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dynamic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dynamic = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AclRule = append(m.AclRule, &AclRuleType{})
			if err := m.AclRule[len(m.AclRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualIpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualIpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualIpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistenceCookieName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistenceCookieName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionLimit", wireType)
			}
			m.ConnectionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistenceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistenceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminState = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPort", wireType)
			}
			m.ProtocolPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommunityAttributes == nil {
				m.CommunityAttributes = &CommunityAttributes{}
			}
			if err := m.CommunityAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminState = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightVirtualNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightVirtualNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementVirtualNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagementVirtualNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleOut == nil {
				m.ScaleOut = &ServiceScaleOutType{}
			}
			if err := m.ScaleOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HaMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceList = append(m.InterfaceList, &ServiceInstanceInterfaceType{})
			if err := m.InterfaceList[len(m.InterfaceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftVirtualNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftVirtualNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoPolicy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchConditionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchConditionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchConditionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcPort == nil {
				m.SrcPort = &PortType{}
			}
			if err := m.SrcPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcAddress == nil {
				m.SrcAddress = &AddressType{}
			}
			if err := m.SrcAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ethertype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ethertype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstAddress == nil {
				m.DstAddress = &AddressType{}
			}
			if err := m.DstAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstPort == nil {
				m.DstPort = &PortType{}
			}
			if err := m.DstPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerMemberType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerMemberType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerMemberType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminState = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPort", wireType)
			}
			m.ProtocolPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowedAddressPairs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowedAddressPairs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowedAddressPairs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedAddressPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedAddressPair = append(m.AllowedAddressPair, &AllowedAddressPair{})
			if err := m.AllowedAddressPair[len(m.AllowedAddressPair)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryResourceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryResourceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryResourceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlTrafficDscpType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlTrafficDscpType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlTrafficDscpType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Control", wireType)
			}
			m.Control = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Control |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Analytics", wireType)
			}
			m.Analytics = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Analytics |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			m.Dns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dns |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDefinedLogStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDefinedLogStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDefinedLogStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerPoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerPoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerPoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionPersistence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionPersistence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminState = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistenceCookieName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistenceCookieName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadbalancerMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValuePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValuePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValuePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpamSubnets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpamSubnets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpamSubnets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &IpamSubnetType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerListenerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerListenerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerListenerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTlsContainer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultTlsContainer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionLimit", wireType)
			}
			m.ConnectionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminState = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SniContainers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SniContainers = append(m.SniContainers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPort", wireType)
			}
			m.ProtocolPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BridgeDomainMembershipType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BridgeDomainMembershipType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BridgeDomainMembershipType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTag", wireType)
			}
			m.VlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTag |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VnSubnetsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VnSubnetsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VnSubnetsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpamSubnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpamSubnets = append(m.IpamSubnets, &IpamSubnetType{})
			if err := m.IpamSubnets[len(m.IpamSubnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostRoutes == nil {
				m.HostRoutes = &RouteTableType{}
			}
			if err := m.HostRoutes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceApplianceInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceApplianceInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceApplianceInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = append(m.Subnet, &SubnetType{})
			if err := m.Subnet[len(m.Subnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPaaServiceParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPaaServiceParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPaaServiceParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortStart", wireType)
			}
			m.PortStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortEnd", wireType)
			}
			m.PortEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortEnd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpamDnsAddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpamDnsAddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpamDnsAddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantDnsServerAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TenantDnsServerAddress == nil {
				m.TenantDnsServerAddress = &IpAddressesType{}
			}
			if err := m.TenantDnsServerAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualDnsServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualDnsServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DhcpOptionsListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DhcpOptionsListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DhcpOptionsListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpOption = append(m.DhcpOption, &DhcpOptionType{})
			if err := m.DhcpOption[len(m.DhcpOption)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MACLimitControlType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MACLimitControlType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MACLimitControlType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacLimit", wireType)
			}
			m.MacLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacLimitAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacLimitAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDefinedLogStatList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDefinedLogStatList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDefinedLogStatList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statlist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statlist = append(m.Statlist, &UserDefinedLogStat{})
			if err := m.Statlist[len(m.Statlist)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EcmpHashingIncludeFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EcmpHashingIncludeFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EcmpHashingIncludeFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DestinationIp = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpProtocol = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceIp = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashingConfigured", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashingConfigured = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourcePort = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationPort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DestinationPort = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncapsulationPrioritiesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncapsulationPrioritiesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncapsulationPrioritiesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encapsulation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encapsulation = append(m.Encapsulation, make([]byte, postIndex-iNdEx))
			copy(m.Encapsulation[len(m.Encapsulation)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualRouterNetworkIpamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualRouterNetworkIpamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualRouterNetworkIpamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = append(m.Subnet, &SubnetType{})
			if err := m.Subnet[len(m.Subnet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocationPools = append(m.AllocationPools, &AllocationPoolType{})
			if err := m.AllocationPools[len(m.AllocationPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualDnsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualDnsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualDnsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpRecord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FloatingIpRecord = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalVisible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExternalVisible = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextVirtual_DNS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextVirtual_DNS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicRecordsFromClient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DynamicRecordsFromClient = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseResolution", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReverseResolution = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTtlSeconds", wireType)
			}
			m.DefaultTtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTtlSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordOrder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordOrder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sequence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorActionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorActionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorActionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicAssistedMirroringVlan", wireType)
			}
			m.NicAssistedMirroringVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NicAssistedMirroringVlan |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalyzerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NhMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NhMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JuniperHeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JuniperHeader = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpPort", wireType)
			}
			m.UdpPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticNhHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StaticNhHeader == nil {
				m.StaticNhHeader = &StaticMirrorNhType{}
			}
			if err := m.StaticNhHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzerIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalyzerIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encapsulation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encapsulation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzerMacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalyzerMacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicAssistedMirroring", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NicAssistedMirroring = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpamMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpamMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpamDnsMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpamDnsMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpamDnsServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpamDnsServer == nil {
				m.IpamDnsServer = &IpamDnsAddressType{}
			}
			if err := m.IpamDnsServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpOptionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DhcpOptionList == nil {
				m.DhcpOptionList = &DhcpOptionsListType{}
			}
			if err := m.DhcpOptionList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostRoutes == nil {
				m.HostRoutes = &RouteTableType{}
			}
			if err := m.HostRoutes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CidrBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CidrBlock == nil {
				m.CidrBlock = &SubnetType{}
			}
			if err := m.CidrBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JunosServicePorts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JunosServicePorts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JunosServicePorts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicePort = append(m.ServicePort, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlarmOperand2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlarmOperand2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlarmOperand2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UveAttribute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UveAttribute = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsonValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RbacRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RbacRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RbacRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleObject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleObject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RulePerms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RulePerms = append(m.RulePerms, &RbacPermType{})
			if err := m.RulePerms[len(m.RulePerms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainLimitsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainLimitsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainLimitsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectLimit", wireType)
			}
			m.ProjectLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetworkLimit", wireType)
			}
			m.VirtualNetworkLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualNetworkLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupLimit", wireType)
			}
			m.SecurityGroupLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityGroupLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyEntriesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyEntriesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyEntriesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyRule = append(m.PolicyRule, &PolicyRuleType{})
			if err := m.PolicyRule[len(m.PolicyRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceHealthCheckType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceHealthCheckType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceHealthCheckType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayUsecs", wireType)
			}
			m.DelayUsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayUsecs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutUsecs", wireType)
			}
			m.TimeoutUsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutUsecs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			m.Delay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delay |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedCodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedCodes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthCheckType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonitorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &SubnetType{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetList = append(m.SubnetList, &SubnetType{})
			if err := m.SubnetList[len(m.SubnetList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowAgingTimeout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowAgingTimeout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowAgingTimeout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutInSeconds", wireType)
			}
			m.TimeoutInSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutInSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosIdForwardingClassPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosIdForwardingClassPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosIdForwardingClassPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClassId", wireType)
			}
			m.ForwardingClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardingClassId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RbacRuleEntriesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RbacRuleEntriesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RbacRuleEntriesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RbacRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RbacRule = append(m.RbacRule, &RbacRuleType{})
			if err := m.RbacRule[len(m.RbacRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatingIpPoolSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatingIpPoolSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatingIpPoolSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetUuid = append(m.SubnetUuid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceTemplateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceTemplateType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceTemplateType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZoneEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AvailabilityZoneEnable = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderedInterfaces", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrderedInterfaces = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceVirtualizationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceVirtualizationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceType = append(m.InterfaceType, &ServiceTemplateInterfaceType{})
			if err := m.InterfaceType[len(m.InterfaceType)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceScaling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServiceScaling = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrouterInstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrouterInstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FatFlowProtocols) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FatFlowProtocols: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FatFlowProtocols: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FatFlowProtocol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FatFlowProtocol = append(m.FatFlowProtocol, &ProtocolType{})
			if err := m.FatFlowProtocol[len(m.FatFlowProtocol)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MACMoveLimitControlType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MACMoveLimitControlType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MACMoveLimitControlType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacMoveTimeWindow", wireType)
			}
			m.MacMoveTimeWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacMoveTimeWindow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacMoveLimit", wireType)
			}
			m.MacMoveLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacMoveLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacMoveLimitAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacMoveLimitAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveryPubSubEndPointType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveryPubSubEndPointType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveryPubSubEndPointType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EpPrefix == nil {
				m.EpPrefix = &SubnetType{}
			}
			if err := m.EpPrefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchCondition == nil {
				m.MatchCondition = &MatchConditionType{}
			}
			if err := m.MatchCondition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionList == nil {
				m.ActionList = &ActionListType{}
			}
			if err := m.ActionList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginProperty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginProperty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginProperty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Property = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityLoggingObjectRuleListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityLoggingObjectRuleListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityLoggingObjectRuleListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = append(m.Rule, &SecurityLoggingObjectRuleEntryType{})
			if err := m.Rule[len(m.Rule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirewallServiceGroupType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirewallServiceGroupType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirewallServiceGroupType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirewallService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirewallService = append(m.FirewallService, &FirewallServiceType{})
			if err := m.FirewallService[len(m.FirewallService)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VrfAssignTableType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VrfAssignTableType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VrfAssignTableType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfAssignRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VrfAssignRule = append(m.VrfAssignRule, &VrfAssignRuleType{})
			if err := m.VrfAssignRule[len(m.VrfAssignRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlarmAndList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlarmAndList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlarmAndList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndList = append(m.AndList, &AlarmExpression{})
			if err := m.AndList[len(m.AndList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentationId", wireType)
			}
			m.SegmentationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PermType2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PermType2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PermType2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAccess", wireType)
			}
			m.OwnerAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerAccess |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalAccess", wireType)
			}
			m.GlobalAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalAccess |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Share = append(m.Share, &ShareType{})
			if err := m.Share[len(m.Share)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DhcpOptionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DhcpOptionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DhcpOptionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpOptionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpOptionValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpOptionValueBytes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpOptionValueBytes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpOptionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpOptionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosIdForwardingClassPairs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosIdForwardingClassPairs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosIdForwardingClassPairs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosIdForwardingClassPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosIdForwardingClassPair = append(m.QosIdForwardingClassPair, &QosIdForwardingClassPair{})
			if err := m.QosIdForwardingClassPair[len(m.QosIdForwardingClassPair)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PluginProperty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PluginProperty = append(m.PluginProperty, &PluginProperty{})
			if err := m.PluginProperty[len(m.PluginProperty)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlarmOrList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlarmOrList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlarmOrList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrList = append(m.OrList, &AlarmAndList{})
			if err := m.OrList[len(m.OrList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceScaleOutType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceScaleOutType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceScaleOutType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoScale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoScale = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInstances", wireType)
			}
			m.MaxInstances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInstances |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowedAddressPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowedAddressPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowedAddressPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &SubnetType{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContrail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContrail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContrail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipContrail(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowContrail
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContrail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthContrail
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowContrail
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipContrail(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthContrail = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowContrail   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/contrail.proto", fileDescriptorContrail) }

var fileDescriptorContrail = []byte{
	// 15632 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xbd, 0x5b, 0x6c, 0x24, 0xc9,
	0x76, 0x20, 0xd6, 0xac, 0x62, 0x93, 0x55, 0xa7, 0xaa, 0xc8, 0x62, 0xf2, 0x55, 0xec, 0x77, 0x67,
	0xcf, 0xa3, 0xe7, 0x55, 0x33, 0xc3, 0x9e, 0x3b, 0x77, 0xde, 0x57, 0x6c, 0xb2, 0x7b, 0xc8, 0x3b,
	0xcd, 0x1e, 0x4e, 0xb2, 0xbb, 0x47, 0xd2, 0x95, 0x94, 0xca, 0xca, 0x0c, 0x16, 0xf3, 0x76, 0x56,
	0x66, 0x4e, 0x66, 0x56, 0x75, 0x53, 0xf0, 0xd7, 0x7a, 0xbd, 0xf0, 0xc2, 0x86, 0x61, 0x1b, 0x96,
	0x25, 0x2f, 0x56, 0x6b, 0x49, 0x0b, 0x1b, 0x86, 0x65, 0xd9, 0x1f, 0x5e, 0x08, 0x86, 0x5f, 0x5f,
	0xc6, 0x7a, 0x6d, 0x78, 0x81, 0xbb, 0xfe, 0x91, 0x0c, 0xfd, 0xac, 0xb5, 0x86, 0x3f, 0xec, 0x5d,
	0x3f, 0x00, 0x2f, 0x20, 0xf9, 0xb1, 0x30, 0xe2, 0xc4, 0x89, 0xcc, 0xc8, 0x47, 0xb1, 0x7b, 0x56,
	0xc2, 0x7e, 0xd5, 0x57, 0x55, 0x9e, 0x38, 0x11, 0x19, 0x79, 0xe2, 0xc4, 0x89, 0x13, 0xe7, 0x9c,
	0x38, 0x01, 0x6b, 0x61, 0x14, 0x24, 0xc1, 0xbb, 0x76, 0xe0, 0x27, 0x91, 0xe5, 0x7a, 0x7d, 0x7c,
	0xd4, 0x3f, 0x82, 0x65, 0x83, 0xc5, 0xc1, 0x38, 0xb2, 0x99, 0xc1, 0xbe, 0x1b, 0xb3, 0x38, 0xd1,
	0x5e, 0x85, 0x46, 0x44, 0xa0, 0x5e, 0xed, 0x46, 0xfd, 0x76, 0x6b, 0xbb, 0xd9, 0x4f, 0x71, 0xd2,
	0x22, 0x7d, 0x04, 0xdd, 0xac, 0x66, 0x1c, 0x06, 0x7e, 0xcc, 0xb4, 0x6d, 0xe8, 0x44, 0xf4, 0xdf,
	0x4c, 0xce, 0x42, 0xd6, 0x9b, 0xbb, 0x31, 0x77, 0x7b, 0x69, 0xbb, 0xd3, 0x97, 0x18, 0x8f, 0xce,
	0x42, 0x66, 0xb4, 0x23, 0xe5, 0xa9, 0xf0, 0xba, 0xb9, 0x69, 0xaf, 0xdb, 0x87, 0xce, 0x1e, 0xf3,
	0x58, 0x92, 0x76, 0xf3, 0x16, 0xbe, 0x0b, 0x0b, 0xb3, 0x77, 0x35, 0xb1, 0x71, 0x04, 0x62, 0xe3,
	0x1a, 0xcc, 0x8f, 0xc7, 0xae, 0x83, 0xdf, 0xd1, 0x34, 0xf0, 0xbf, 0xfe, 0xf3, 0xb0, 0x24, 0x5b,
	0xfa, 0x73, 0x74, 0x3b, 0x6b, 0x79, 0x2e, 0x6d, 0xf9, 0xd7, 0xeb, 0xd0, 0x7a, 0xe0, 0xc6, 0xc9,
	0xf7, 0xea, 0xe2, 0x1a, 0x5c, 0xf4, 0xdc, 0x91, 0x9b, 0x60, 0x4b, 0x75, 0x43, 0x3c, 0x68, 0x1b,
	0xb0, 0x10, 0x9c, 0x9c, 0xc4, 0x2c, 0xe9, 0xd5, 0x11, 0x4c, 0x4f, 0x1c, 0xee, 0xb0, 0xc4, 0x72,
	0xbd, 0xde, 0xfc, 0x8d, 0xb9, 0xdb, 0x0d, 0x83, 0x9e, 0x78, 0x2b, 0x76, 0x30, 0xf6, 0x93, 0xde,
	0x45, 0x04, 0x8b, 0x07, 0x8e, 0x1d, 0x9f, 0x5a, 0x11, 0x73, 0x7a, 0x0b, 0x02, 0x5b, 0x3c, 0xf1,
	0x8e, 0xb1, 0xe7, 0xb6, 0x37, 0x76, 0x98, 0x79, 0x1a, 0xb1, 0x93, 0xb8, 0xb7, 0x88, 0xc5, 0x6d,
	0x02, 0xee, 0x73, 0x98, 0xf6, 0x0a, 0x2c, 0x85, 0x56, 0xc4, 0xfc, 0xc4, 0x3c, 0xf9, 0xce, 0xf4,
	0xad, 0x11, 0xeb, 0x35, 0x90, 0x8a, 0x6d, 0x01, 0xbd, 0xff, 0xdd, 0x43, 0x6b, 0xc4, 0xb4, 0xeb,
	0xd0, 0x22, 0x2c, 0xfc, 0xc2, 0x26, 0x7e, 0x21, 0x08, 0x10, 0x7e, 0xdf, 0x4d, 0xa0, 0x0a, 0x26,
	0xa7, 0x51, 0xdc, 0x03, 0x6c, 0x84, 0x2a, 0x3d, 0xe6, 0x20, 0xde, 0x9d, 0x81, 0x65, 0x3f, 0x8d,
	0xd8, 0x09, 0xe1, 0xb4, 0xc4, 0x8b, 0x08, 0x28, 0x90, 0x6e, 0x42, 0x3b, 0x18, 0xfc, 0x94, 0xd9,
	0xb2, 0x9d, 0xb6, 0x68, 0x47, 0xc0, 0x04, 0xca, 0x06, 0x2c, 0x9c, 0xb8, 0xcc, 0x73, 0xe2, 0x5e,
	0x07, 0x0b, 0xe9, 0x49, 0xff, 0x27, 0x6f, 0x43, 0x43, 0xb2, 0x94, 0xb6, 0x07, 0xab, 0x96, 0x6d,
	0xb3, 0x38, 0x36, 0x71, 0x2a, 0x04, 0x9e, 0xe9, 0xb9, 0x71, 0x82, 0xe4, 0x6c, 0x6d, 0x6b, 0xfd,
	0x1d, 0x2c, 0xdb, 0x15, 0x45, 0x7c, 0x30, 0xf7, 0x2f, 0x18, 0x2b, 0x56, 0x11, 0xa8, 0x7d, 0x00,
	0x1d, 0xcb, 0x71, 0x22, 0xde, 0xcc, 0x30, 0x0a, 0xc6, 0x21, 0xd2, 0xbd, 0xb5, 0xdd, 0xe9, 0xef,
	0x08, 0xe8, 0x97, 0x1c, 0xb8, 0x7f, 0xc1, 0x68, 0x5b, 0xca, 0xb3, 0x76, 0x0d, 0x2e, 0x5a, 0x9e,
	0x15, 0x8d, 0x70, 0x38, 0x5a, 0xdb, 0x0b, 0xfd, 0x1d, 0xfe, 0xb4, 0x7f, 0xc1, 0x10, 0x60, 0xce,
	0x88, 0x96, 0xe7, 0x5a, 0xb1, 0xe9, 0x86, 0x66, 0x18, 0x04, 0x1e, 0x8e, 0x4b, 0x6b, 0xbb, 0xdd,
	0xdf, 0xe1, 0xd0, 0x83, 0xa3, 0xa3, 0x20, 0xf0, 0xf6, 0x2f, 0x18, 0x2d, 0x44, 0x3a, 0x08, 0xf9,
	0x23, 0x9f, 0x3f, 0xb2, 0x4e, 0xaf, 0x81, 0xe8, 0x0d, 0x89, 0xbe, 0x7f, 0xc1, 0x58, 0x24, 0x54,
	0xed, 0x87, 0xb0, 0x64, 0xf9, 0x96, 0x77, 0x96, 0xb8, 0x76, 0x6c, 0xfa, 0x81, 0x23, 0x86, 0xaa,
	0xb5, 0xbd, 0xd4, 0xdf, 0x91, 0xe0, 0x87, 0x81, 0xc3, 0xf6, 0x2f, 0x18, 0x1d, 0x4b, 0x05, 0x68,
	0x1f, 0xc1, 0xb2, 0x15, 0xba, 0x26, 0xd1, 0x0c, 0x69, 0x05, 0xb2, 0xe6, 0xd1, 0x81, 0x20, 0x17,
	0xd1, 0xa9, 0x63, 0x85, 0x6e, 0x06, 0xd0, 0x0e, 0x61, 0xc3, 0x0a, 0x43, 0xcf, 0xb5, 0xad, 0xc4,
	0x0d, 0x7c, 0x33, 0x0c, 0x3c, 0xd7, 0x3e, 0x33, 0x39, 0x4f, 0xb7, 0xb0, 0x81, 0xf5, 0xfe, 0x4e,
	0x56, 0x7c, 0x84, 0xa5, 0xc7, 0x8c, 0xb7, 0xb3, 0x66, 0x55, 0xc0, 0xb5, 0x8f, 0xa1, 0x3b, 0x18,
	0x86, 0xa6, 0x15, 0x9b, 0x96, 0x19, 0xb3, 0x68, 0xe2, 0xda, 0xac, 0xd7, 0xa6, 0x9e, 0xdc, 0xfd,
	0xf2, 0x68, 0x27, 0xde, 0x39, 0x16, 0x50, 0xde, 0x93, 0xc1, 0x30, 0xcc, 0x00, 0xda, 0x5b, 0x00,
	0xbc, 0x6a, 0x14, 0x8c, 0x13, 0x16, 0xf5, 0x3a, 0x58, 0x09, 0x78, 0x25, 0x03, 0x21, 0xfb, 0x17,
	0x8c, 0xe6, 0x60, 0x18, 0x8a, 0x07, 0xed, 0x26, 0x2c, 0x0c, 0x86, 0xe1, 0x24, 0xf4, 0x7b, 0x4b,
	0x88, 0xb8, 0xc8, 0x11, 0x9f, 0x1c, 0x3d, 0xdc, 0xbf, 0x60, 0x50, 0x01, 0x1f, 0xfd, 0x41, 0xe4,
	0x3a, 0x43, 0x66, 0x3a, 0xc1, 0xc8, 0x72, 0xfd, 0xde, 0x32, 0x8d, 0xfe, 0x5d, 0x84, 0xee, 0x21,
	0x90, 0x8f, 0xfe, 0x40, 0x79, 0xd6, 0xfa, 0xd0, 0xb2, 0x03, 0xff, 0xc4, 0x1d, 0x0a, 0xfa, 0x77,
	0xb1, 0x4e, 0xab, 0xbf, 0x8b, 0x30, 0x22, 0x3e, 0xd8, 0xe9, 0x93, 0x82, 0x1f, 0x05, 0x41, 0xd2,
	0x5b, 0xc9, 0xe1, 0x1b, 0x41, 0x90, 0x64, 0xf8, 0xfc, 0x49, 0xbb, 0x0f, 0xab, 0xf6, 0x38, 0x4e,
	0x82, 0x11, 0x8b, 0x4c, 0x2b, 0x49, 0x2c, 0xfb, 0x74, 0xc4, 0xfc, 0xa4, 0xa7, 0x61, 0xbd, 0xd5,
	0xfe, 0x2e, 0x95, 0xed, 0xa4, 0x45, 0xfb, 0x17, 0x0c, 0xcd, 0x2e, 0x41, 0xf9, 0xd7, 0x39, 0x56,
	0x62, 0x0d, 0xac, 0x98, 0x89, 0x9e, 0xae, 0xd2, 0xd7, 0xed, 0x11, 0x94, 0xfa, 0xda, 0x76, 0x94,
	0x67, 0xcd, 0x84, 0x2b, 0x8e, 0x1b, 0xdb, 0xc1, 0x84, 0x45, 0x67, 0x72, 0x7c, 0x4c, 0x2b, 0x8e,
	0xdd, 0xa1, 0x8f, 0xdd, 0x58, 0xc3, 0x46, 0x2e, 0xf7, 0xf7, 0x24, 0x12, 0x0d, 0xce, 0x4e, 0x8a,
	0xb2, 0x7f, 0xc1, 0xb8, 0xe4, 0x4c, 0x2d, 0xe5, 0xe3, 0x42, 0xd4, 0x5e, 0xa7, 0x71, 0x49, 0xe9,
	0x4c, 0x05, 0x7c, 0x2e, 0x38, 0xb1, 0x65, 0x46, 0x63, 0x8f, 0xf5, 0x36, 0x68, 0x2e, 0xec, 0xc5,
	0x96, 0x31, 0xf6, 0x78, 0x7f, 0x17, 0x1d, 0xf1, 0x97, 0x8b, 0x00, 0xb6, 0x9d, 0xf6, 0x31, 0x8c,
	0x82, 0x89, 0xeb, 0xb0, 0xa8, 0xb7, 0x49, 0x22, 0xe0, 0xde, 0x36, 0xbd, 0xfc, 0x88, 0x4a, 0xb8,
	0x08, 0x60, 0x45, 0xa0, 0xf6, 0x09, 0x2c, 0x9f, 0xb8, 0x11, 0x7b, 0x66, 0x79, 0x1e, 0xf1, 0x76,
	0xaf, 0x87, 0x2d, 0x2c, 0xf7, 0xef, 0x13, 0x5c, 0x30, 0xef, 0xfe, 0x05, 0x63, 0xe9, 0x24, 0x07,
	0xe1, 0x24, 0x4e, 0xeb, 0x62, 0x6f, 0xb7, 0x88, 0xc4, 0xb2, 0x26, 0x75, 0xb9, 0x7d, 0xa2, 0x3c,
	0x6b, 0x9f, 0x42, 0xf7, 0xc4, 0x0b, 0xac, 0xc4, 0xf5, 0x87, 0xa9, 0x84, 0xb8, 0x24, 0x5f, 0x49,
	0x05, 0xa9, 0x90, 0x58, 0x92, 0xa8, 0x24, 0x27, 0xfa, 0xd0, 0x52, 0x2a, 0xf7, 0x2e, 0x13, 0x37,
	0x65, 0xf5, 0x38, 0x37, 0x65, 0x75, 0xb4, 0xcf, 0xa1, 0x7b, 0x12, 0x44, 0xcf, 0xac, 0xc8, 0xe1,
	0x35, 0x6c, 0xcf, 0x8a, 0xe3, 0xde, 0x15, 0xac, 0xd4, 0xed, 0xdf, 0x4f, 0x0b, 0x76, 0x39, 0x7c,
	0xff, 0x82, 0xb1, 0x7c, 0x92, 0x07, 0x69, 0x5f, 0xc0, 0xca, 0xd0, 0x0b, 0x06, 0x96, 0x67, 0x7e,
	0x17, 0xa0, 0xa8, 0x3d, 0x71, 0x87, 0xbd, 0xab, 0x54, 0xff, 0x4b, 0x2c, 0xf9, 0x26, 0x88, 0x05,
	0x2f, 0xf3, 0xfa, 0xc3, 0x3c, 0x48, 0xfb, 0x12, 0xd6, 0xa8, 0x7e, 0x7c, 0x16, 0x27, 0x6c, 0x24,
	0x9b, 0xb8, 0x46, 0xdc, 0x2c, 0x9a, 0x38, 0xc6, 0xb2, 0xb4, 0x15, 0x6d, 0x58, 0x82, 0x6a, 0x3f,
	0x86, 0x75, 0x6a, 0x68, 0x22, 0xe6, 0xbf, 0x6c, 0xe9, 0x3a, 0xb6, 0xb4, 0x46, 0x2d, 0x3d, 0x11,
	0x85, 0x69, 0x53, 0xab, 0xc3, 0x32, 0x98, 0xd3, 0xd0, 0xf5, 0xe3, 0xc4, 0xf2, 0x6d, 0xc6, 0x69,
	0x78, 0x83, 0x68, 0x78, 0x40, 0x30, 0x41, 0x43, 0x89, 0x71, 0x10, 0xf2, 0x77, 0xbb, 0x7e, 0xc2,
	0xa2, 0x13, 0xcb, 0x66, 0x42, 0xfa, 0x98, 0x89, 0x35, 0xf0, 0x58, 0xef, 0x26, 0xbd, 0xfb, 0x40,
	0x96, 0xa2, 0xec, 0x79, 0xc4, 0xcb, 0xf8, 0xbb, 0xdd, 0x32, 0x58, 0xfb, 0x09, 0x5c, 0xf2, 0x02,
	0xcb, 0x19, 0x58, 0x1e, 0x6f, 0x3c, 0x32, 0x4f, 0x99, 0xe5, 0x25, 0xa7, 0xa3, 0xc0, 0x77, 0x93,
	0x20, 0xea, 0xe9, 0xd8, 0xe0, 0xa5, 0xfe, 0x03, 0x05, 0x65, 0x5f, 0xc5, 0xd8, 0xbf, 0x60, 0x6c,
	0x79, 0xd3, 0x0a, 0xb5, 0x07, 0xb0, 0x9e, 0x6b, 0x9c, 0x8b, 0x79, 0xe6, 0xb3, 0xa8, 0x77, 0x8b,
	0x24, 0xb5, 0xda, 0xee, 0x03, 0x2a, 0xe4, 0x92, 0xda, 0xab, 0x80, 0x73, 0x41, 0x94, 0x6b, 0x6d,
	0xc4, 0x46, 0x03, 0x16, 0xf5, 0x5e, 0xa1, 0xa1, 0x53, 0xdb, 0x3a, 0xc4, 0x22, 0x3e, 0x74, 0x5e,
	0x09, 0xaa, 0xfd, 0x1c, 0xac, 0xe4, 0xda, 0x41, 0x86, 0x7f, 0x15, 0x5b, 0x59, 0xc9, 0xb5, 0x42,
	0x2c, 0xdf, 0xf5, 0x0a, 0x30, 0xed, 0x0e, 0xb4, 0x55, 0x58, 0xef, 0x35, 0x9a, 0x66, 0x39, 0x32,
	0x5d, 0x30, 0x72, 0x48, 0xe2, 0xb5, 0x43, 0xd7, 0xb6, 0x3c, 0x33, 0x1d, 0x88, 0xde, 0xeb, 0xe9,
	0x6b, 0xb1, 0x24, 0x1d, 0x38, 0xf1, 0xda, 0x3c, 0x8c, 0x2f, 0xb6, 0xb2, 0x05, 0x5a, 0x73, 0x6e,
	0xd3, 0x42, 0x45, 0xd5, 0xd3, 0x75, 0xa7, 0xe3, 0xa9, 0x00, 0xed, 0x4d, 0x68, 0x72, 0x4d, 0x2b,
	0x0e, 0xf9, 0x2b, 0xdf, 0xa0, 0x75, 0xea, 0xa1, 0x84, 0xf0, 0x75, 0x2a, 0x2d, 0xe6, 0xcc, 0xe5,
	0xb3, 0xe4, 0x59, 0x10, 0x3d, 0x35, 0x1d, 0x86, 0x92, 0x8c, 0x18, 0xfb, 0x4d, 0x62, 0xae, 0x87,
	0xa2, 0x74, 0x0f, 0x0b, 0x33, 0xc6, 0xf6, 0xcb, 0x60, 0xed, 0x7d, 0x68, 0xcb, 0xb6, 0xdc, 0xd0,
	0x1a, 0xf5, 0xde, 0x22, 0xbd, 0x83, 0x9a, 0x38, 0x08, 0x2d, 0xae, 0xa5, 0xb4, 0xfc, 0xec, 0x91,
	0x7f, 0xa3, 0xac, 0x42, 0xd2, 0xef, 0x6d, 0xfa, 0x46, 0xaa, 0x94, 0x0a, 0xbf, 0x8e, 0xaf, 0x02,
	0x78, 0xc5, 0x90, 0xb1, 0x88, 0x4b, 0x15, 0xaa, 0xf8, 0x0e, 0x55, 0x3c, 0x12, 0xe0, 0xac, 0x62,
	0xa8, 0x02, 0xb4, 0x5d, 0xd0, 0xc2, 0xd3, 0xb3, 0xb8, 0x30, 0x30, 0x7d, 0x92, 0xda, 0x47, 0x54,
	0xa4, 0x8e, 0xcc, 0x4a, 0x58, 0x04, 0x72, 0xa9, 0x9d, 0x36, 0x42, 0x63, 0xf3, 0x2e, 0x89, 0x50,
	0xd9, 0x42, 0x3a, 0x38, 0x4b, 0x61, 0x0e, 0xc2, 0x19, 0x83, 0x94, 0x98, 0x91, 0xe5, 0x5b, 0x43,
	0x86, 0xeb, 0xda, 0x7b, 0xc4, 0x18, 0xa2, 0x93, 0x87, 0x69, 0x01, 0x67, 0x8c, 0xb0, 0x00, 0xe3,
	0x8a, 0x48, 0x18, 0x44, 0x89, 0x99, 0x8c, 0x43, 0x8f, 0xf5, 0xde, 0xa7, 0x01, 0x3e, 0x0a, 0xa2,
	0xe4, 0x11, 0x87, 0xf0, 0x01, 0x0e, 0xe5, 0x83, 0xf6, 0x0a, 0x2c, 0x86, 0x51, 0xc0, 0xd5, 0xdb,
	0xde, 0x36, 0x2d, 0x66, 0x47, 0xe2, 0x99, 0x2f, 0x66, 0x54, 0xc4, 0x27, 0x9b, 0x5c, 0xc1, 0xd4,
	0x55, 0xff, 0x0e, 0x4d, 0x36, 0xb9, 0x5c, 0xe5, 0x57, 0xfd, 0xb0, 0x04, 0xe5, 0x5d, 0x53, 0x24,
	0xf5, 0x07, 0xd4, 0x35, 0x55, 0x46, 0x37, 0xbf, 0x4b, 0xa5, 0xf3, 0x6d, 0xe0, 0x0f, 0xe6, 0x77,
	0x63, 0x36, 0x66, 0xbd, 0x1f, 0xd0, 0xae, 0xed, 0x9b, 0x20, 0xfe, 0x86, 0x03, 0xf6, 0x2f, 0x18,
	0x8d, 0xef, 0xe8, 0x3f, 0xa7, 0xb7, 0x10, 0x7c, 0xd6, 0x70, 0x18, 0xb1, 0xa1, 0x95, 0xb0, 0xde,
	0x87, 0x44, 0x6f, 0xa4, 0xea, 0x8e, 0x04, 0x73, 0x7a, 0x47, 0x39, 0x08, 0x17, 0xb7, 0xaa, 0xd0,
	0xfc, 0x21, 0x89, 0xdb, 0x9c, 0xac, 0x84, 0x28, 0x13, 0x91, 0xef, 0x43, 0x5b, 0xe2, 0x47, 0x43,
	0x96, 0xf4, 0x3e, 0x22, 0x2e, 0xa6, 0x0a, 0x1c, 0xc6, 0xb9, 0x38, 0xca, 0x1e, 0xf9, 0x2a, 0xc7,
	0x1f, 0x71, 0x51, 0x24, 0xb9, 0xdd, 0xfb, 0x98, 0x56, 0x29, 0x43, 0x14, 0x48, 0xe9, 0xce, 0x57,
	0xa9, 0x28, 0x0f, 0xe2, 0xbc, 0x2c, 0xab, 0x13, 0x2f, 0x7f, 0x42, 0xbc, 0x4c, 0x95, 0x33, 0x5e,
	0x8e, 0x54, 0x00, 0xaf, 0x18, 0x33, 0x7b, 0x1c, 0xb9, 0xc9, 0x19, 0x6d, 0x20, 0x3e, 0xa5, 0x8a,
	0xc7, 0x04, 0x96, 0x3b, 0x88, 0x4e, 0xac, 0x02, 0xb4, 0x23, 0xd8, 0x4c, 0x2b, 0x7a, 0xc1, 0x70,
	0xc8, 0x5f, 0x2d, 0xf6, 0x40, 0xbd, 0xcf, 0xb0, 0x85, 0x8d, 0xb4, 0x85, 0x07, 0xa2, 0xf8, 0xeb,
	0x01, 0xb1, 0xcc, 0x7a, 0x5c, 0x55, 0xc0, 0xb9, 0x3a, 0x55, 0xd7, 0xb8, 0xde, 0x8d, 0x34, 0xf8,
	0x9c, 0xb8, 0x5a, 0xaa, 0x61, 0xb2, 0x80, 0x73, 0x75, 0x5c, 0x80, 0x71, 0x49, 0x54, 0x6a, 0x01,
	0xf5, 0xfc, 0x2f, 0x48, 0x12, 0x15, 0x5b, 0x11, 0x6a, 0xfe, 0x6a, 0x5c, 0x06, 0x6b, 0x4f, 0x60,
	0x4b, 0xb6, 0x65, 0x07, 0xbe, 0xcf, 0x6c, 0xdc, 0x3b, 0x8c, 0x02, 0x87, 0x6b, 0x49, 0x3f, 0xc2,
	0xf6, 0x7a, 0xb2, 0xbd, 0xdd, 0x14, 0xe1, 0x10, 0xcb, 0xf7, 0x2f, 0x18, 0x9b, 0x71, 0x75, 0x11,
	0x1f, 0x68, 0xd9, 0x2e, 0xf3, 0x9d, 0x30, 0x70, 0xfd, 0xa4, 0xf7, 0x73, 0x34, 0xd0, 0xd4, 0xdc,
	0x3d, 0x82, 0xf3, 0x81, 0x8e, 0xf3, 0x20, 0xae, 0xb0, 0xc9, 0xea, 0x62, 0xb8, 0x76, 0x68, 0x25,
	0xa1, 0xba, 0xe9, 0x7e, 0x2f, 0x56, 0x9e, 0xb9, 0x12, 0x23, 0x6b, 0x89, 0xe5, 0xda, 0xb4, 0x4f,
	0x99, 0xfd, 0xb4, 0x77, 0x97, 0x26, 0xa7, 0xdc, 0xb0, 0x60, 0xd9, 0x2e, 0x2f, 0xe2, 0x93, 0x33,
	0x2e, 0x41, 0xd5, 0xde, 0xa7, 0x6c, 0xba, 0x9b, 0xef, 0xbd, 0xca, 0xa6, 0x71, 0x1e, 0x24, 0xb8,
	0x4d, 0x54, 0x27, 0x5e, 0xd9, 0x4b, 0xb9, 0x0d, 0xc1, 0x29, 0x8f, 0xc8, 0xaf, 0x24, 0xde, 0x50,
	0xde, 0x9b, 0xb0, 0x51, 0xe8, 0xf1, 0xe9, 0x7b, 0x2f, 0xff, 0xde, 0x47, 0x04, 0x57, 0xde, 0x2b,
	0x41, 0x5c, 0x65, 0x8f, 0xc7, 0x03, 0x9f, 0x25, 0xbd, 0xfb, 0xa4, 0xb2, 0x1f, 0xe3, 0x23, 0x57,
	0xd9, 0x45, 0x81, 0xd6, 0x83, 0x7a, 0x62, 0x0d, 0x7b, 0x5f, 0x62, 0xf9, 0x7c, 0xff, 0x91, 0xc5,
	0x25, 0x0d, 0x07, 0x71, 0x65, 0x3e, 0xb1, 0x86, 0xc2, 0xac, 0xb0, 0x4f, 0xf2, 0xef, 0x91, 0x35,
	0x7c, 0x74, 0x16, 0xa2, 0x32, 0x9f, 0x88, 0xbf, 0xda, 0x65, 0x98, 0x1f, 0xc7, 0x2c, 0xea, 0x1d,
	0x20, 0xca, 0xc5, 0xfe, 0xe3, 0x18, 0x65, 0x37, 0x02, 0xb5, 0x1d, 0xd0, 0x26, 0x6e, 0x94, 0x8c,
	0x2d, 0xcf, 0xdc, 0x7b, 0x78, 0x6c, 0x46, 0xcc, 0x0e, 0x22, 0xa7, 0xf7, 0x63, 0x62, 0xee, 0x27,
	0xa2, 0x68, 0xef, 0xe1, 0xb1, 0x81, 0x05, 0x9c, 0xb9, 0x27, 0x05, 0x18, 0x17, 0x42, 0x4a, 0x13,
	0xbd, 0xaf, 0x48, 0x08, 0x65, 0x75, 0xb9, 0x10, 0xca, 0x6a, 0x71, 0x39, 0x2a, 0xf1, 0xdd, 0xb0,
	0xf7, 0x80, 0xe4, 0x28, 0xa1, 0xa3, 0x86, 0xd8, 0xa4, 0xf2, 0x83, 0x90, 0x73, 0xbb, 0x44, 0x1e,
	0x59, 0xf6, 0xa9, 0xeb, 0x33, 0x65, 0x65, 0x3b, 0x24, 0x6e, 0xa7, 0xba, 0x87, 0x02, 0x41, 0x5d,
	0xdf, 0x36, 0x27, 0xd5, 0x45, 0x5c, 0xea, 0x16, 0xda, 0xed, 0x3d, 0x24, 0xa9, 0x9b, 0x6f, 0x8d,
	0x4b, 0xdd, 0x7c, 0x23, 0x6a, 0x5d, 0x5a, 0xb8, 0x7b, 0x5f, 0xe7, 0xeb, 0xd2, 0x02, 0xaf, 0xd4,
	0x25, 0x08, 0x67, 0x34, 0x59, 0x97, 0x16, 0xd7, 0x23, 0x62, 0x34, 0xaa, 0x9a, 0x29, 0x3e, 0x13,
	0x15, 0x80, 0x56, 0x99, 0x30, 0x3c, 0x09, 0xa2, 0x91, 0xfb, 0x1c, 0x37, 0x9d, 0x66, 0x14, 0x78,
	0xac, 0xf7, 0x8d, 0xb4, 0xca, 0xc8, 0x32, 0xbe, 0xd5, 0x34, 0x02, 0x9c, 0xea, 0x2b, 0x56, 0x11,
	0xc8, 0x5f, 0x3f, 0xb0, 0x22, 0x36, 0x62, 0x09, 0xef, 0x3c, 0xdf, 0xba, 0x1a, 0xd2, 0x40, 0x20,
	0xc1, 0xd2, 0xc8, 0x31, 0x50, 0x01, 0xf9, 0x8a, 0x7c, 0x05, 0xee, 0x1d, 0x17, 0x2b, 0xf2, 0x45,
	0x3a, 0x57, 0x91, 0x03, 0xb4, 0x09, 0xbc, 0x2a, 0x2d, 0xaa, 0x66, 0x66, 0x5f, 0xc9, 0x6d, 0x9f,
	0xc5, 0x97, 0x3c, 0xc2, 0xf6, 0xf4, 0xfe, 0x2e, 0x61, 0xa7, 0x56, 0x17, 0x75, 0x53, 0x4d, 0x5f,
	0x76, 0xd3, 0x7e, 0x11, 0x12, 0x5f, 0x06, 0x2a, 0xde, 0x8b, 0x9f, 0xfc, 0x98, 0x96, 0x81, 0xd2,
	0x9b, 0xe8, 0xd3, 0xd7, 0xed, 0xaa, 0x02, 0x3e, 0xd5, 0xd3, 0x16, 0x6d, 0x6f, 0x1c, 0xf3, 0xc1,
	0x7b, 0x42, 0x53, 0x5d, 0x36, 0xb5, 0x2b, 0xe0, 0x7c, 0xaa, 0xdb, 0x79, 0x90, 0xf6, 0xab, 0x70,
	0x35, 0xab, 0x2e, 0x0c, 0x65, 0x1e, 0x8b, 0x14, 0x02, 0x7c, 0x4b, 0xfb, 0xff, 0xb4, 0xad, 0x14,
	0x49, 0xf9, 0xf2, 0x4b, 0xf6, 0xd4, 0x52, 0x2e, 0x4c, 0x2b, 0x1b, 0xfe, 0x79, 0x69, 0xdf, 0xa8,
	0x6a, 0x50, 0xb3, 0xcb, 0x0d, 0xbd, 0x09, 0x4d, 0xc7, 0x8a, 0x4f, 0x07, 0x81, 0x15, 0x39, 0xbd,
	0x5f, 0xa0, 0x09, 0xba, 0x27, 0x21, 0x7c, 0x82, 0xa6, 0xc5, 0x5c, 0x07, 0x7b, 0xca, 0xce, 0x42,
	0xcb, 0x8d, 0x7a, 0xbf, 0x48, 0x32, 0xe8, 0x2b, 0xf1, 0xcc, 0x65, 0x10, 0x15, 0x71, 0xcd, 0xf4,
	0xe9, 0x78, 0xc0, 0x22, 0x9f, 0x25, 0x2c, 0x4e, 0xa9, 0xf7, 0x13, 0x62, 0xde, 0xaf, 0xd2, 0xa2,
	0x8c, 0x7e, 0x2b, 0x4f, 0x8b, 0x40, 0x3e, 0xef, 0x94, 0x46, 0x70, 0x28, 0x7f, 0x89, 0xe6, 0x5d,
	0xd6, 0x02, 0x8d, 0xe1, 0xd2, 0xd3, 0x1c, 0x44, 0x7b, 0x1d, 0x1a, 0x5e, 0x20, 0x0c, 0x66, 0xbd,
	0x5f, 0x26, 0x75, 0xec, 0x01, 0x01, 0xb8, 0x3a, 0x26, 0x0b, 0xb9, 0xb4, 0xc4, 0x96, 0x7f, 0x85,
	0xa4, 0x25, 0xb5, 0x87, 0x40, 0xae, 0x09, 0x04, 0x21, 0xe3, 0x8b, 0x86, 0xfd, 0x34, 0xfd, 0x0a,
	0x93, 0x84, 0xe5, 0xd7, 0xb2, 0x24, 0xfb, 0x88, 0x6e, 0x50, 0x80, 0x69, 0xbf, 0x08, 0x97, 0x95,
	0x16, 0x82, 0x51, 0xc8, 0xb5, 0xb1, 0x6c, 0xa8, 0x7e, 0x15, 0xdb, 0xda, 0x52, 0xda, 0x12, 0x28,
	0xca, 0x80, 0xf5, 0x82, 0x29, 0x65, 0xf9, 0xb6, 0xe3, 0x24, 0x88, 0xac, 0xa1, 0xda, 0xb6, 0x55,
	0x6c, 0xfb, 0x58, 0xa0, 0x54, 0xb6, 0x5d, 0x28, 0xe3, 0xfa, 0xec, 0x24, 0xf4, 0x69, 0x69, 0x1f,
	0x10, 0x01, 0x9f, 0x1c, 0x3d, 0x94, 0xcb, 0x7a, 0x63, 0x12, 0xfa, 0x62, 0x49, 0xbf, 0x09, 0x0b,
	0xcf, 0x5c, 0x87, 0x6b, 0x97, 0x36, 0x2d, 0x69, 0xdf, 0xe2, 0x23, 0x5f, 0xd2, 0x44, 0xc1, 0xdd,
	0x2e, 0x2c, 0xa5, 0x66, 0xff, 0xc0, 0x67, 0xc1, 0x89, 0xfe, 0xfb, 0x75, 0x58, 0x29, 0x19, 0x96,
	0x53, 0x17, 0xc2, 0x5c, 0xe6, 0x42, 0x50, 0xcc, 0xe9, 0x8a, 0x77, 0x01, 0x32, 0x63, 0x79, 0xd1,
	0xde, 0x5e, 0x2f, 0xd9, 0xdb, 0x37, 0x61, 0x51, 0xda, 0xeb, 0xe7, 0xc9, 0x0a, 0x2e, 0x2c, 0xf5,
	0xaf, 0x43, 0xc3, 0x75, 0xcc, 0x90, 0x45, 0xa3, 0x98, 0xac, 0xd5, 0xed, 0xfe, 0x81, 0x73, 0xc4,
	0x9f, 0xd1, 0xbf, 0xb1, 0xe8, 0x8a, 0x07, 0xed, 0x26, 0xb4, 0x1d, 0x37, 0x0e, 0x3d, 0xeb, 0x4c,
	0x34, 0xb3, 0x80, 0xef, 0x68, 0x11, 0x0c, 0xdb, 0x7a, 0x0f, 0x5a, 0x96, 0xef, 0x07, 0x09, 0x32,
	0x55, 0x4c, 0x66, 0xea, 0x25, 0x3e, 0x35, 0x9e, 0x58, 0xde, 0x98, 0x1d, 0x59, 0x6e, 0x14, 0x1b,
	0x2a, 0x8a, 0xa6, 0xc3, 0x02, 0xbe, 0x7a, 0x9b, 0x8c, 0xd4, 0xd0, 0xe7, 0x2f, 0xe3, 0x2f, 0xde,
	0x36, 0xa8, 0x44, 0xfb, 0x21, 0xf4, 0x2a, 0x4c, 0xf3, 0xe6, 0xa9, 0x15, 0x9f, 0xa2, 0xb5, 0xba,
	0x6d, 0xac, 0x97, 0x2c, 0xf1, 0xfb, 0x56, 0x7c, 0xaa, 0x3d, 0x84, 0xcb, 0x55, 0x15, 0x99, 0x9f,
	0x44, 0x2e, 0x8b, 0xc9, 0x5e, 0xbd, 0xdc, 0xdf, 0xb1, 0xbd, 0x7b, 0x02, 0x84, 0x1f, 0xdc, 0x2b,
	0x35, 0x46, 0xa5, 0xfa, 0x9f, 0xd4, 0xa0, 0xad, 0x1a, 0xf2, 0x67, 0x43, 0x55, 0x1c, 0xaa, 0x1d,
	0x58, 0xcb, 0xf9, 0x3f, 0xcc, 0x30, 0x62, 0x27, 0xee, 0x73, 0x72, 0x2a, 0x2c, 0x93, 0x9e, 0xc7,
	0x69, 0x8a, 0x1d, 0xd6, 0x54, 0x37, 0xc8, 0x11, 0xa2, 0xea, 0xbf, 0x51, 0x87, 0x8b, 0xe8, 0xff,
	0x98, 0x51, 0xb7, 0x48, 0xdd, 0x77, 0xa0, 0x85, 0x0e, 0x21, 0xb4, 0x0d, 0xc7, 0x44, 0xd4, 0xb6,
	0xf0, 0x16, 0x7d, 0x8d, 0x76, 0x36, 0x03, 0x10, 0xc1, 0xe0, 0xe5, 0xfc, 0x83, 0xc6, 0x13, 0x66,
	0x3e, 0x65, 0x67, 0x92, 0xd7, 0xdb, 0xfd, 0xc7, 0x13, 0xf6, 0x15, 0x3b, 0xa3, 0x0f, 0x1a, 0x8b,
	0x07, 0xed, 0x55, 0x58, 0x12, 0xed, 0xc6, 0x6c, 0xc2, 0xf8, 0x4e, 0x10, 0x3d, 0x31, 0x75, 0xa3,
	0x83, 0xd0, 0x63, 0x02, 0xea, 0x7f, 0xa3, 0x06, 0x2d, 0xc5, 0xe3, 0x34, 0x1b, 0x9f, 0xc2, 0xf8,
	0xe8, 0xff, 0x4f, 0x0d, 0x16, 0x89, 0x40, 0x33, 0xe2, 0x14, 0x99, 0xf7, 0x36, 0x74, 0x53, 0x27,
	0x26, 0x4d, 0x7b, 0x72, 0x0b, 0x2f, 0x91, 0x33, 0x92, 0x44, 0xab, 0xf6, 0x03, 0xd8, 0x2c, 0x62,
	0x9a, 0x27, 0xd6, 0xc8, 0xf5, 0xce, 0x90, 0x8d, 0x9b, 0xc6, 0x5a, 0xbe, 0xc2, 0x7d, 0x2c, 0xd3,
	0xff, 0xb8, 0x06, 0x9d, 0xbc, 0xee, 0x3a, 0x1b, 0x83, 0xc2, 0x18, 0x7c, 0x0c, 0x5b, 0xf9, 0x5d,
	0x41, 0x79, 0x30, 0x36, 0x72, 0x6e, 0xde, 0x94, 0xc6, 0xfa, 0x3f, 0xe2, 0xd4, 0x55, 0x1d, 0xbb,
	0x33, 0xea, 0x16, 0xa9, 0xfb, 0x15, 0x6c, 0x16, 0x5c, 0xe2, 0xa9, 0xaa, 0xd1, 0x24, 0x8b, 0x97,
	0x31, 0xb0, 0x6c, 0x2e, 0x9c, 0x55, 0x7d, 0x63, 0x2d, 0xe7, 0x1e, 0x97, 0xba, 0xc6, 0x7f, 0x5f,
	0x83, 0xb5, 0x2a, 0x3f, 0xf8, 0x8c, 0xec, 0x45, 0xb2, 0xbf, 0xc1, 0x05, 0x8b, 0x67, 0x2a, 0xc1,
	0x01, 0x82, 0xde, 0x0d, 0x63, 0xd9, 0xf2, 0x3c, 0x85, 0x86, 0xb1, 0xfe, 0xbf, 0xcf, 0x43, 0x27,
	0x17, 0x13, 0x30, 0xa3, 0x66, 0x91, 0x9a, 0xb7, 0xa0, 0x33, 0x18, 0x86, 0x96, 0x15, 0x9b, 0x14,
	0x22, 0x24, 0x48, 0xd9, 0x16, 0xc0, 0x63, 0x11, 0x28, 0xf4, 0x09, 0x6c, 0x49, 0x24, 0x16, 0xc7,
	0x6e, 0xe0, 0x9b, 0x56, 0x92, 0x44, 0xee, 0x60, 0x9c, 0x90, 0x5a, 0xdd, 0x34, 0x36, 0xa9, 0x82,
	0x28, 0xdf, 0x49, 0x8b, 0xb5, 0x43, 0xb8, 0x25, 0xeb, 0x8e, 0xc3, 0x10, 0x85, 0x3b, 0x79, 0x02,
	0x9c, 0x09, 0x8b, 0x12, 0x37, 0x16, 0xfe, 0x93, 0x16, 0xbe, 0xf6, 0x06, 0xb5, 0x42, 0x98, 0xc2,
	0x35, 0xa0, 0xe2, 0x69, 0x7b, 0x70, 0x9d, 0x9a, 0x73, 0xc3, 0xc9, 0x07, 0xe6, 0xc8, 0x0a, 0x43,
	0xe6, 0xf0, 0xff, 0x1f, 0x9a, 0x3e, 0x7b, 0x9e, 0x9c, 0x06, 0x21, 0x46, 0x83, 0x34, 0x8c, 0xcb,
	0x02, 0xed, 0x20, 0x9c, 0x7c, 0x70, 0x88, 0x48, 0x07, 0xe1, 0xe4, 0xc3, 0x87, 0x02, 0x45, 0x7b,
	0x13, 0x56, 0xd2, 0x56, 0x52, 0x81, 0xd8, 0xc1, 0x0f, 0x59, 0x96, 0xf5, 0xe4, 0xf2, 0xf4, 0x16,
	0xac, 0x58, 0xe3, 0x24, 0xf0, 0x83, 0x51, 0x30, 0x8e, 0xc9, 0x0d, 0x8d, 0x31, 0x21, 0x75, 0xa3,
	0x9b, 0x15, 0x08, 0x67, 0xb3, 0xfe, 0xd7, 0x6b, 0xd0, 0x4c, 0x03, 0x4a, 0x66, 0xdc, 0x56, 0xd4,
	0x98, 0xfe, 0x95, 0x79, 0x58, 0x10, 0x61, 0x34, 0x33, 0xda, 0x14, 0x67, 0xe2, 0x67, 0xb0, 0xa2,
	0xba, 0xad, 0x44, 0x8c, 0x55, 0x53, 0x71, 0x42, 0x91, 0xb3, 0x0a, 0xf5, 0xfe, 0xe5, 0x28, 0x0f,
	0xd0, 0x0e, 0xa0, 0xe7, 0x8e, 0xd0, 0xa9, 0x58, 0x6e, 0x04, 0xa6, 0x34, 0xb2, 0x2e, 0x6a, 0x18,
	0xe5, 0xa6, 0xd8, 0xf3, 0x29, 0x4d, 0xb5, 0xa6, 0x35, 0x25, 0x6a, 0x14, 0x9b, 0xba, 0x0e, 0x2d,
	0x11, 0x2b, 0x25, 0xc6, 0xab, 0x2d, 0xc6, 0x4b, 0x80, 0xf8, 0xd7, 0xeb, 0xff, 0xda, 0x3c, 0xb4,
	0xd5, 0x68, 0xa9, 0x19, 0x5b, 0x14, 0xd9, 0xe2, 0x15, 0x58, 0x1a, 0x59, 0xb6, 0x69, 0xa1, 0x8b,
	0x2f, 0x71, 0x47, 0x22, 0x62, 0xaf, 0x6e, 0xb4, 0x47, 0x96, 0xbd, 0xc3, 0x81, 0x8f, 0xdc, 0x11,
	0xae, 0x6b, 0x6e, 0xec, 0x3a, 0x38, 0xd4, 0x75, 0x03, 0xff, 0x6b, 0xef, 0xc1, 0x1a, 0xaf, 0xe9,
	0x31, 0x2b, 0xf2, 0x79, 0x65, 0xe6, 0x5b, 0x03, 0x8f, 0x39, 0x24, 0x6a, 0xb5, 0x91, 0x65, 0x3f,
	0xa0, 0xa2, 0x7b, 0xa2, 0x44, 0xbb, 0x0b, 0x5d, 0x5e, 0x63, 0x14, 0x4c, 0x98, 0x34, 0xa1, 0x50,
	0x6c, 0x5d, 0xaf, 0x7f, 0xb8, 0xb3, 0x7b, 0x18, 0x4c, 0xd8, 0x03, 0x77, 0xe4, 0x26, 0x64, 0x2b,
	0x41, 0x0a, 0xf1, 0xde, 0xf1, 0x02, 0x82, 0x69, 0x3f, 0x07, 0x2b, 0xf8, 0x56, 0x8e, 0x97, 0x36,
	0xd2, 0x21, 0x7d, 0xe8, 0x70, 0x67, 0xb7, 0xd4, 0xc0, 0x32, 0xef, 0x88, 0x02, 0xe4, 0xaa, 0x10,
	0x64, 0xd1, 0x70, 0x33, 0x8e, 0x28, 0x72, 0xc4, 0x1d, 0xd8, 0x50, 0x02, 0x08, 0xcb, 0x2a, 0xfd,
	0x6a, 0x16, 0x3c, 0x98, 0xe9, 0xf3, 0xbf, 0x95, 0x12, 0x15, 0x83, 0x04, 0x67, 0x44, 0x2d, 0xac,
	0x4c, 0xff, 0x4e, 0x0d, 0xb4, 0x72, 0x68, 0xe4, 0x8c, 0x4e, 0x45, 0x3a, 0xfd, 0x51, 0x0d, 0xda,
	0xaa, 0x1b, 0x6a, 0x46, 0xa1, 0x0a, 0xf3, 0x75, 0xde, 0xf1, 0x57, 0x9a, 0xa0, 0xeb, 0x6a, 0xc4,
	0x6c, 0x36, 0x45, 0x7f, 0xbf, 0x06, 0x97, 0xa6, 0x87, 0xc5, 0xce, 0x08, 0x5d, 0x64, 0xc5, 0xbf,
	0x57, 0x83, 0x85, 0x99, 0xd6, 0x50, 0xcd, 0x84, 0x1f, 0x42, 0x47, 0x04, 0x43, 0x8b, 0x85, 0x58,
	0x5a, 0x24, 0x56, 0x28, 0x58, 0x1a, 0xd7, 0x5b, 0xd1, 0xd7, 0xb6, 0xa3, 0x40, 0xf4, 0xff, 0xb1,
	0x06, 0x8b, 0x14, 0x2a, 0x3d, 0x23, 0x6a, 0x91, 0xa8, 0xf7, 0x60, 0x49, 0xc6, 0x95, 0xa3, 0xa5,
	0xe7, 0x8c, 0xa8, 0x7a, 0xfd, 0x9c, 0x68, 0x76, 0xa2, 0xb1, 0x20, 0xe9, 0x3d, 0x5e, 0x49, 0xff,
	0x5f, 0x6b, 0xb0, 0x52, 0x0a, 0x2e, 0x9f, 0x51, 0xbb, 0x4c, 0xed, 0xeb, 0x15, 0xe1, 0xf9, 0xfc,
	0xcf, 0xc8, 0x8d, 0xed, 0x71, 0x30, 0x96, 0x66, 0x9f, 0x2b, 0xa5, 0xa0, 0xfc, 0xa3, 0x0c, 0x47,
	0xff, 0x9d, 0x1a, 0x2c, 0xe5, 0x03, 0xf1, 0x67, 0xa4, 0x2e, 0x4a, 0xd2, 0xdf, 0xbc, 0x08, 0x6d,
	0xf5, 0xc8, 0xc1, 0x8c, 0x42, 0x45, 0x66, 0xfc, 0x08, 0x40, 0xc6, 0x0b, 0x9a, 0xef, 0xd3, 0xb4,
	0xdf, 0xca, 0x1d, 0xd3, 0x90, 0x31, 0x82, 0xd8, 0xe1, 0xa6, 0x44, 0x7e, 0x3f, 0x57, 0x73, 0x9b,
	0xb6, 0xe2, 0x2f, 0x53, 0x73, 0x1b, 0xbf, 0x44, 0xc4, 0x3d, 0x2a, 0x5b, 0xef, 0xe5, 0xfe, 0x0e,
	0xc2, 0x52, 0x9f, 0x2a, 0x58, 0xe9, 0xb3, 0xd6, 0x87, 0xc5, 0xfc, 0x91, 0xa8, 0xb5, 0xf4, 0x45,
	0x32, 0x4c, 0x0f, 0xc9, 0x49, 0x48, 0xda, 0x15, 0x68, 0x3a, 0x6e, 0x24, 0x02, 0x24, 0xc9, 0xfc,
	0x95, 0x01, 0xb4, 0x7d, 0x58, 0x1e, 0x59, 0x89, 0x7d, 0x6a, 0xca, 0xf8, 0xbb, 0x98, 0x8e, 0x42,
	0xdd, 0xc8, 0x75, 0xff, 0x90, 0xe3, 0x3c, 0xb2, 0x86, 0x38, 0x54, 0x07, 0x0e, 0x9a, 0x03, 0x3a,
	0x23, 0x02, 0x72, 0x58, 0xac, 0x7d, 0x0c, 0x90, 0xb6, 0x14, 0xd3, 0x29, 0xa9, 0x4b, 0xd3, 0x1b,
	0x31, 0x9a, 0xb2, 0x7a, 0xac, 0xff, 0x63, 0x3e, 0x7d, 0x73, 0x87, 0x5a, 0x66, 0xcc, 0x59, 0x64,
	0x4e, 0x03, 0x7a, 0xc5, 0x03, 0x41, 0xa6, 0x88, 0xab, 0x8c, 0x33, 0x56, 0xcd, 0x1d, 0x03, 0x12,
	0x7e, 0x79, 0xec, 0xfe, 0xfa, 0x49, 0x45, 0x49, 0xac, 0xff, 0x0f, 0x17, 0x01, 0x32, 0xba, 0xcf,
	0x68, 0x5e, 0xa4, 0xf9, 0xa7, 0x70, 0x49, 0xa5, 0x79, 0xc1, 0x6f, 0x29, 0xf4, 0xfc, 0xcd, 0x8c,
	0xb4, 0x39, 0xd7, 0xa5, 0xb6, 0x0f, 0x5b, 0xf9, 0x01, 0x8b, 0x12, 0xb4, 0x64, 0xbb, 0xfe, 0x50,
	0xba, 0xee, 0x3b, 0x78, 0x1c, 0xe0, 0x90, 0x80, 0xc6, 0x86, 0x3a, 0x4a, 0x19, 0x5c, 0xfb, 0x28,
	0xdf, 0x92, 0x1b, 0x9b, 0x4a, 0xd4, 0xa9, 0x30, 0xf4, 0x28, 0x03, 0x7c, 0x10, 0x3f, 0x49, 0x63,
	0x4e, 0xfb, 0xb0, 0x5a, 0xf1, 0x01, 0x64, 0xa2, 0x5b, 0x29, 0xf5, 0x5c, 0xbb, 0x0f, 0x37, 0xa6,
	0xf6, 0x99, 0x4c, 0x4b, 0x28, 0x42, 0x1a, 0xc6, 0x95, 0xea, 0xbe, 0x0a, 0x23, 0x93, 0xf6, 0x05,
	0x5c, 0x51, 0xdb, 0x39, 0x71, 0x9f, 0xa3, 0xfd, 0x3e, 0xed, 0xc0, 0x12, 0x76, 0xa0, 0x97, 0xb5,
	0x71, 0x9f, 0x63, 0x64, 0xfd, 0xd8, 0x81, 0xab, 0x6a, 0xfd, 0x24, 0xb2, 0x4e, 0x4e, 0x5c, 0xdb,
	0xcc, 0xe4, 0xd8, 0x32, 0x36, 0x70, 0x29, 0x6b, 0xe0, 0x91, 0x40, 0xd9, 0x93, 0x18, 0xfa, 0x5f,
	0x99, 0x87, 0xe5, 0xc2, 0xd9, 0xb5, 0x19, 0x83, 0x17, 0x19, 0x7c, 0x1b, 0xd6, 0x8b, 0x07, 0xff,
	0x4c, 0x27, 0xb6, 0x43, 0x32, 0x3f, 0xae, 0x16, 0x4e, 0xfa, 0xed, 0xc5, 0x76, 0xa8, 0xed, 0xc2,
	0xb5, 0x52, 0x9d, 0x89, 0x67, 0xf9, 0x66, 0x18, 0xb9, 0x01, 0x06, 0x9a, 0x08, 0xfb, 0xe4, 0xe5,
	0x42, 0xe5, 0x27, 0x9e, 0xe5, 0x1f, 0x11, 0x8a, 0xf6, 0x31, 0x6c, 0x95, 0x1a, 0x19, 0x85, 0x5e,
	0x6c, 0xb2, 0xe7, 0x21, 0x05, 0xaa, 0x6c, 0x14, 0xea, 0x1f, 0x86, 0x5e, 0x7c, 0xef, 0xb9, 0xe0,
	0xe9, 0x62, 0x55, 0xd7, 0x41, 0x9e, 0xae, 0x1b, 0x2b, 0x85, 0x4a, 0x07, 0x8e, 0xfe, 0x8f, 0x6a,
	0xb0, 0x5c, 0x38, 0x84, 0x38, 0x63, 0x84, 0x22, 0x23, 0x1c, 0xa4, 0x01, 0xb7, 0xd9, 0x64, 0x93,
	0x7c, 0xd0, 0xda, 0xde, 0x94, 0x01, 0xb7, 0x72, 0x96, 0xc5, 0x76, 0x28, 0x62, 0xbd, 0xec, 0x12,
	0x5c, 0xff, 0x6b, 0x0d, 0xd0, 0xca, 0x27, 0x36, 0x67, 0x24, 0x2f, 0x92, 0xfc, 0x55, 0x58, 0x22,
	0x0b, 0xef, 0x84, 0x45, 0x31, 0x17, 0x6a, 0x62, 0x41, 0xe9, 0x08, 0xe8, 0x13, 0x01, 0xd4, 0xf6,
	0x53, 0x2f, 0x66, 0x68, 0x45, 0xd6, 0x88, 0x25, 0x2c, 0x92, 0xcb, 0xc7, 0xe5, 0xfe, 0xdd, 0x2f,
	0x8f, 0x2c, 0x4b, 0xee, 0x8b, 0xd2, 0x62, 0xfc, 0xc0, 0xae, 0xa8, 0x95, 0x41, 0xf9, 0x97, 0x8a,
	0x88, 0x30, 0x12, 0xe4, 0x62, 0xe5, 0x10, 0xd1, 0x67, 0x24, 0xb7, 0xff, 0x22, 0x7c, 0x03, 0x1f,
	0x42, 0x27, 0xf4, 0xc6, 0x43, 0xd7, 0x37, 0x93, 0xb1, 0xef, 0xfa, 0x43, 0xf2, 0x0b, 0xac, 0xf4,
	0x8f, 0x10, 0x7a, 0x14, 0x05, 0x21, 0x8b, 0x12, 0x97, 0xc5, 0x46, 0x5b, 0xe0, 0x3d, 0x42, 0x34,
	0xed, 0x15, 0x58, 0x72, 0xf1, 0xd0, 0xff, 0x38, 0x09, 0xcc, 0x11, 0x8b, 0x4f, 0x71, 0x95, 0x68,
	0x18, 0x6d, 0x0e, 0xdd, 0x19, 0x27, 0xc1, 0x21, 0x8b, 0x4f, 0x2b, 0x3c, 0x25, 0xcb, 0x15, 0x9e,
	0x92, 0x3b, 0xb0, 0x81, 0x4d, 0x79, 0xcf, 0xac, 0xb3, 0x18, 0x83, 0x93, 0xad, 0x88, 0x99, 0x23,
	0xe6, 0xe0, 0x49, 0xfc, 0x86, 0xb1, 0xca, 0x9b, 0xc4, 0xc2, 0x5d, 0x51, 0x76, 0xc8, 0x1c, 0xed,
	0x09, 0x5c, 0x1e, 0xc7, 0x2c, 0x32, 0x1d, 0x76, 0xe2, 0xfa, 0xcc, 0x31, 0xbd, 0x60, 0x68, 0xc6,
	0x7c, 0x44, 0xe3, 0xc4, 0xb5, 0x63, 0x3a, 0x93, 0xbf, 0x89, 0x87, 0x4e, 0xf6, 0x04, 0xca, 0x83,
	0x60, 0x78, 0x9c, 0x58, 0xc2, 0x39, 0xd6, 0x1b, 0x97, 0xe0, 0xa2, 0xa2, 0xf6, 0x2b, 0x70, 0x79,
	0x18, 0x59, 0x36, 0x3b, 0x19, 0x7b, 0x66, 0xc4, 0xe2, 0xc4, 0x8a, 0x12, 0x75, 0x2c, 0xc5, 0x99,
	0xfd, 0x6b, 0xfd, 0x2f, 0x09, 0xc7, 0x10, 0x28, 0x85, 0xe1, 0xdc, 0x1a, 0x4e, 0x2b, 0xd6, 0x3e,
	0x85, 0x15, 0xbe, 0xc6, 0x5a, 0x83, 0xc8, 0xb5, 0x53, 0x95, 0x70, 0xb5, 0x3a, 0x38, 0x73, 0xd9,
	0x0d, 0xef, 0x23, 0x22, 0xa9, 0x80, 0xd5, 0x8e, 0xef, 0xb5, 0x6a, 0xc7, 0x77, 0xb5, 0xdb, 0x67,
	0xfd, 0xfb, 0xb8, 0x7d, 0xfe, 0x8b, 0x05, 0x58, 0xad, 0x38, 0x84, 0x3d, 0x93, 0x0e, 0x45, 0xe9,
	0xf0, 0xf3, 0x70, 0x99, 0xd9, 0xa3, 0x10, 0x03, 0xa2, 0xc5, 0x89, 0x45, 0x91, 0xc3, 0x85, 0x92,
	0x9e, 0x48, 0x8d, 0xff, 0x9e, 0x3d, 0x0a, 0xf7, 0x05, 0xca, 0x81, 0xc0, 0xb8, 0x8f, 0x08, 0x46,
	0x8f, 0x4d, 0x29, 0xd1, 0x1e, 0x00, 0x57, 0x59, 0x9f, 0x29, 0x53, 0x28, 0x18, 0xe7, 0x7c, 0xc8,
	0xeb, 0x7c, 0x1f, 0xf1, 0x2c, 0x9d, 0x4c, 0xc1, 0x58, 0x30, 0xf8, 0xda, 0x49, 0x05, 0x54, 0x7b,
	0x1d, 0x94, 0x74, 0x00, 0xe6, 0x28, 0x70, 0x84, 0x5c, 0x69, 0x1a, 0x4b, 0x19, 0xf8, 0x30, 0x70,
	0x98, 0x76, 0x1b, 0x13, 0x1a, 0x3c, 0x33, 0xa5, 0xd7, 0xd9, 0x4a, 0x18, 0xad, 0xd9, 0x4b, 0x1c,
	0x7e, 0x4f, 0xb8, 0x96, 0xad, 0x84, 0x69, 0xf7, 0x41, 0xf3, 0x5c, 0xff, 0xa9, 0x17, 0xd8, 0x96,
	0x27, 0x4d, 0x43, 0x31, 0x49, 0x91, 0xcd, 0xfe, 0x03, 0x59, 0x44, 0x62, 0x0f, 0x07, 0x2c, 0x36,
	0x56, 0xbc, 0x22, 0x5c, 0xfb, 0x16, 0x7a, 0xcc, 0xb7, 0xad, 0x30, 0x1e, 0x7b, 0x94, 0x95, 0x44,
	0x68, 0x1f, 0x6e, 0xba, 0xc7, 0xbd, 0xd2, 0xbf, 0xa7, 0x22, 0x1c, 0xa5, 0xe5, 0xc8, 0x04, 0x9b,
	0xac, 0xba, 0x90, 0x6b, 0xa7, 0x93, 0xe7, 0x5c, 0xe3, 0x49, 0xcf, 0x51, 0x3b, 0xcc, 0x4f, 0xdc,
	0x13, 0x97, 0x45, 0x82, 0x02, 0xa4, 0x9d, 0x22, 0x92, 0x3c, 0x56, 0x9d, 0xa2, 0x20, 0x35, 0x3e,
	0x84, 0x4d, 0x21, 0x85, 0xcd, 0xe2, 0x09, 0x4f, 0x92, 0x50, 0xeb, 0xa2, 0xb8, 0x70, 0xbe, 0x53,
	0xff, 0xa3, 0x8b, 0x00, 0x59, 0x0a, 0x82, 0xd9, 0xb4, 0x29, 0x4e, 0x9b, 0x1f, 0xc0, 0x66, 0xd5,
	0x29, 0x4c, 0xbe, 0x51, 0x12, 0x76, 0xc4, 0xb5, 0xf2, 0x89, 0xcb, 0x83, 0x50, 0xdb, 0x83, 0x5e,
	0xcc, 0xec, 0xc0, 0x77, 0xac, 0xe8, 0x8c, 0x36, 0x1c, 0xf6, 0x53, 0xca, 0x9e, 0x01, 0x74, 0x0a,
	0x50, 0xdd, 0x4e, 0xa7, 0xc8, 0xb8, 0xf1, 0x40, 0x54, 0xb1, 0xdb, 0x52, 0x52, 0x46, 0xa4, 0x9b,
	0x1d, 0x31, 0x1f, 0x56, 0xb2, 0x5c, 0x11, 0x72, 0x97, 0x73, 0x1b, 0xba, 0x2a, 0x3e, 0xb2, 0x8e,
	0xd8, 0x9a, 0x2d, 0x65, 0xc8, 0xc8, 0x2e, 0xd7, 0xa1, 0x25, 0x04, 0xbb, 0x18, 0x53, 0x61, 0xc5,
	0x01, 0x01, 0xc2, 0x31, 0x7d, 0x1b, 0x34, 0xb5, 0x29, 0xda, 0xa1, 0x8a, 0x6d, 0x56, 0x37, 0x6b,
	0x8c, 0xb6, 0xa6, 0x7d, 0x58, 0x2d, 0x1e, 0x31, 0xe5, 0x5f, 0xba, 0x8c, 0x14, 0x5a, 0x29, 0x9c,
	0x28, 0x3d, 0x08, 0xb5, 0x77, 0x61, 0x4d, 0x6d, 0x5d, 0xcc, 0x4c, 0x37, 0x24, 0x56, 0x55, 0xbe,
	0xec, 0x01, 0x2f, 0x39, 0x08, 0xf9, 0xbe, 0x42, 0xad, 0x90, 0x92, 0x0b, 0x17, 0xd1, 0x86, 0xb1,
	0x9a, 0xd5, 0x38, 0x96, 0x45, 0xfa, 0x9f, 0xd6, 0x60, 0xb5, 0x22, 0x47, 0xc6, 0x8c, 0xc7, 0x8b,
	0x3c, 0x7e, 0x04, 0x57, 0x2a, 0x33, 0x8d, 0x88, 0xff, 0x71, 0x7a, 0x2e, 0x23, 0xa3, 0xa1, 0xd0,
	0x20, 0x2a, 0x32, 0x8d, 0xe0, 0xbf, 0x58, 0xff, 0xed, 0x3a, 0x6c, 0x4d, 0xcd, 0x26, 0x32, 0x1b,
	0x80, 0xe2, 0x00, 0x44, 0xf0, 0xea, 0xf4, 0xf4, 0x2c, 0x66, 0x98, 0x2a, 0xb8, 0x34, 0x12, 0xd7,
	0xa6, 0x67, 0x6a, 0xc1, 0x0f, 0xba, 0x35, 0x35, 0x57, 0x4b, 0xa6, 0x2b, 0xeb, 0xff, 0x72, 0x1d,
	0xd6, 0xaa, 0x12, 0xb3, 0xcc, 0x46, 0xa7, 0x38, 0x3a, 0x36, 0xdc, 0xa8, 0xcc, 0x6f, 0x53, 0x1e,
	0x98, 0xad, 0xca, 0x54, 0x37, 0xf8, 0x19, 0xd7, 0xaa, 0x92, 0xdd, 0x28, 0xc3, 0xf1, 0x97, 0xeb,
	0xa0, 0x95, 0x73, 0xdb, 0xcc, 0x06, 0xa3, 0x38, 0x18, 0xbf, 0x0c, 0xd7, 0x2a, 0xd2, 0x03, 0x95,
	0x87, 0x62, 0xb3, 0x22, 0x53, 0x10, 0x7e, 0xc2, 0x95, 0x72, 0xae, 0x20, 0x65, 0x18, 0xfe, 0xad,
	0x79, 0xe8, 0x16, 0x93, 0x03, 0xcd, 0x06, 0xa1, 0x38, 0x08, 0xdf, 0xc2, 0x95, 0x52, 0x6e, 0xa5,
	0xf2, 0x10, 0xac, 0x97, 0xd2, 0x2c, 0x61, 0xf7, 0x2f, 0x15, 0x13, 0x2d, 0x65, 0xe4, 0xd7, 0x7e,
	0x19, 0x6e, 0x95, 0x1b, 0x16, 0x59, 0xe6, 0x8a, 0xc1, 0xe3, 0xe5, 0xcf, 0xb8, 0x51, 0x6c, 0x58,
	0x44, 0x66, 0x29, 0x51, 0xe5, 0x9f, 0x15, 0xd2, 0x60, 0xc9, 0x7e, 0x8b, 0x14, 0x6e, 0x42, 0xad,
	0xea, 0x55, 0x74, 0x0f, 0xcb, 0xf9, 0xa2, 0xd6, 0x56, 0xbf, 0x68, 0xc6, 0x17, 0x45, 0xbe, 0xf8,
	0x31, 0x6c, 0xe6, 0xe9, 0x5b, 0x64, 0x89, 0x7c, 0xe6, 0x2d, 0xec, 0xf5, 0x46, 0x8e, 0xde, 0x19,
	0x2b, 0xdc, 0x29, 0x64, 0x15, 0x4b, 0x87, 0x89, 0x4e, 0x77, 0x15, 0xaa, 0x89, 0x21, 0xfa, 0x37,
	0xeb, 0x7c, 0xfa, 0x16, 0x12, 0x6a, 0xcd, 0x86, 0xa9, 0xec, 0x85, 0x2a, 0xe5, 0x28, 0x13, 0x16,
	0xf7, 0xc4, 0x1a, 0x92, 0xa5, 0x7e, 0xb3, 0x98, 0x97, 0xec, 0x89, 0x67, 0xf9, 0x8f, 0xac, 0xa1,
	0xf6, 0x01, 0x6c, 0x94, 0x2b, 0x23, 0x8d, 0xd2, 0x81, 0xc9, 0x57, 0xc4, 0x88, 0xed, 0xdf, 0xaf,
	0x43, 0x27, 0x97, 0xbe, 0x6c, 0x36, 0x2a, 0xe5, 0x60, 0x81, 0xde, 0x34, 0x23, 0x80, 0x3c, 0x75,
	0x57, 0xbd, 0xff, 0xd7, 0xbe, 0x81, 0x2b, 0xc2, 0xc4, 0x3b, 0x8e, 0x98, 0xf3, 0x3d, 0x22, 0xf9,
	0xb7, 0xb2, 0x5a, 0x85, 0x22, 0xfd, 0x67, 0x35, 0x68, 0xa6, 0xa9, 0xe3, 0x66, 0x63, 0x55, 0x76,
	0x73, 0x2d, 0xa5, 0xb9, 0xf4, 0x4c, 0xdb, 0x75, 0x22, 0x92, 0x6f, 0xb9, 0x4d, 0x7d, 0x27, 0x45,
	0xd9, 0x75, 0x9d, 0x48, 0xff, 0x77, 0x6b, 0xb0, 0x5a, 0x91, 0x55, 0x6f, 0x46, 0xdc, 0x62, 0x5c,
	0xd1, 0xdf, 0xaa, 0x43, 0x4b, 0xc9, 0x1d, 0x38, 0x23, 0x50, 0xd9, 0x26, 0xb5, 0xa2, 0x26, 0x5c,
	0x34, 0x47, 0xc3, 0x91, 0x3c, 0xf3, 0xd3, 0xec, 0x73, 0x92, 0x09, 0x53, 0xb9, 0x92, 0x70, 0xf1,
	0x70, 0x38, 0x4a, 0xb4, 0x77, 0xa1, 0x8d, 0xe8, 0xd2, 0xa2, 0x2f, 0x4f, 0xfb, 0x73, 0x04, 0xb2,
	0xde, 0x1b, 0x2d, 0x37, 0x7b, 0x40, 0x1b, 0x50, 0x56, 0xc1, 0x1c, 0xb1, 0xe4, 0x34, 0x70, 0x48,
	0x4d, 0xea, 0x66, 0x88, 0x87, 0x08, 0xd7, 0xff, 0x97, 0x1a, 0x74, 0x72, 0xd9, 0x1b, 0x67, 0x03,
	0x57, 0x1c, 0xb8, 0x7d, 0xd8, 0xc8, 0xa7, 0xbd, 0x2c, 0x1c, 0xfd, 0xd5, 0x28, 0x11, 0x64, 0xee,
	0xe0, 0x6f, 0x2e, 0x01, 0xa6, 0x3c, 0xf8, 0xfb, 0xdf, 0xd4, 0xa0, 0x93, 0xcb, 0x78, 0x39, 0x23,
	0x76, 0x91, 0xd8, 0xaf, 0xc3, 0xb2, 0x4c, 0x15, 0x2a, 0xc3, 0xdb, 0x28, 0x93, 0x00, 0x81, 0xc9,
	0xae, 0xaf, 0xff, 0x4f, 0x35, 0x58, 0x29, 0x25, 0x00, 0x9d, 0xd1, 0xb3, 0x48, 0xcf, 0x2f, 0xe0,
	0x32, 0x4b, 0x4e, 0x31, 0x71, 0x94, 0x19, 0xb3, 0xe1, 0x88, 0x7f, 0x65, 0x49, 0x45, 0xd9, 0x92,
	0x28, 0xc7, 0x02, 0x23, 0xd3, 0x52, 0xf4, 0xbf, 0xd3, 0x84, 0xa5, 0x7c, 0x96, 0xd4, 0x19, 0x8d,
	0xcb, 0x99, 0x71, 0xae, 0x16, 0x12, 0xcc, 0x2a, 0xd9, 0x62, 0xa5, 0xcf, 0xa1, 0x69, 0x5c, 0xca,
	0xe7, 0x96, 0xcd, 0x72, 0xc4, 0x1e, 0x84, 0xda, 0x2f, 0xc0, 0x8d, 0x62, 0x13, 0xb1, 0x3f, 0x0a,
	0x4d, 0x3b, 0x62, 0x38, 0x16, 0x96, 0x17, 0xa7, 0x0a, 0xe1, 0xf1, 0xc3, 0xc3, 0xa3, 0xdd, 0x0c,
	0x6e, 0x5c, 0xcd, 0xb7, 0x7b, 0xec, 0x8f, 0x42, 0xa5, 0x58, 0x7b, 0x0f, 0xd6, 0x8a, 0x4d, 0x63,
	0xf6, 0x2c, 0xb1, 0x22, 0x68, 0xf9, 0xca, 0x98, 0x1a, 0xab, 0xa2, 0x33, 0xe8, 0x11, 0x57, 0x3b,
	0xd3, 0xa6, 0xce, 0x3c, 0x8e, 0x59, 0x74, 0x4e, 0x67, 0x0a, 0xc5, 0xda, 0xe7, 0x70, 0xb9, 0xd8,
	0xf4, 0x84, 0xf9, 0x4e, 0x10, 0x89, 0x21, 0x13, 0x1e, 0x8d, 0x5e, 0xbe, 0x8d, 0x27, 0x88, 0x80,
	0xe3, 0x57, 0x55, 0xdd, 0xb7, 0x89, 0xda, 0x0e, 0x45, 0x0a, 0x14, 0xab, 0xfb, 0xb6, 0x20, 0xb5,
	0xa3, 0xfd, 0x08, 0xae, 0x14, 0xab, 0x87, 0x51, 0xe0, 0x8c, 0xed, 0x44, 0xbc, 0x5e, 0x38, 0xec,
	0xb6, 0xf2, 0xf5, 0x8f, 0x04, 0x06, 0xf1, 0x4f, 0x89, 0x96, 0x9e, 0xe7, 0x48, 0x0f, 0x48, 0x81,
	0x96, 0x0f, 0x3c, 0x27, 0xac, 0xea, 0xb1, 0x17, 0x04, 0xe1, 0xc0, 0x12, 0xde, 0xa8, 0x95, 0xaa,
	0x0f, 0x7e, 0x40, 0x08, 0x07, 0xa1, 0xf6, 0x31, 0x6c, 0x15, 0xab, 0xbb, 0x23, 0x6b, 0xc8, 0xcc,
	0x71, 0xe4, 0x62, 0xc8, 0x40, 0xd3, 0xd8, 0xc8, 0x57, 0x3e, 0xe0, 0xc5, 0x8f, 0x23, 0x57, 0xfb,
	0x04, 0x96, 0x12, 0xe6, 0xb1, 0x11, 0x4b, 0xa2, 0x33, 0xd3, 0xf5, 0x4f, 0x02, 0x0a, 0x06, 0x58,
	0xed, 0x3f, 0x92, 0xe0, 0xe3, 0xc4, 0x4a, 0xd8, 0x81, 0x7f, 0x12, 0x18, 0x9d, 0x14, 0x95, 0x3f,
	0x56, 0x7d, 0x27, 0x67, 0x47, 0x8c, 0x08, 0x28, 0x7d, 0x27, 0x67, 0xb8, 0x2a, 0xd2, 0x3a, 0x56,
	0x62, 0x85, 0x9e, 0xe5, 0xa3, 0x53, 0x69, 0xbd, 0x8a, 0xb4, 0x7b, 0x12, 0xe3, 0x20, 0xd4, 0x7e,
	0x15, 0x6e, 0x15, 0x1b, 0xf8, 0xe9, 0xd8, 0x0f, 0xe2, 0xec, 0x54, 0x40, 0x10, 0x25, 0x31, 0xe5,
	0xf8, 0xd7, 0xfa, 0x3f, 0xe6, 0x65, 0x32, 0xe4, 0x85, 0x97, 0x18, 0xd7, 0xf3, 0x6d, 0x97, 0x10,
	0xf4, 0xbf, 0x59, 0x83, 0x6e, 0x31, 0x65, 0xf3, 0x4c, 0x98, 0x15, 0xf5, 0xf8, 0xbf, 0x5e, 0x83,
	0x66, 0x9a, 0x9d, 0x7a, 0x46, 0x9e, 0x22, 0x79, 0xfe, 0x72, 0x1d, 0x16, 0x29, 0x25, 0xf7, 0x8c,
	0x38, 0x15, 0x09, 0x46, 0x84, 0x31, 0x84, 0x32, 0x5f, 0xcb, 0x04, 0x23, 0x08, 0xa4, 0xf4, 0xd8,
	0xa5, 0xf8, 0x33, 0x28, 0xc7, 0x9f, 0xdd, 0x80, 0x8b, 0xdf, 0x8d, 0x83, 0xc4, 0xa2, 0x73, 0x10,
	0xd0, 0xff, 0x86, 0x3f, 0xe1, 0x47, 0x8a, 0x02, 0x3c, 0xc2, 0x5b, 0xce, 0x73, 0x3e, 0x1b, 0x91,
	0xd2, 0x11, 0xde, 0x79, 0x68, 0xce, 0xe2, 0x5d, 0xa7, 0x32, 0xec, 0x6b, 0xb0, 0x9c, 0x65, 0xc0,
	0x57, 0xaf, 0xb3, 0xea, 0xa4, 0x89, 0xef, 0xf1, 0x13, 0xf7, 0xa0, 0x2b, 0xc3, 0x92, 0x0b, 0x29,
	0x26, 0x2f, 0xf5, 0xbf, 0x09, 0xe2, 0x03, 0xa7, 0x10, 0x62, 0x2e, 0xba, 0xb3, 0x34, 0x12, 0xb1,
	0xca, 0xb4, 0xfd, 0xd3, 0x1e, 0xc2, 0x7a, 0x2e, 0x42, 0x3a, 0x6d, 0xaa, 0xf5, 0xc2, 0xa6, 0x56,
	0x27, 0x4a, 0xd8, 0xb4, 0x6c, 0xef, 0x73, 0xb8, 0xec, 0xb0, 0x13, 0x6b, 0xec, 0x25, 0xe6, 0xf4,
	0x50, 0xe8, 0x1e, 0xa1, 0xdc, 0x2f, 0x46, 0x44, 0x6b, 0x9f, 0x43, 0xdb, 0x89, 0xed, 0xec, 0x83,
	0x3a, 0x2f, 0xec, 0x45, 0x8b, 0xe3, 0xcb, 0xcd, 0xec, 0x6f, 0xd4, 0xa1, 0x21, 0xf3, 0xff, 0xcf,
	0x38, 0xab, 0xc8, 0x59, 0xef, 0xc1, 0x5a, 0x7a, 0x5d, 0x42, 0x71, 0xc3, 0x55, 0x37, 0x34, 0x79,
	0x59, 0x82, 0x62, 0x0f, 0xbe, 0x05, 0x9d, 0x91, 0xf5, 0xdc, 0x1c, 0x58, 0xbe, 0xf3, 0xcc, 0x75,
	0x92, 0x53, 0x8a, 0x9f, 0x6f, 0x8f, 0xac, 0xe7, 0x77, 0x25, 0x0c, 0x91, 0x5c, 0x5f, 0x41, 0x6a,
	0x11, 0x92, 0xeb, 0xa7, 0x48, 0x78, 0x0c, 0x32, 0x7f, 0xd3, 0xc2, 0x6c, 0x7c, 0x8a, 0x82, 0xf1,
	0x6f, 0xd7, 0x00, 0x66, 0xd1, 0x45, 0xe7, 0xd9, 0x61, 0x16, 0xce, 0x8f, 0x23, 0xa2, 0x62, 0xcc,
	0x1c, 0xaa, 0xf8, 0x21, 0x66, 0x94, 0x2c, 0x72, 0xda, 0xef, 0xd6, 0x60, 0xb9, 0x70, 0xaf, 0xc8,
	0x8c, 0x48, 0x45, 0x22, 0xfd, 0x76, 0x0d, 0x3a, 0xb9, 0xfb, 0x53, 0x66, 0x24, 0x2a, 0x92, 0xe8,
	0x0f, 0xeb, 0xd0, 0xc9, 0xdd, 0x14, 0x33, 0x23, 0x51, 0x85, 0xa5, 0x3e, 0x7f, 0xc5, 0xce, 0xcb,
	0x58, 0xea, 0x73, 0x97, 0xed, 0x48, 0xd5, 0xea, 0x47, 0x39, 0xe7, 0x6c, 0xa1, 0xd1, 0x34, 0xf7,
	0x96, 0xe2, 0x8a, 0xcd, 0x8d, 0xcc, 0x81, 0xa3, 0xbd, 0x09, 0x2b, 0xe5, 0x5a, 0x62, 0xb1, 0x5e,
	0x8e, 0xf3, 0xb8, 0xfa, 0xcf, 0xea, 0xb0, 0x5e, 0x79, 0x83, 0xcf, 0x6c, 0x84, 0x8b, 0x23, 0xcc,
	0xe0, 0xea, 0x94, 0xbb, 0x90, 0x72, 0x89, 0xb3, 0xf5, 0xea, 0x1b, 0x91, 0x8c, 0xb1, 0xc7, 0xd2,
	0x33, 0x30, 0x97, 0xe2, 0x69, 0x28, 0x38, 0xfc, 0x53, 0x5f, 0x63, 0x25, 0x4c, 0x0e, 0x7f, 0x75,
	0x0b, 0x56, 0xc2, 0xf4, 0x5f, 0x9f, 0x87, 0x6e, 0xf1, 0x0a, 0xa4, 0xd9, 0x68, 0x96, 0xc3, 0x02,
	0xf5, 0xf2, 0x2d, 0x52, 0x25, 0x53, 0x73, 0x73, 0x8a, 0xa9, 0xf9, 0x7a, 0xf1, 0x32, 0xa9, 0xa2,
	0xb1, 0x19, 0x47, 0xb1, 0xd8, 0xbc, 0x12, 0x91, 0x2f, 0x42, 0x5f, 0xb6, 0x8a, 0xcd, 0x64, 0x91,
	0xf9, 0x47, 0x55, 0x0d, 0x28, 0xe1, 0x51, 0xad, 0x4a, 0x32, 0x5c, 0x2a, 0x36, 0xa8, 0x44, 0x2a,
	0xfe, 0x5f, 0x75, 0x58, 0xad, 0xb8, 0x1a, 0x6b, 0xc6, 0x1a, 0xe5, 0x60, 0xc5, 0x1b, 0x95, 0x17,
	0x8c, 0x95, 0xa3, 0xd3, 0x8a, 0xaf, 0xba, 0x5a, 0x71, 0xc7, 0x98, 0x12, 0xa1, 0xf6, 0x71, 0x76,
	0xdb, 0x58, 0xd6, 0xf0, 0xa9, 0x25, 0x8e, 0x5d, 0x08, 0x8e, 0xd8, 0x28, 0xb6, 0xb0, 0x6f, 0x1d,
	0x8a, 0x7b, 0x91, 0x7b, 0xe5, 0xaa, 0x4e, 0xe4, 0x4e, 0xd2, 0x30, 0xc4, 0x52, 0xcd, 0x3d, 0x2c,
	0xd5, 0xff, 0x61, 0x0d, 0x36, 0xa7, 0xdc, 0x60, 0x36, 0x1b, 0xfa, 0xe2, 0xd0, 0xdf, 0x84, 0x76,
	0x7a, 0x03, 0x59, 0x66, 0x91, 0x69, 0xc5, 0x59, 0x56, 0x13, 0xed, 0x2a, 0x40, 0x96, 0x2f, 0x88,
	0x46, 0xad, 0x99, 0xa6, 0x06, 0x42, 0x95, 0xbb, 0x70, 0xc3, 0xdb, 0x8c, 0xcc, 0x45, 0x7d, 0xf2,
	0x5f, 0xac, 0x43, 0x5b, 0xbd, 0xca, 0x6e, 0x46, 0xa1, 0x22, 0x23, 0x0e, 0xe1, 0x56, 0xee, 0x06,
	0x40, 0x33, 0xbd, 0xc0, 0x59, 0x82, 0x95, 0xbc, 0xbd, 0x5b, 0xc5, 0xf4, 0x3b, 0x48, 0x54, 0xfc,
	0x92, 0xeb, 0xea, 0x0d, 0x81, 0x05, 0x2c, 0x8c, 0xdb, 0xfb, 0x17, 0xea, 0xa0, 0x95, 0x2f, 0x06,
	0x9c, 0x0d, 0x48, 0x71, 0x40, 0x7e, 0x05, 0xae, 0x57, 0x1e, 0xeb, 0xab, 0x38, 0x47, 0x50, 0x26,
	0xa7, 0x38, 0x47, 0x50, 0x3e, 0xf7, 0xa7, 0xac, 0xce, 0xff, 0x55, 0x3d, 0x95, 0x1b, 0xb3, 0xad,
	0xfa, 0xf4, 0x70, 0xf1, 0xad, 0xd2, 0xa9, 0xc1, 0x81, 0xeb, 0x3b, 0x98, 0xd0, 0xa6, 0x7a, 0x49,
	0xde, 0x2c, 0x9c, 0x25, 0xbc, 0x4b, 0xe8, 0xda, 0x23, 0xb8, 0x5c, 0x6a, 0x4b, 0x19, 0x4c, 0xc8,
	0x5f, 0x26, 0x2a, 0xab, 0x8b, 0x73, 0x6c, 0x85, 0x36, 0x95, 0x61, 0xfc, 0xed, 0x1a, 0xdf, 0x29,
	0xab, 0x97, 0x5a, 0xce, 0x06, 0xb1, 0x20, 0xfc, 0xff, 0x34, 0x5b, 0x21, 0xd3, 0xab, 0x3b, 0x67,
	0x44, 0x2a, 0x70, 0xba, 0xc2, 0x9d, 0xf2, 0x2a, 0xd4, 0xb2, 0xa8, 0x59, 0x2b, 0xde, 0x8a, 0x9a,
	0xe3, 0x4e, 0x09, 0x54, 0xb8, 0xf3, 0x67, 0x35, 0x58, 0x10, 0x21, 0x98, 0x33, 0x8a, 0x97, 0x63,
	0x64, 0xbb, 0x14, 0xb6, 0xea, 0x16, 0xee, 0x17, 0xcb, 0xc5, 0x68, 0x2f, 0x09, 0xa4, 0x03, 0x79,
	0xaf, 0xd8, 0xff, 0x56, 0x83, 0xfa, 0x23, 0x6b, 0xe6, 0xdf, 0x2c, 0xd1, 0x53, 0x87, 0x8e, 0x4c,
	0xe8, 0x27, 0xde, 0x4c, 0xba, 0x34, 0xdd, 0xa4, 0x8b, 0x6f, 0x5e, 0x87, 0x05, 0x8e, 0x43, 0x46,
	0xad, 0xa6, 0x71, 0x31, 0xb1, 0x86, 0x07, 0x8e, 0x76, 0x19, 0x9a, 0x1c, 0x3c, 0xe1, 0x6f, 0xa7,
	0xdd, 0x4d, 0x23, 0xb1, 0x86, 0xd8, 0x1b, 0xfd, 0x3f, 0xad, 0xc1, 0x22, 0x65, 0xfc, 0x9b, 0x11,
	0xbd, 0x48, 0xf4, 0x6b, 0xd0, 0x4a, 0x89, 0xee, 0x3a, 0x44, 0xf2, 0x26, 0x91, 0xfc, 0xc0, 0xd1,
	0xff, 0xe3, 0x1a, 0xcc, 0x3f, 0x8e, 0x67, 0x81, 0x94, 0x65, 0xca, 0x5d, 0x82, 0x46, 0x68, 0xc5,
	0xf1, 0xb3, 0x20, 0x92, 0x64, 0x4b, 0x9f, 0xf5, 0xff, 0xb3, 0x06, 0xdd, 0xe2, 0xed, 0xcd, 0x33,
	0x0a, 0x16, 0x29, 0xf8, 0x00, 0x36, 0xcb, 0xb7, 0x5f, 0x63, 0x24, 0x5e, 0x7a, 0xbc, 0x53, 0x12,
	0xd1, 0x8f, 0x05, 0x11, 0x85, 0x15, 0xbc, 0x78, 0x09, 0xf6, 0x9e, 0x95, 0x58, 0xfa, 0x1f, 0xd5,
	0x00, 0x32, 0x9a, 0xcf, 0xa8, 0x5d, 0xbe, 0x73, 0xad, 0xab, 0x52, 0x5b, 0x21, 0xf3, 0xb2, 0x42,
	0x66, 0xb1, 0x64, 0x65, 0x04, 0x46, 0xd2, 0xfe, 0xfd, 0x1a, 0x34, 0xd3, 0x1b, 0xc2, 0x67, 0x94,
	0x2d, 0x52, 0xf6, 0x2e, 0xac, 0x67, 0xc9, 0x2d, 0xab, 0x6c, 0x7e, 0x69, 0x72, 0x4b, 0xec, 0xf0,
	0x6a, 0x7a, 0xbf, 0xba, 0xa2, 0x68, 0xfd, 0x83, 0x16, 0x6c, 0x4e, 0xb9, 0x48, 0x7d, 0x46, 0xf0,
	0x7f, 0x76, 0x89, 0xa6, 0x2c, 0x78, 0x75, 0xea, 0x85, 0xf7, 0xe6, 0x69, 0x10, 0x27, 0x32, 0x61,
	0x09, 0x54, 0x07, 0x1a, 0xdc, 0x9c, 0x72, 0xe3, 0xfd, 0x7e, 0x10, 0x8b, 0x3b, 0x88, 0x62, 0x6d,
	0x08, 0xaf, 0x4f, 0x7f, 0x05, 0xe6, 0x89, 0x13, 0x06, 0xfd, 0xd4, 0x64, 0xbf, 0xd2, 0x3f, 0xb4,
	0xec, 0x1d, 0x09, 0x14, 0xe9, 0x37, 0xa6, 0xbc, 0x46, 0x45, 0xd4, 0x02, 0x78, 0x73, 0xfa, 0x8b,
	0x9c, 0x53, 0x3b, 0x34, 0x83, 0x30, 0xcb, 0xe2, 0x2c, 0xf3, 0x32, 0xef, 0x9d, 0xda, 0xe1, 0xd7,
	0x08, 0x8f, 0x53, 0xef, 0xd3, 0xab, 0x53, 0x5e, 0x97, 0xe1, 0x62, 0x5e, 0xad, 0x9f, 0x80, 0x3e,
	0xfd, 0x85, 0xe9, 0xae, 0xbb, 0x53, 0xc9, 0x03, 0xd7, 0xa7, 0xbc, 0x22, 0xdd, 0x7d, 0x3f, 0x81,
	0xdb, 0xe7, 0x7c, 0x8d, 0x1b, 0x63, 0x36, 0x19, 0x71, 0xe4, 0x89, 0x42, 0xeb, 0x5f, 0x99, 0xd6,
	0x6b, 0x81, 0x4c, 0xae, 0xfb, 0x33, 0x78, 0x77, 0x7a, 0xbb, 0x96, 0xe7, 0x05, 0xcf, 0x98, 0x93,
	0x66, 0xd1, 0x0d, 0x79, 0x5f, 0x29, 0x4f, 0xf4, 0x5a, 0x7f, 0x47, 0x94, 0x12, 0xc5, 0xc5, 0x77,
	0xbc, 0x39, 0xe5, 0xa5, 0x15, 0xb8, 0x5a, 0x08, 0x6f, 0x4f, 0x7f, 0xf5, 0x89, 0x95, 0x98, 0x98,
	0x7c, 0x2c, 0x8c, 0x82, 0x24, 0xb0, 0x03, 0x2f, 0xc6, 0xc0, 0x7d, 0xce, 0x0e, 0xf7, 0xad, 0xe4,
	0xbe, 0x17, 0x3c, 0x3b, 0x92, 0x05, 0xc6, 0xeb, 0x53, 0x5e, 0x5a, 0x44, 0xd4, 0xbe, 0x80, 0x2b,
	0xf2, 0x10, 0xb6, 0x39, 0xb0, 0x62, 0xe6, 0x98, 0x03, 0xbc, 0xe3, 0xca, 0x14, 0x77, 0x2d, 0x50,
	0xaa, 0xa3, 0xde, 0x44, 0x1c, 0xc4, 0xbe, 0xcb, 0x31, 0x72, 0x97, 0x60, 0x19, 0xf0, 0xda, 0x39,
	0x83, 0x80, 0x47, 0x4e, 0xcd, 0xe0, 0x99, 0xcf, 0x22, 0x0a, 0xf7, 0xd7, 0xa7, 0x0d, 0x01, 0xa2,
	0x7e, 0xcd, 0x31, 0xb5, 0xcf, 0xa1, 0x3b, 0x89, 0x4e, 0x4c, 0x0b, 0x6f, 0x26, 0x10, 0x59, 0x81,
	0xd2, 0xe0, 0xff, 0x27, 0xd1, 0x89, 0xb8, 0xb1, 0x20, 0x9b, 0x61, 0x4b, 0x93, 0x1c, 0x4c, 0xdb,
	0x86, 0x75, 0x4c, 0xce, 0x96, 0xba, 0x40, 0xe5, 0x6d, 0x52, 0x22, 0xfc, 0x7f, 0x95, 0x17, 0x4a,
	0xff, 0xaa, 0xbc, 0x4e, 0xea, 0x19, 0xbc, 0x32, 0xfd, 0x33, 0x14, 0xf9, 0x2d, 0xd2, 0x04, 0xbe,
	0xd6, 0x9f, 0x22, 0x98, 0x33, 0xf1, 0x7d, 0xee, 0xdc, 0x57, 0xa4, 0xfc, 0xef, 0xd4, 0x60, 0x29,
	0xdf, 0xd8, 0x4c, 0xb8, 0x17, 0xad, 0x3d, 0x7f, 0xdc, 0x4a, 0x69, 0x44, 0x67, 0x3d, 0x67, 0x34,
	0x2a, 0x2e, 0x80, 0xdf, 0xc0, 0x25, 0xc9, 0xc0, 0xe9, 0x69, 0xcf, 0xa2, 0xda, 0xb1, 0xda, 0xcf,
	0x53, 0x51, 0xdc, 0x29, 0x3f, 0xc9, 0xc1, 0x14, 0x57, 0xe3, 0x0b, 0xd6, 0x54, 0xf8, 0xa7, 0x5f,
	0x53, 0x3f, 0x2d, 0x77, 0x36, 0xcb, 0x3f, 0x40, 0x61, 0x26, 0x9b, 0xf9, 0x7e, 0xa5, 0x09, 0x08,
	0xb4, 0x0f, 0x61, 0x53, 0x0a, 0x5f, 0x2e, 0x8c, 0xc5, 0x05, 0xaa, 0x6a, 0xda, 0xb9, 0x75, 0x2a,
	0xde, 0x49, 0x4b, 0xd1, 0xfd, 0xf9, 0x1a, 0x2c, 0x87, 0x83, 0x81, 0xc9, 0x26, 0xa1, 0x9f, 0x4f,
	0x02, 0xde, 0x09, 0x07, 0x83, 0x7b, 0x93, 0xd0, 0xa7, 0xe8, 0xfd, 0xd7, 0x61, 0x99, 0x0e, 0xf0,
	0xb0, 0xe7, 0x09, 0x8b, 0x7c, 0xcb, 0xa3, 0xd5, 0x63, 0x49, 0x80, 0xef, 0x11, 0xf4, 0xdc, 0x7b,
	0x0c, 0x97, 0xbf, 0xdf, 0x3d, 0x86, 0xe5, 0x7c, 0xb0, 0xdd, 0x8a, 0x7c, 0xb0, 0x3b, 0xb0, 0xaa,
	0xde, 0x2d, 0x22, 0x07, 0x77, 0x85, 0xde, 0x25, 0x0f, 0x14, 0xec, 0xb1, 0xc4, 0x72, 0xbd, 0xd8,
	0xd0, 0xc2, 0xec, 0x8e, 0x11, 0x39, 0xa6, 0x95, 0x37, 0x37, 0x6a, 0x2f, 0x7b, 0x73, 0xe3, 0xb4,
	0x6b, 0xfa, 0x56, 0xa7, 0x5e, 0xd3, 0x77, 0xde, 0x05, 0x8d, 0x6b, 0xdf, 0xef, 0x82, 0xc6, 0x6d,
	0x58, 0x3f, 0xf1, 0x82, 0xc0, 0x31, 0xc7, 0xfe, 0x53, 0x3f, 0x78, 0xe6, 0x9b, 0x63, 0xdf, 0xb5,
	0xad, 0x38, 0x41, 0x99, 0xdc, 0x30, 0x56, 0xb1, 0xf0, 0xb1, 0x28, 0x7b, 0x2c, 0x8a, 0xb4, 0xdb,
	0xd0, 0xc5, 0x31, 0x4f, 0x22, 0xc6, 0xe4, 0xa0, 0x6f, 0x88, 0xc1, 0xe4, 0x83, 0xce, 0xc1, 0x34,
	0xea, 0x7d, 0x58, 0xf5, 0xac, 0x33, 0x16, 0x6d, 0xcb, 0x8c, 0xb0, 0x26, 0x6e, 0xe3, 0x37, 0x45,
	0x6e, 0x40, 0x51, 0x44, 0xe9, 0x5f, 0xbf, 0xe5, 0x5b, 0xf7, 0x5b, 0xd0, 0x91, 0xec, 0x81, 0xe7,
	0xe1, 0x7b, 0x3d, 0x71, 0x56, 0x44, 0x02, 0x31, 0x89, 0xc0, 0xd4, 0x95, 0x68, 0x6b, 0xfa, 0x4a,
	0x54, 0x95, 0xbc, 0xf8, 0xd2, 0xf7, 0x4c, 0x5e, 0xfc, 0x00, 0x6e, 0x8d, 0xc6, 0x5e, 0xe2, 0xca,
	0x03, 0xdf, 0xd2, 0x0c, 0x6c, 0x9f, 0x5a, 0xae, 0x1f, 0xa7, 0xbd, 0xb8, 0x8c, 0xbd, 0xb8, 0x8e,
	0xa8, 0xf2, 0x16, 0x67, 0xe1, 0xe4, 0x47, 0x3c, 0xd9, 0xa3, 0xca, 0x7c, 0xb9, 0x57, 0xbe, 0x47,
	0xbe, 0x5c, 0xed, 0x32, 0x34, 0xdd, 0xf4, 0xd6, 0xde, 0xab, 0xf8, 0xd6, 0x86, 0x4b, 0x37, 0xf6,
	0xea, 0xff, 0x6d, 0x1d, 0x3a, 0x24, 0x97, 0x66, 0x27, 0x74, 0xab, 0x85, 0xfb, 0xe7, 0x70, 0x59,
	0xca, 0x4b, 0x79, 0x38, 0x31, 0x74, 0x9e, 0xa6, 0xe3, 0xd8, 0x24, 0x1d, 0x4d, 0x25, 0xe2, 0x5e,
	0xe8, 0x3c, 0x95, 0x03, 0xd8, 0x87, 0xd5, 0x42, 0x75, 0x25, 0x75, 0xce, 0x4a, 0xae, 0x1a, 0x52,
	0xea, 0x63, 0xd8, 0x2a, 0xe0, 0x97, 0xf2, 0x80, 0x6e, 0xe4, 0x6a, 0x65, 0x17, 0xc3, 0xfd, 0xde,
	0x3c, 0xac, 0xec, 0x84, 0xe1, 0x49, 0x10, 0x8d, 0xdc, 0xe7, 0x0f, 0x03, 0x87, 0xe1, 0x89, 0xdc,
	0x37, 0xa0, 0x8b, 0xb2, 0x28, 0x76, 0x03, 0x94, 0x1b, 0x5e, 0x30, 0xa4, 0xc1, 0x5d, 0x56, 0xe1,
	0x0f, 0x82, 0xa1, 0x76, 0x07, 0xd6, 0x73, 0xa8, 0x61, 0x14, 0x0c, 0xf1, 0xbd, 0x35, 0x14, 0x88,
	0x6b, 0x6a, 0xe1, 0x11, 0x95, 0x69, 0x5f, 0xc0, 0xe5, 0xca, 0x4a, 0x66, 0x9c, 0x58, 0x43, 0xc9,
	0x0b, 0x5b, 0x55, 0x55, 0x8f, 0x39, 0x02, 0x5f, 0x52, 0x72, 0xf5, 0x45, 0x76, 0x6b, 0x94, 0xc3,
	0xf3, 0x62, 0x49, 0x51, 0x8b, 0x8f, 0x79, 0x29, 0x0a, 0xe4, 0x77, 0x40, 0x2b, 0xd6, 0x4b, 0x18,
	0xf2, 0x50, 0xd3, 0x58, 0x29, 0x54, 0x51, 0x3c, 0x54, 0x0b, 0xd3, 0xf9, 0x7a, 0xf1, 0x45, 0x7c,
	0xdd, 0x38, 0x8f, 0xaf, 0x9b, 0x53, 0xf9, 0x1a, 0xbe, 0x0f, 0x5f, 0xb7, 0x5e, 0xc8, 0xd7, 0xed,
	0xef, 0xc3, 0xd7, 0x9d, 0xe9, 0x8a, 0xdd, 0x3c, 0x74, 0xee, 0x5a, 0x11, 0x1b, 0xb1, 0xc4, 0xf2,
	0x66, 0x57, 0x34, 0x56, 0x4d, 0x7d, 0x0d, 0xe6, 0x15, 0xcf, 0x07, 0xfe, 0xe7, 0x9d, 0x71, 0xc3,
	0x91, 0x5b, 0x08, 0x04, 0x6c, 0x71, 0x98, 0x0c, 0xfd, 0xbb, 0x05, 0x1d, 0x44, 0x19, 0xc7, 0x7c,
	0x35, 0x4a, 0xc7, 0x14, 0xeb, 0x3d, 0x26, 0x58, 0x8a, 0x94, 0x1a, 0xad, 0xdb, 0x19, 0xd2, 0x11,
	0xc1, 0xb8, 0xec, 0xb6, 0xc3, 0xb1, 0x69, 0x07, 0x63, 0x3f, 0xc1, 0xa1, 0xac, 0x1b, 0x0d, 0x3b,
	0x1c, 0xef, 0xf2, 0x67, 0x6d, 0x0b, 0xf8, 0x7f, 0xd3, 0x8a, 0xec, 0x53, 0x4a, 0xd3, 0xbb, 0x68,
	0x87, 0xe3, 0x9d, 0xc8, 0x3e, 0xe5, 0x34, 0x77, 0xdc, 0xf8, 0xa9, 0x39, 0x1c, 0x50, 0x6e, 0xfb,
	0x05, 0xfe, 0xf8, 0xe5, 0x80, 0x37, 0x38, 0x62, 0xa3, 0x20, 0x3a, 0x33, 0x47, 0x03, 0x52, 0x73,
	0x1a, 0x02, 0x70, 0x38, 0xe0, 0x5d, 0x72, 0x58, 0xe8, 0x05, 0x67, 0xe6, 0x53, 0x16, 0xf9, 0xcc,
	0xa3, 0x13, 0xe6, 0x6d, 0x01, 0xfc, 0x0a, 0x61, 0xda, 0xab, 0xb0, 0x44, 0x48, 0x91, 0x35, 0xe2,
	0xad, 0xd2, 0xde, 0x92, 0xaa, 0x1a, 0x02, 0xa8, 0xff, 0xdd, 0xba, 0xc2, 0x5d, 0x47, 0x41, 0x34,
	0x73, 0x58, 0x96, 0xb8, 0xeb, 0x3a, 0xb4, 0x14, 0xfb, 0x12, 0x31, 0x19, 0x8c, 0x52, 0x9b, 0x11,
	0xb2, 0x5f, 0x16, 0x59, 0x88, 0xff, 0xf9, 0x00, 0xc6, 0xcf, 0xdc, 0xc4, 0x3e, 0x95, 0xca, 0x7a,
	0xd3, 0x68, 0x08, 0xc0, 0x81, 0xc3, 0x89, 0x81, 0x2a, 0x8f, 0x2b, 0xb9, 0x69, 0x81, 0x3f, 0x1e,
	0x20, 0x19, 0x65, 0x2d, 0xff, 0x24, 0x48, 0x93, 0x3f, 0x8b, 0x7a, 0xfe, 0x49, 0x80, 0x74, 0x7e,
	0xce, 0xd2, 0x45, 0x4d, 0xe8, 0xdc, 0x10, 0x3e, 0x27, 0x0d, 0xcd, 0xd1, 0xff, 0xb3, 0x79, 0xb8,
	0x89, 0x1a, 0x85, 0xe5, 0x7a, 0x3b, 0xbe, 0xe5, 0x9d, 0x25, 0xae, 0x1d, 0xab, 0x17, 0xbc, 0xce,
	0xd6, 0x9a, 0xd9, 0x5a, 0x33, 0x75, 0xad, 0xf9, 0x8f, 0xe6, 0x61, 0xbd, 0xc4, 0x3d, 0xb8, 0xe6,
	0xcc, 0x38, 0x66, 0xc6, 0x31, 0x55, 0x1c, 0xf3, 0xaf, 0x5f, 0x84, 0x65, 0xc9, 0x31, 0xbb, 0xde,
	0x38, 0x9e, 0x6d, 0x4d, 0x2a, 0x56, 0x90, 0xdb, 0xd0, 0xa5, 0xe3, 0xe7, 0xd6, 0xd8, 0x71, 0x13,
	0x33, 0x49, 0x3c, 0x99, 0xf1, 0x4a, 0xc0, 0x77, 0x38, 0xf8, 0x51, 0xe2, 0xd1, 0x4d, 0x41, 0x48,
	0x4d, 0xf3, 0x19, 0x1b, 0x8c, 0x5d, 0x5a, 0x54, 0x3a, 0x12, 0xfa, 0x2d, 0x07, 0x72, 0x95, 0xc2,
	0xb1, 0x12, 0x0b, 0x1b, 0x12, 0x43, 0xbd, 0xc8, 0x9f, 0x79, 0x0b, 0xaf, 0xc3, 0xb2, 0x3c, 0x30,
	0x3e, 0xb4, 0x12, 0xf6, 0xcc, 0x3a, 0x93, 0x17, 0x0d, 0x10, 0xf8, 0x4b, 0x01, 0xd5, 0x76, 0xe1,
	0x9a, 0x44, 0x9c, 0xd0, 0x0e, 0x66, 0x10, 0xf8, 0x4e, 0x66, 0xd2, 0xa5, 0xe5, 0x47, 0x9e, 0x3f,
	0xa7, 0x5b, 0x5c, 0xee, 0x06, 0xbe, 0x93, 0xf9, 0xd8, 0x0c, 0x78, 0xed, 0xfc, 0x46, 0x28, 0x0d,
	0xb4, 0xbc, 0x07, 0x4e, 0x3f, 0xa7, 0x31, 0x91, 0xf2, 0x39, 0xe6, 0x1f, 0x87, 0x16, 0x7c, 0xfe,
	0x71, 0x22, 0x5b, 0xcf, 0x22, 0x7f, 0x26, 0xf2, 0x64, 0xd7, 0xf4, 0x20, 0x42, 0x57, 0x90, 0x27,
	0x83, 0x3e, 0x4a, 0x3c, 0xfd, 0x6f, 0xcd, 0xc3, 0xa5, 0x94, 0x29, 0xc5, 0xf6, 0xda, 0x63, 0xd1,
	0x6c, 0xf5, 0x9b, 0xc9, 0xb2, 0x73, 0x65, 0xd9, 0xef, 0x2d, 0x80, 0x36, 0x63, 0x97, 0x19, 0xbb,
	0xbc, 0x1c, 0xbb, 0x70, 0x49, 0x6b, 0x5b, 0xa1, 0x65, 0xbb, 0xc9, 0x99, 0x38, 0x21, 0x24, 0x85,
	0xdc, 0x92, 0x04, 0xe3, 0xc9, 0xa0, 0x58, 0xfb, 0x0a, 0x74, 0x94, 0x87, 0xbe, 0xe5, 0x59, 0xa1,
	0x3b, 0x4d, 0x40, 0x0a, 0x51, 0x77, 0x5d, 0xc1, 0xac, 0x94, 0x8e, 0x7c, 0xd4, 0x58, 0x74, 0x12,
	0x44, 0xa3, 0xec, 0x68, 0x52, 0x4c, 0x62, 0x70, 0x45, 0x29, 0xa1, 0x77, 0xff, 0x3c, 0xbc, 0x11,
	0x27, 0x41, 0x64, 0x0d, 0x99, 0x9a, 0xaf, 0x6e, 0x4a, 0x17, 0xc4, 0x3e, 0xf2, 0x55, 0xaa, 0x90,
	0x65, 0xd0, 0xaa, 0xea, 0x88, 0xfe, 0x5f, 0xd7, 0xa0, 0xb9, 0x67, 0xc5, 0xa7, 0x83, 0xc0, 0x9a,
	0x45, 0x69, 0x95, 0xb9, 0xe3, 0x0d, 0x5c, 0xf3, 0x13, 0xcb, 0xf5, 0x59, 0x44, 0xc9, 0x67, 0x68,
	0xcd, 0x5f, 0x4e, 0xe1, 0x22, 0xfb, 0x8c, 0xfe, 0x77, 0x6b, 0xb0, 0xf8, 0x15, 0x3b, 0x0b, 0x2d,
	0x77, 0xa6, 0x3b, 0xbd, 0x94, 0x6d, 0xe7, 0x2a, 0x40, 0x38, 0x1e, 0x78, 0xae, 0x6d, 0x3e, 0x65,
	0x67, 0xf2, 0x68, 0x98, 0x80, 0x7c, 0xc5, 0xce, 0xf4, 0xbf, 0x5a, 0x87, 0x95, 0xaf, 0xc6, 0x03,
	0xcc, 0x76, 0xc9, 0xe2, 0x99, 0x56, 0x3a, 0x85, 0xb2, 0x7d, 0x58, 0x4d, 0x75, 0x4d, 0x5b, 0x10,
	0x29, 0x8b, 0x65, 0x5d, 0xb1, 0xf3, 0x4a, 0xfd, 0x81, 0xc3, 0x17, 0xb7, 0xa7, 0x9c, 0xaa, 0x63,
	0x24, 0xab, 0xe9, 0xc8, 0xb9, 0x2f, 0xd3, 0xcb, 0x2b, 0x85, 0xa9, 0x5c, 0xd0, 0xff, 0xbd, 0x79,
	0x58, 0xca, 0xc6, 0x62, 0xb6, 0x95, 0x9c, 0xad, 0xa7, 0x53, 0xd5, 0xaf, 0x7f, 0xbf, 0x0d, 0x8d,
	0x07, 0xe4, 0x8c, 0x9e, 0x31, 0xc9, 0x8c, 0x49, 0xa6, 0x2d, 0x07, 0xf8, 0x51, 0x42, 0xd3, 0xc2,
	0xff, 0x5c, 0x90, 0x85, 0x91, 0x3b, 0xb1, 0x12, 0x66, 0x3a, 0xbe, 0x48, 0x26, 0x9a, 0x29, 0x54,
	0x2b, 0x54, 0xb4, 0xe7, 0x63, 0xa6, 0x50, 0xae, 0x42, 0xbd, 0x09, 0x12, 0x68, 0xfa, 0x49, 0x88,
	0xf1, 0x89, 0x52, 0x83, 0x5a, 0xa6, 0x82, 0x87, 0x49, 0xb8, 0xcf, 0xc1, 0xda, 0x0f, 0xa1, 0x27,
	0x71, 0x83, 0x38, 0x74, 0xcc, 0xd0, 0xb2, 0x9f, 0x8a, 0xdc, 0xac, 0xd2, 0xec, 0xbe, 0x4e, 0xe5,
	0x5f, 0xc7, 0xa1, 0x73, 0x24, 0x4a, 0x1f, 0x47, 0x9e, 0x76, 0x07, 0x36, 0x72, 0x15, 0x31, 0xe5,
	0x01, 0xd2, 0x4a, 0xd8, 0xe1, 0x57, 0x95, 0x6a, 0x8f, 0x63, 0x26, 0x72, 0xdf, 0x7e, 0x0a, 0x97,
	0xca, 0x95, 0x52, 0xcf, 0xc3, 0xaa, 0xb8, 0x85, 0xbe, 0x50, 0x31, 0x75, 0x42, 0x7c, 0x00, 0x9b,
	0xb9, 0xca, 0x93, 0x91, 0x29, 0x9d, 0x0b, 0x6b, 0xa5, 0x57, 0x3e, 0x19, 0xed, 0x09, 0x4f, 0xc3,
	0xbb, 0xb0, 0x56, 0xac, 0x85, 0xbd, 0x5c, 0xcf, 0x51, 0x4f, 0x54, 0xc1, 0x3e, 0x6e, 0x17, 0x3e,
	0x6c, 0x32, 0x32, 0x23, 0x6b, 0x64, 0x8e, 0x06, 0x18, 0x34, 0xd0, 0x34, 0xb4, 0x5c, 0x15, 0xc3,
	0x1a, 0x1d, 0x0e, 0xb4, 0xf7, 0x61, 0xbd, 0x58, 0x67, 0x62, 0x87, 0xe3, 0x18, 0x43, 0x07, 0x8a,
	0x55, 0x9e, 0xf0, 0x12, 0x95, 0x7e, 0x11, 0x73, 0x4e, 0xad, 0x44, 0xdc, 0x09, 0xe4, 0x3a, 0x18,
	0x44, 0x90, 0x7d, 0x8c, 0x81, 0x85, 0x47, 0x41, 0xe0, 0x1d, 0x38, 0xda, 0x3d, 0xb8, 0x5e, 0xa8,
	0x14, 0x8f, 0x07, 0xb1, 0x1d, 0xb9, 0x22, 0x62, 0x93, 0x6b, 0x0b, 0x5b, 0x58, 0xfb, 0x4a, 0xae,
	0xf6, 0xb1, 0x82, 0xf4, 0x15, 0x3b, 0xd3, 0x0e, 0xe1, 0xd6, 0x79, 0xcd, 0x84, 0x96, 0x18, 0x8f,
	0x4b, 0xd8, 0xd4, 0x8d, 0xa9, 0x4d, 0x1d, 0x09, 0x3c, 0xed, 0x4b, 0xb8, 0x71, 0x5e, 0x73, 0x7c,
	0x90, 0x31, 0xcc, 0xa0, 0x69, 0x5c, 0x9d, 0xda, 0x16, 0x1e, 0x26, 0xb9, 0x0d, 0xdd, 0xa1, 0x1d,
	0x9a, 0x96, 0x8d, 0x8e, 0x26, 0xe1, 0x23, 0xb8, 0x22, 0xb6, 0x1c, 0x43, 0x3b, 0xdc, 0x11, 0x60,
	0xf4, 0x13, 0x6c, 0xc2, 0x22, 0x62, 0xc6, 0x3e, 0x86, 0x12, 0xd4, 0x8d, 0x05, 0x8e, 0x10, 0xfb,
	0x5c, 0x75, 0xe2, 0x05, 0x11, 0x1b, 0xba, 0x81, 0xdf, 0xbb, 0x26, 0x54, 0xa7, 0xa1, 0x1d, 0x1a,
	0x08, 0x90, 0xc5, 0xe2, 0xec, 0x55, 0xef, 0x7a, 0x5a, 0x4c, 0x87, 0xd9, 0x5e, 0x81, 0x25, 0xeb,
	0x59, 0xcc, 0x3b, 0xc0, 0x45, 0x25, 0x27, 0xe7, 0x0d, 0xe1, 0x7a, 0xb2, 0x9e, 0xc5, 0x3b, 0x08,
	0xe4, 0xe4, 0xbb, 0x0a, 0xc0, 0xb1, 0xe8, 0x1d, 0x37, 0x45, 0x23, 0xd6, 0xb3, 0x98, 0xde, 0x41,
	0x8d, 0xc4, 0xcc, 0x8e, 0x58, 0x82, 0x8d, 0xe8, 0x69, 0x23, 0xc7, 0x08, 0x54, 0x1a, 0xa1, 0x9e,
	0xdc, 0x4a, 0x1b, 0x11, 0x3d, 0xd1, 0x7f, 0x6f, 0x11, 0xe6, 0x67, 0xce, 0xd0, 0x29, 0x07, 0x6c,
	0xb8, 0x44, 0x53, 0x94, 0xe6, 0xf4, 0x99, 0x13, 0xb5, 0x94, 0x1b, 0xa5, 0xe9, 0xa6, 0xb9, 0x50,
	0x0a, 0x9e, 0xae, 0x56, 0x95, 0xa7, 0x0b, 0x09, 0xd6, 0x56, 0xa4, 0xaf, 0x7a, 0xa0, 0xa7, 0x93,
	0x3f, 0xd0, 0xc3, 0xc9, 0x18, 0xc7, 0xa7, 0x38, 0xc6, 0x42, 0x60, 0x2f, 0xc4, 0xf1, 0x29, 0x1f,
	0xdd, 0x4b, 0xd0, 0x48, 0xbd, 0xae, 0x42, 0x4e, 0xa7, 0xcf, 0xbc, 0x12, 0x32, 0xd9, 0xc8, 0x25,
	0xa1, 0xbc, 0xc0, 0xb9, 0x6b, 0xe4, 0x72, 0xb9, 0xcd, 0x0b, 0xd2, 0x53, 0xc4, 0xd8, 0x15, 0x21,
	0x84, 0x97, 0xad, 0x67, 0xb1, 0x7a, 0x74, 0x58, 0xbb, 0x0c, 0x9c, 0x6d, 0x45, 0x22, 0x6d, 0x92,
	0xb8, 0x8d, 0xa1, 0x1d, 0x62, 0xe6, 0x6c, 0x39, 0x8f, 0x64, 0x10, 0x2b, 0xb6, 0xb3, 0x9a, 0xce,
	0x23, 0x0a, 0x31, 0xc5, 0x66, 0x3e, 0xcb, 0x04, 0xb2, 0xc4, 0x56, 0x82, 0xca, 0xd6, 0x28, 0xb3,
	0xb7, 0xc0, 0xa0, 0x7a, 0x4a, 0x20, 0xd9, 0x76, 0x26, 0xf6, 0x64, 0x6d, 0xb1, 0xde, 0xaf, 0xe7,
	0x44, 0x18, 0x55, 0x14, 0x2b, 0xfe, 0xe7, 0x5c, 0x31, 0x11, 0x75, 0xc2, 0xe0, 0x59, 0x29, 0xcd,
	0xfc, 0x46, 0xee, 0x95, 0x47, 0x1c, 0x23, 0x97, 0x64, 0xfe, 0x00, 0x6e, 0x4e, 0xad, 0x9e, 0x0e,
	0x93, 0x90, 0xba, 0xd7, 0xaa, 0x1b, 0x49, 0xd7, 0x93, 0xf3, 0x9a, 0x4a, 0x07, 0xaf, 0x77, 0x5e,
	0x53, 0xd2, 0x89, 0xae, 0xff, 0x97, 0x00, 0xdd, 0xaf, 0x43, 0xc6, 0x07, 0xc8, 0x7e, 0x2a, 0x37,
	0x64, 0x33, 0x15, 0x6f, 0xa6, 0xe2, 0x55, 0x09, 0xb0, 0x57, 0x61, 0xc9, 0x72, 0x46, 0xae, 0x9f,
	0xf1, 0xab, 0x90, 0x1d, 0x1d, 0x84, 0xa6, 0xec, 0x39, 0x65, 0xfb, 0xba, 0x3c, 0x6d, 0xfb, 0xfa,
	0x21, 0x6c, 0x4a, 0x57, 0x45, 0xd1, 0x6c, 0x27, 0xc4, 0xcc, 0x3a, 0x15, 0xef, 0xe6, 0xad, 0x77,
	0x1f, 0xc0, 0x86, 0xac, 0xf7, 0xd3, 0x60, 0x8c, 0xb1, 0x8c, 0x54, 0x4d, 0x88, 0x9e, 0x35, 0x2a,
	0xfd, 0xb1, 0x28, 0xa4, 0x5a, 0x6f, 0x83, 0x26, 0x6b, 0x05, 0xb1, 0x23, 0x6b, 0x08, 0x41, 0xd4,
	0xa5, 0x92, 0xaf, 0x63, 0x87, 0xb0, 0x3f, 0x83, 0x4b, 0x12, 0xbb, 0xc2, 0xb8, 0x27, 0x44, 0x93,
	0x4c, 0xf2, 0x7b, 0x54, 0xb2, 0xf1, 0x99, 0xf0, 0x8e, 0xac, 0x2d, 0x6d, 0x7d, 0xb4, 0x42, 0x4f,
	0xb1, 0xf3, 0x09, 0xb9, 0x75, 0x9b, 0x2a, 0x1d, 0x8b, 0x3a, 0x62, 0xfd, 0xae, 0xb4, 0x39, 0x5a,
	0xd0, 0x2f, 0xbe, 0x60, 0x60, 0xd9, 0x4f, 0x99, 0xef, 0x4c, 0x7b, 0x83, 0x10, 0x70, 0x6f, 0xe4,
	0xdf, 0x70, 0x57, 0xd4, 0xa9, 0x7c, 0xc5, 0x8f, 0xe0, 0x4a, 0x1a, 0x2a, 0xaa, 0x44, 0x2c, 0xa3,
	0xce, 0xc7, 0x7c, 0x87, 0xe4, 0xde, 0x96, 0xc4, 0xc9, 0xc2, 0x96, 0xb9, 0xe6, 0x77, 0xcf, 0x77,
	0xb4, 0x5d, 0xb8, 0x36, 0xb5, 0x01, 0x9c, 0xb9, 0x24, 0xf5, 0x2e, 0x57, 0x37, 0x81, 0xd3, 0x97,
	0xaf, 0x30, 0x69, 0x23, 0x3e, 0x4b, 0xc4, 0x05, 0x62, 0x42, 0xc4, 0x2d, 0xcb, 0x82, 0x87, 0x2c,
	0xd9, 0x75, 0x9d, 0x48, 0x7b, 0x1d, 0x96, 0x03, 0x29, 0xd2, 0xc8, 0x57, 0x27, 0x74, 0xcb, 0xa5,
	0x14, 0x2c, 0x9c, 0x75, 0xaf, 0xc2, 0x12, 0x59, 0xab, 0xa4, 0x43, 0x4e, 0x28, 0x8e, 0x1d, 0x01,
	0x95, 0xfe, 0xb8, 0xcb, 0x40, 0x26, 0x2c, 0x2e, 0xe6, 0x2f, 0xd3, 0x42, 0x8a, 0x80, 0x83, 0x50,
	0xff, 0xb3, 0x8b, 0xd0, 0xcb, 0x04, 0x68, 0x30, 0x0a, 0xc7, 0xc9, 0x2c, 0x9a, 0x63, 0x26, 0x48,
	0x5f, 0xe8, 0xa0, 0x28, 0xba, 0x82, 0x97, 0x2a, 0x5d, 0xc1, 0x1f, 0xc0, 0xc6, 0x14, 0x17, 0xb0,
	0x90, 0xa6, 0x6b, 0x93, 0x2a, 0xdf, 0xef, 0x2e, 0x5c, 0x7b, 0x81, 0xcf, 0x57, 0xc8, 0xd5, 0xcb,
	0x93, 0x73, 0x9c, 0xbd, 0x37, 0xa1, 0x3d, 0x51, 0xe3, 0x6d, 0x85, 0x4c, 0x6d, 0x11, 0x0c, 0x6f,
	0xa8, 0xfc, 0x1b, 0x0b, 0x0a, 0xef, 0x93, 0x28, 0x99, 0xf1, 0xfe, 0x8c, 0xf7, 0x5f, 0xa4, 0x44,
	0x14, 0x56, 0x6b, 0x52, 0x22, 0x7e, 0x9a, 0x5b, 0xa6, 0xaf, 0x02, 0x28, 0xcb, 0xb3, 0xe0, 0xf6,
	0x66, 0x90, 0xae, 0xcb, 0x47, 0xf0, 0xea, 0xcb, 0xad, 0xa8, 0x82, 0xd3, 0x6f, 0xc6, 0x2f, 0x5c,
	0x4a, 0x0d, 0x78, 0xed, 0x25, 0x97, 0x50, 0x31, 0x13, 0xf4, 0xf8, 0x85, 0x6b, 0xa7, 0xfe, 0x07,
	0xf3, 0xd0, 0x78, 0x72, 0xf4, 0x50, 0x64, 0x78, 0x9b, 0x4d, 0x88, 0xd9, 0x84, 0x78, 0x49, 0xc3,
	0xa9, 0xfe, 0xaf, 0xd6, 0x61, 0xe1, 0x5b, 0xd7, 0x99, 0xa5, 0x74, 0xff, 0x73, 0xf9, 0x6f, 0x65,
	0xd0, 0x16, 0xa7, 0x03, 0x21, 0x2a, 0x41, 0x5b, 0xcc, 0x4f, 0x08, 0xed, 0x16, 0x74, 0x3c, 0xeb,
	0x2c, 0x18, 0xa7, 0x58, 0x14, 0x6e, 0x2e, 0x80, 0xe4, 0x0b, 0xfe, 0xb7, 0xe7, 0xa0, 0x21, 0x3b,
	0xa3, 0xad, 0xc1, 0x45, 0x71, 0x2c, 0x58, 0x8c, 0x8a, 0x78, 0xe0, 0x24, 0xc1, 0x3f, 0x24, 0x92,
	0x68, 0xb6, 0xb6, 0x10, 0x26, 0x24, 0x0f, 0xa2, 0x24, 0xa7, 0x19, 0x4a, 0x9d, 0x50, 0x38, 0x8c,
	0x50, 0xd6, 0xe0, 0x22, 0x26, 0x3c, 0xa4, 0x59, 0x27, 0x1e, 0x78, 0x45, 0x91, 0x06, 0x91, 0x2a,
	0x5e, 0x14, 0x15, 0x11, 0x26, 0x2a, 0xea, 0xbf, 0x51, 0x83, 0xab, 0xea, 0x5d, 0xe1, 0x22, 0xcd,
	0xde, 0x28, 0xf0, 0xdd, 0x24, 0x88, 0x64, 0xb7, 0x1d, 0xe6, 0x59, 0x67, 0xd8, 0xed, 0xba, 0x21,
	0x1e, 0x38, 0x95, 0xd8, 0xf3, 0x90, 0xd9, 0x09, 0x73, 0x4c, 0x3b, 0x70, 0x58, 0x4c, 0x0c, 0xd5,
	0x91, 0xd0, 0x5d, 0x0e, 0x14, 0x36, 0xa8, 0xe7, 0x66, 0xc4, 0x44, 0x52, 0x6f, 0xd1, 0x73, 0x18,
	0x59, 0xcf, 0x0d, 0x01, 0xe1, 0x08, 0xa7, 0x49, 0x12, 0xca, 0x4b, 0x4f, 0x45, 0xf7, 0x81, 0x83,
	0xc4, 0x75, 0xa7, 0x1c, 0x41, 0xec, 0x1f, 0x33, 0x11, 0xd1, 0x30, 0x00, 0x41, 0x42, 0x36, 0xf4,
	0x60, 0x91, 0xcb, 0x9b, 0x60, 0x9c, 0x20, 0x3b, 0xd5, 0x0d, 0xf9, 0xa8, 0x6d, 0x41, 0x63, 0x1c,
	0x79, 0x66, 0x68, 0x25, 0xa7, 0x24, 0x1e, 0x16, 0xc7, 0x91, 0x77, 0x64, 0x25, 0xa7, 0x9c, 0x32,
	0xf4, 0x8d, 0xaa, 0x70, 0x68, 0x29, 0xdf, 0xad, 0xff, 0xed, 0x8b, 0xb0, 0x5c, 0xb8, 0xb8, 0x0f,
	0x8f, 0x15, 0xdd, 0x31, 0xd1, 0x3c, 0x62, 0x9f, 0xa5, 0x87, 0xd2, 0x69, 0x40, 0x57, 0x26, 0x77,
	0x8e, 0x44, 0x89, 0x3c, 0x6b, 0xce, 0xfb, 0x26, 0x3f, 0x5d, 0x8c, 0xab, 0x7c, 0xe4, 0x7b, 0xc4,
	0xc9, 0x1d, 0xd3, 0x1a, 0x27, 0xa7, 0xbc, 0x6d, 0xb9, 0xbd, 0x91, 0x5b, 0x64, 0x31, 0xf7, 0x7a,
	0x93, 0x3b, 0x3b, 0x39, 0x84, 0x74, 0xb7, 0xfc, 0x0a, 0x2c, 0x4d, 0xee, 0x98, 0xcc, 0x1f, 0xa2,
	0xc1, 0x4b, 0x4a, 0xdb, 0xba, 0xd1, 0x9e, 0xdc, 0xb9, 0x87, 0x40, 0x14, 0xb2, 0x37, 0xa0, 0x9d,
	0x61, 0xb9, 0x0e, 0x89, 0x57, 0x90, 0x38, 0x07, 0x0e, 0x5f, 0x30, 0xf9, 0xb6, 0xc9, 0xc3, 0xab,
	0xda, 0x88, 0x7c, 0x4d, 0x84, 0xe0, 0xe1, 0x81, 0x37, 0x61, 0x65, 0x72, 0x27, 0x3b, 0xca, 0xe7,
	0xb1, 0x09, 0xf3, 0x88, 0x92, 0xcb, 0x93, 0x3b, 0x69, 0xc2, 0x6e, 0x0e, 0xe6, 0x4d, 0x4d, 0xee,
	0xe0, 0x59, 0x39, 0xf6, 0x3c, 0x21, 0x7a, 0x36, 0x27, 0x77, 0x76, 0x05, 0x40, 0xbb, 0x0d, 0x5d,
	0xb5, 0x29, 0xc5, 0x9e, 0xb9, 0x94, 0xb5, 0x84, 0x02, 0xa0, 0x9a, 0x32, 0x92, 0xd4, 0x30, 0x85,
	0x32, 0x92, 0xe2, 0x5c, 0x03, 0xdd, 0x36, 0xed, 0x60, 0x34, 0x1a, 0xfb, 0x6e, 0x72, 0x26, 0x25,
	0xf2, 0x64, 0x7b, 0x57, 0x82, 0xb4, 0xf7, 0x61, 0x5d, 0xed, 0x4a, 0x46, 0x1f, 0x61, 0x07, 0xd5,
	0xb2, 0xfe, 0xa4, 0x74, 0x7a, 0x17, 0xd6, 0xb2, 0x8f, 0x53, 0x6a, 0x74, 0xe4, 0xc0, 0xd3, 0x67,
	0xa6, 0x15, 0x7a, 0xb0, 0x38, 0x61, 0x11, 0x5f, 0xc3, 0x50, 0x44, 0xd7, 0x0d, 0xf9, 0xa8, 0xb2,
	0xeb, 0x72, 0x9e, 0x5d, 0x0b, 0xcc, 0x25, 0x79, 0xa1, 0x5b, 0x64, 0x2e, 0xc9, 0x04, 0xaf, 0xc1,
	0x72, 0x36, 0xbc, 0x83, 0x20, 0x48, 0x84, 0x96, 0x51, 0x37, 0x3a, 0x72, 0x84, 0xef, 0x72, 0xa0,
	0xfe, 0x07, 0x35, 0xb8, 0x2a, 0xce, 0x3a, 0x62, 0x2e, 0x83, 0xec, 0x9e, 0x20, 0x63, 0x2c, 0xd2,
	0x09, 0xe0, 0xc1, 0x95, 0x38, 0x31, 0x47, 0x96, 0x4d, 0xac, 0xbc, 0xe0, 0xc4, 0xc9, 0xa1, 0x65,
	0xa3, 0x35, 0x58, 0x52, 0xbe, 0x46, 0x9b, 0x58, 0x49, 0xe9, 0x4f, 0xe1, 0x92, 0x1b, 0x4e, 0x3e,
	0xcc, 0x9f, 0xb4, 0x4c, 0xad, 0xcd, 0x82, 0x83, 0x37, 0x39, 0x86, 0x7a, 0xc2, 0x52, 0x9a, 0x9e,
	0xaf, 0x40, 0xd3, 0x71, 0x23, 0x91, 0x55, 0x99, 0x26, 0x7d, 0x06, 0xe0, 0xbc, 0x84, 0x97, 0x37,
	0x79, 0xd6, 0x80, 0x79, 0x24, 0xb5, 0x9a, 0x1c, 0xf2, 0x80, 0x03, 0xf8, 0xbc, 0x4e, 0x6f, 0xd1,
	0xa7, 0x29, 0x4f, 0xc9, 0x1a, 0xd0, 0x44, 0x1d, 0xd9, 0xf8, 0x25, 0x8b, 0x64, 0xa2, 0x8e, 0x6c,
	0xfe, 0x25, 0xdb, 0xb0, 0x5e, 0xdd, 0x51, 0xc1, 0xa9, 0xab, 0x71, 0xb9, 0x93, 0xfa, 0x3f, 0x99,
	0x83, 0x57, 0x5f, 0x2a, 0xeb, 0x81, 0x76, 0x07, 0x36, 0xe2, 0xf1, 0xa0, 0xea, 0x96, 0x7f, 0x21,
	0x34, 0x57, 0xe3, 0xf1, 0xa0, 0x74, 0xc3, 0xff, 0x1b, 0xd0, 0xa5, 0xc9, 0x17, 0xb1, 0x13, 0x16,
	0x31, 0xdf, 0x66, 0x24, 0x25, 0x96, 0xc5, 0x14, 0x4c, 0xc1, 0xda, 0x8f, 0xa0, 0xab, 0xa8, 0x94,
	0x6e, 0x14, 0x05, 0x11, 0x52, 0xb8, 0xb5, 0xbd, 0xd6, 0xcf, 0x14, 0x48, 0x84, 0x8b, 0xe3, 0xa8,
	0x6e, 0x1e, 0xc8, 0xf7, 0x84, 0x59, 0xda, 0x4e, 0xd9, 0x10, 0x4a, 0x3e, 0x41, 0xfc, 0xb5, 0x34,
	0x37, 0x27, 0x15, 0xa2, 0x08, 0x1c, 0x42, 0x2f, 0x7f, 0x7c, 0x5e, 0xb0, 0x11, 0x7e, 0xf2, 0x0d,
	0xb8, 0xc8, 0x19, 0x57, 0xac, 0x66, 0x7c, 0xd1, 0xe5, 0x22, 0x47, 0xbc, 0x5d, 0x14, 0x68, 0x6f,
	0x40, 0x23, 0x66, 0xdf, 0x8d, 0xd3, 0xef, 0x6a, 0x6d, 0x77, 0xfa, 0xc7, 0x04, 0x40, 0xbc, 0xb4,
	0x58, 0xdf, 0x87, 0x26, 0x1e, 0x8d, 0xc5, 0x96, 0x6f, 0x41, 0x27, 0x61, 0xbe, 0xe5, 0x27, 0x72,
	0xd9, 0x12, 0x34, 0x6c, 0x0b, 0x20, 0x2d, 0x78, 0x1b, 0xb0, 0x20, 0x9e, 0x89, 0x2f, 0xe9, 0x49,
	0xff, 0x2b, 0x73, 0xa0, 0xf1, 0x75, 0xc1, 0xb5, 0xc5, 0x97, 0x3f, 0x3c, 0xc5, 0x36, 0xdf, 0x81,
	0xd5, 0x49, 0xc2, 0x42, 0x93, 0xb3, 0xb9, 0xe2, 0x33, 0x11, 0xdc, 0xde, 0xe5, 0x45, 0x7b, 0x71,
	0x92, 0xa5, 0x91, 0xe7, 0xf3, 0x5d, 0xa2, 0xab, 0x3e, 0x94, 0x1a, 0xcd, 0x45, 0x81, 0x9f, 0x25,
	0x9a, 0xd1, 0xba, 0x50, 0x9f, 0xf8, 0x2e, 0xad, 0x6f, 0xfc, 0xaf, 0xfe, 0x19, 0x5c, 0x97, 0x89,
	0x83, 0xf9, 0x3c, 0x3b, 0xb4, 0x12, 0xfb, 0xf4, 0x91, 0x35, 0x8c, 0x45, 0x4a, 0x39, 0x3c, 0xde,
	0xbd, 0x05, 0x0d, 0x99, 0x76, 0xae, 0x37, 0x77, 0xa3, 0x8e, 0xb2, 0x40, 0xe4, 0x9c, 0xd3, 0xef,
	0xc3, 0x6a, 0x2a, 0xb0, 0x76, 0x92, 0x24, 0x72, 0x07, 0x98, 0x36, 0xe7, 0x5d, 0x58, 0x4d, 0x45,
	0x9b, 0x69, 0x49, 0x38, 0x56, 0x6e, 0x1b, 0x9a, 0x5d, 0xaa, 0xa1, 0xbf, 0x07, 0xcb, 0xe9, 0x57,
	0x11, 0xaf, 0xe6, 0xbd, 0x46, 0x73, 0x05, 0xaf, 0x91, 0xfe, 0x3b, 0x73, 0x70, 0xa5, 0x90, 0x1f,
	0x33, 0xc7, 0x14, 0x5c, 0x4c, 0x61, 0x7c, 0xb6, 0x4d, 0xe7, 0xdb, 0xe9, 0x8c, 0xf9, 0x9c, 0x38,
	0x36, 0x2e, 0x8a, 0xf0, 0x8c, 0x2c, 0x1d, 0x33, 0xbf, 0x0c, 0x4d, 0x71, 0x0c, 0xda, 0x74, 0x43,
	0x24, 0x60, 0xc3, 0x68, 0x08, 0xc0, 0x41, 0x78, 0x0e, 0x5f, 0xd6, 0xcf, 0xe1, 0xcb, 0xff, 0x63,
	0x0e, 0x5a, 0x8a, 0x7e, 0xc9, 0x99, 0x21, 0xd7, 0x0b, 0x7a, 0xd2, 0x6e, 0x40, 0xcb, 0x61, 0xa9,
	0xd3, 0x95, 0x46, 0x4f, 0x05, 0x71, 0x69, 0x6c, 0x47, 0xcc, 0x4a, 0x98, 0x5c, 0x73, 0xe5, 0x63,
	0x5a, 0x12, 0x44, 0x34, 0x45, 0xe4, 0x23, 0x5f, 0x62, 0xd0, 0x93, 0xcf, 0xf7, 0x28, 0xfc, 0x9d,
	0x42, 0x25, 0x69, 0x71, 0xd8, 0x13, 0x01, 0x12, 0xca, 0x21, 0xe7, 0x9d, 0xc0, 0x71, 0x4f, 0x5c,
	0x26, 0x37, 0x2e, 0x6d, 0x0e, 0x3c, 0x24, 0x98, 0xf6, 0x16, 0xb4, 0xb8, 0x76, 0xea, 0xc6, 0xb1,
	0xa2, 0xe9, 0x36, 0x53, 0xe5, 0xd5, 0x50, 0x4b, 0xf5, 0x7d, 0x68, 0x1b, 0x03, 0xcb, 0x4e, 0x95,
	0xc9, 0xcb, 0xd0, 0x8c, 0x02, 0x8f, 0x99, 0x76, 0x34, 0x96, 0x6a, 0x7e, 0x83, 0x03, 0x76, 0xa3,
	0xb1, 0x93, 0x16, 0xe2, 0x2a, 0x5b, 0xcb, 0x0a, 0xf9, 0xfa, 0xaa, 0x7f, 0x0b, 0x6b, 0xf7, 0xbd,
	0xe0, 0x59, 0x9a, 0x63, 0x21, 0x18, 0x8b, 0x64, 0x03, 0x3f, 0x02, 0x0d, 0x03, 0xf5, 0xb3, 0x8c,
	0x0c, 0x7c, 0x8d, 0xe2, 0xac, 0x85, 0xe9, 0x76, 0x0a, 0x55, 0x8c, 0xee, 0x49, 0x01, 0xa2, 0xbf,
	0x06, 0xad, 0xc7, 0x13, 0xf6, 0x15, 0x3b, 0x8b, 0xe5, 0xa2, 0x32, 0x9e, 0x30, 0xf4, 0x16, 0xce,
	0x89, 0xdd, 0xc2, 0x18, 0x4b, 0xf5, 0xbf, 0x36, 0x07, 0xd7, 0xf6, 0xdc, 0xd8, 0x0e, 0x26, 0x2c,
	0x92, 0xc7, 0xef, 0x45, 0x32, 0x9b, 0x91, 0xdc, 0x69, 0x7c, 0x06, 0x40, 0x4e, 0xf5, 0x01, 0x4a,
	0x18, 0xde, 0x87, 0x2b, 0xfd, 0xb4, 0xd2, 0xd1, 0x78, 0x70, 0x3c, 0x1e, 0xdc, 0xf3, 0x9d, 0xa3,
	0xc0, 0x15, 0x35, 0x0c, 0x05, 0x5f, 0xfb, 0x84, 0x6c, 0xaf, 0xf1, 0x29, 0x8b, 0x48, 0xf2, 0x9c,
	0x5f, 0x39, 0x43, 0xd7, 0x7f, 0xb3, 0x06, 0x57, 0xbf, 0x8c, 0x2c, 0x9b, 0x9d, 0x8c, 0x3d, 0x83,
	0xe1, 0x76, 0xf6, 0xc8, 0x8a, 0xac, 0x11, 0x4b, 0x58, 0x74, 0x3e, 0xb3, 0xbd, 0x05, 0x1a, 0xdf,
	0xff, 0x07, 0x27, 0x66, 0xe4, 0x0e, 0x52, 0xfa, 0x91, 0x40, 0x67, 0xbe, 0xf3, 0xf5, 0x89, 0xe1,
	0x0e, 0x88, 0x56, 0x5c, 0xb3, 0x1a, 0x0c, 0x43, 0xf3, 0x94, 0x79, 0x21, 0x8b, 0xe4, 0x14, 0xaa,
	0x63, 0x7b, 0xcb, 0x83, 0x61, 0xb8, 0x8f, 0x70, 0x9a, 0x40, 0x6f, 0x83, 0xf6, 0x7c, 0x14, 0x16,
	0x91, 0xe7, 0x11, 0xb9, 0xcb, 0x4b, 0x72, 0xd8, 0x37, 0xa1, 0x1d, 0x31, 0x65, 0x1b, 0x4e, 0x3a,
	0x3f, 0xc1, 0x50, 0x2f, 0xfc, 0x01, 0x6c, 0x7a, 0x81, 0x3f, 0x34, 0x3d, 0x77, 0xc2, 0x1c, 0x33,
	0x87, 0x2d, 0x96, 0xd3, 0x35, 0x5e, 0xfc, 0x80, 0x97, 0x1a, 0x59, 0x35, 0xfd, 0xb3, 0xf4, 0x22,
	0x8c, 0x6c, 0x36, 0x5a, 0xb8, 0x5f, 0x2a, 0x4c, 0x5d, 0xc1, 0x8e, 0x1d, 0x37, 0x37, 0x67, 0x43,
	0xd0, 0xf2, 0x36, 0x7a, 0x24, 0xe6, 0x36, 0xac, 0x4b, 0x83, 0x61, 0x1c, 0x32, 0xdb, 0x3d, 0x71,
	0x6d, 0x34, 0xf2, 0x13, 0x6d, 0x57, 0xa9, 0xf0, 0x98, 0xca, 0x78, 0x3d, 0xbe, 0x21, 0x11, 0x2e,
	0x00, 0xc1, 0xd9, 0xe2, 0x81, 0x4b, 0x60, 0xe6, 0xcb, 0x59, 0xcc, 0xff, 0xea, 0x7f, 0x69, 0x1e,
	0x96, 0xc4, 0x82, 0x95, 0x2a, 0x3a, 0x39, 0xb5, 0x63, 0xae, 0xa8, 0x76, 0x9c, 0xa7, 0xed, 0xbc,
	0x0f, 0x1d, 0xbe, 0x18, 0x64, 0x69, 0xc9, 0xea, 0xc8, 0x94, 0xed, 0x3e, 0xc9, 0x4d, 0xe4, 0xa3,
	0xb6, 0x13, 0x27, 0x59, 0xea, 0x31, 0xbe, 0x93, 0xb5, 0xb3, 0xdc, 0x62, 0xf3, 0x94, 0x2c, 0x6d,
	0xc7, 0x96, 0xb9, 0xc2, 0x04, 0xe3, 0x5a, 0xe9, 0xb3, 0x2a, 0x8d, 0x2e, 0xe6, 0xa5, 0x11, 0x9f,
	0xd1, 0x63, 0x8f, 0x99, 0x8a, 0x15, 0xa4, 0xc1, 0x01, 0xb8, 0x71, 0x7f, 0x0d, 0x9a, 0xbc, 0x6f,
	0xe2, 0xba, 0xe5, 0x45, 0xec, 0x57, 0xb3, 0x8f, 0x37, 0x02, 0xe3, 0x2a, 0xeb, 0xc4, 0x09, 0x5e,
	0xa7, 0xcc, 0xc5, 0x21, 0xde, 0x82, 0x21, 0xc6, 0xa0, 0xd7, 0xc0, 0x59, 0xa9, 0x82, 0xca, 0x72,
	0xab, 0x59, 0x21, 0xb7, 0xae, 0x40, 0x13, 0x6f, 0x9f, 0x57, 0x32, 0x2a, 0x64, 0x00, 0x4e, 0x28,
	0xae, 0x81, 0xa9, 0xf9, 0xdb, 0x2a, 0x08, 0x15, 0x47, 0x4a, 0x8e, 0xb6, 0x6d, 0xe8, 0xe0, 0xc7,
	0xa5, 0xda, 0x42, 0xbb, 0x4a, 0x5b, 0x68, 0x73, 0x1c, 0x09, 0xe1, 0xdf, 0xcc, 0x5f, 0x23, 0xbe,
	0xb9, 0x53, 0xfa, 0xe6, 0x38, 0xb2, 0xc5, 0x15, 0xd2, 0xff, 0xef, 0x1c, 0xac, 0x55, 0xe5, 0xcf,
	0xe4, 0xfb, 0x4a, 0xca, 0xb5, 0x89, 0x52, 0x52, 0x30, 0x03, 0x08, 0xd0, 0x43, 0x3a, 0x72, 0x4e,
	0x08, 0x78, 0x3f, 0xa7, 0x5c, 0x3d, 0x04, 0x0c, 0xaf, 0xd8, 0x54, 0xda, 0xc0, 0x44, 0x92, 0x75,
	0xb5, 0x8d, 0x3d, 0x2b, 0xb1, 0x14, 0x04, 0x45, 0xd7, 0x22, 0x04, 0xec, 0xc5, 0xdb, 0xa0, 0x49,
	0x84, 0xc4, 0xe3, 0x7b, 0x92, 0xc0, 0x77, 0xe4, 0x3e, 0xbd, 0x4b, 0x78, 0x89, 0x77, 0x2c, 0xe0,
	0xda, 0x7b, 0xb0, 0x46, 0xd8, 0xa3, 0xe7, 0xaa, 0xd6, 0x28, 0x66, 0x2d, 0xb5, 0x74, 0xf8, 0x3c,
	0x53, 0x1c, 0xf5, 0x5f, 0x9f, 0x83, 0xe5, 0x1d, 0xbc, 0xa7, 0xf7, 0x79, 0xc8, 0xa9, 0xcd, 0x07,
	0xf9, 0x0a, 0x34, 0xb9, 0xf2, 0x6a, 0xa9, 0x93, 0x20, 0x05, 0xf0, 0x49, 0x80, 0x0f, 0xbe, 0xf3,
	0xbe, 0x9c, 0x04, 0xf2, 0x99, 0xd7, 0x9c, 0x58, 0x91, 0xcb, 0xe5, 0x8c, 0x98, 0x00, 0x7c, 0x8b,
	0x27, 0x01, 0xda, 0x9b, 0x69, 0xcd, 0x6d, 0x62, 0xf6, 0xa5, 0x3e, 0xbe, 0xfb, 0x6b, 0x82, 0xa6,
	0x2d, 0x6d, 0xeb, 0xbf, 0x3b, 0x07, 0xab, 0x85, 0x7b, 0x15, 0x1e, 0xc9, 0xf0, 0x93, 0xfc, 0xae,
	0x3a, 0x9b, 0x82, 0x39, 0x36, 0xaf, 0xc9, 0xd5, 0xb2, 0xcc, 0xe6, 0x39, 0xd6, 0xa8, 0x97, 0xf0,
	0x24, 0x6b, 0xa0, 0xbd, 0x8b, 0xda, 0xe6, 0x7b, 0x39, 0xb1, 0x83, 0x06, 0x09, 0x3a, 0x70, 0x74,
	0x1f, 0x6e, 0xe4, 0x6e, 0xb8, 0xab, 0x48, 0x6a, 0xcf, 0xa5, 0x5f, 0xe4, 0x0e, 0x4f, 0x93, 0x8c,
	0x79, 0x49, 0xfa, 0x21, 0x34, 0x65, 0x57, 0x3e, 0xb1, 0xd8, 0x89, 0x82, 0x55, 0xa3, 0x89, 0xc5,
	0x4e, 0x52, 0x24, 0xfd, 0xaf, 0xce, 0x41, 0x33, 0xd5, 0xa2, 0xb9, 0x9e, 0xa6, 0x08, 0x66, 0x1a,
	0xa7, 0x4c, 0x88, 0xdf, 0x84, 0x76, 0x70, 0x72, 0x22, 0xb4, 0xa6, 0x89, 0x25, 0x05, 0x56, 0x2b,
	0x38, 0x39, 0x39, 0x20, 0x10, 0xff, 0xc0, 0xc0, 0xcf, 0x30, 0x88, 0x3d, 0x03, 0x3f, 0x45, 0xd8,
	0x82, 0x06, 0x5f, 0xb2, 0x14, 0x73, 0xed, 0x22, 0xf3, 0x1d, 0x14, 0xf6, 0xff, 0xdd, 0x1c, 0xf4,
	0x54, 0xfd, 0x55, 0xde, 0xca, 0x22, 0x35, 0x74, 0x99, 0x8f, 0x4a, 0x58, 0x9d, 0xe6, 0x28, 0xe4,
	0x4b, 0x00, 0x85, 0xe9, 0xfa, 0x16, 0x2c, 0x50, 0xb8, 0x57, 0xad, 0x9c, 0x0f, 0x9c, 0x8a, 0xd0,
	0x8e, 0x69, 0x0d, 0x25, 0x33, 0xe1, 0x7f, 0xae, 0x38, 0x88, 0xf4, 0xd6, 0x31, 0x9a, 0x19, 0xeb,
	0xc6, 0x02, 0xe6, 0xb7, 0x8e, 0xb5, 0xd7, 0x61, 0xb9, 0x90, 0x43, 0x8b, 0xc4, 0xe4, 0x52, 0x3e,
	0x71, 0x16, 0x5f, 0x0b, 0x2c, 0xff, 0x0c, 0xa7, 0x45, 0xc3, 0xe0, 0x7f, 0xf5, 0x08, 0x56, 0x2b,
	0xf6, 0x49, 0xda, 0x5b, 0xb0, 0x92, 0x44, 0xd6, 0x09, 0x5f, 0x75, 0x8a, 0xeb, 0x42, 0x97, 0x0a,
	0xf6, 0xd2, 0xe5, 0xa1, 0x0f, 0x4d, 0xb1, 0xf5, 0x32, 0x93, 0x80, 0xbe, 0x69, 0xa5, 0x2f, 0x1a,
	0x13, 0x32, 0x5d, 0xf0, 0x97, 0xc0, 0x79, 0x14, 0x70, 0xd1, 0xa3, 0x95, 0xb3, 0x8f, 0xf1, 0xaf,
	0x50, 0xee, 0xfe, 0xc5, 0x24, 0x5e, 0xe2, 0x8d, 0x4b, 0x19, 0x18, 0xb3, 0x77, 0x71, 0x2a, 0x7b,
	0x78, 0x74, 0x32, 0xb2, 0xfc, 0xd8, 0x4d, 0x48, 0x79, 0x6e, 0x23, 0xf0, 0x91, 0x80, 0x71, 0x2e,
	0x51, 0xf2, 0x88, 0x89, 0xfd, 0x47, 0xd3, 0x4f, 0x33, 0x87, 0xbd, 0x03, 0x1a, 0xf5, 0xd9, 0x61,
	0x71, 0xe2, 0xfa, 0x56, 0xba, 0xe1, 0x6e, 0x18, 0x2b, 0xa2, 0x64, 0x2f, 0x2b, 0xd0, 0x3e, 0x82,
	0x9e, 0xb8, 0x0e, 0x3c, 0x6b, 0x33, 0xbd, 0x07, 0x57, 0x08, 0xa5, 0x0d, 0x2c, 0x4f, 0x53, 0x93,
	0xa5, 0x77, 0xe1, 0x76, 0xa1, 0x1e, 0x85, 0x27, 0xb4, 0x34, 0xf1, 0xbf, 0xfa, 0x1e, 0x34, 0xe4,
	0xa4, 0x93, 0x8c, 0x86, 0x56, 0x26, 0xb1, 0x9b, 0xe3, 0x8c, 0x86, 0x36, 0xa6, 0x94, 0xcd, 0xb1,
	0x50, 0xa8, 0x4b, 0x82, 0xcd, 0x79, 0xb1, 0xfe, 0x39, 0xb4, 0xf9, 0xef, 0xa1, 0x15, 0x86, 0x98,
	0x01, 0xf3, 0x1d, 0xe8, 0x60, 0xb2, 0x85, 0x11, 0x01, 0x48, 0x39, 0x6c, 0xf4, 0x09, 0xcb, 0x68,
	0x87, 0x0a, 0xba, 0xfe, 0x3f, 0x67, 0xbb, 0x19, 0x39, 0x6d, 0xf3, 0xbb, 0x99, 0x0a, 0x9e, 0x9a,
	0xab, 0xe4, 0xa9, 0xfc, 0xb6, 0xa9, 0x56, 0x0c, 0xb6, 0xdb, 0x87, 0xf5, 0xea, 0x3c, 0x99, 0xf5,
	0x73, 0xf2, 0x64, 0xae, 0x5a, 0x15, 0x09, 0x31, 0x3f, 0x80, 0x8e, 0xba, 0xbf, 0x8a, 0x53, 0xc5,
	0xa1, 0x90, 0x65, 0xb5, 0xad, 0x6c, 0xb5, 0x62, 0xfd, 0x13, 0x68, 0xab, 0xab, 0x25, 0x57, 0x92,
	0x46, 0xd6, 0x4f, 0x83, 0x48, 0x5a, 0x6d, 0xf1, 0x01, 0xa1, 0xae, 0x1f, 0x44, 0x44, 0x67, 0xf1,
	0xa0, 0x3f, 0x06, 0x7d, 0xea, 0xe5, 0x7b, 0xf7, 0xfc, 0x24, 0x3a, 0x4b, 0x77, 0x1c, 0xa9, 0x0a,
	0x32, 0x57, 0x50, 0x41, 0x34, 0x98, 0xc7, 0x6b, 0xf6, 0x44, 0xbb, 0xf8, 0x5f, 0x3f, 0x04, 0xc8,
	0x66, 0x3c, 0x26, 0xc4, 0x4a, 0x6f, 0x08, 0xa0, 0xea, 0x2e, 0x5d, 0x07, 0xa0, 0xe9, 0xd0, 0x49,
	0x0b, 0x4d, 0x8f, 0xf9, 0xd2, 0x0a, 0x2e, 0x11, 0x1e, 0x30, 0x5f, 0xff, 0x40, 0x5c, 0xca, 0xaa,
	0xe6, 0x47, 0xe3, 0x4b, 0xb4, 0x92, 0x63, 0x8d, 0xf6, 0x19, 0x2d, 0x25, 0x87, 0x9b, 0xfe, 0xc7,
	0x35, 0xd8, 0x7a, 0xe0, 0xfa, 0x4f, 0xd1, 0xa2, 0x92, 0xde, 0x30, 0x25, 0xbf, 0xe9, 0x5d, 0x58,
	0x73, 0x43, 0xf3, 0xc4, 0x1a, 0x44, 0xae, 0x9d, 0x1a, 0xb2, 0xdc, 0x90, 0x1a, 0x5a, 0x71, 0xc3,
	0xfb, 0x58, 0x24, 0x39, 0x08, 0xf7, 0xab, 0x9e, 0x6c, 0x2d, 0xad, 0xa0, 0x6c, 0xb3, 0xd6, 0xbc,
	0xc2, 0xbb, 0xc8, 0xa7, 0xb1, 0x56, 0xae, 0xe5, 0x86, 0x24, 0x91, 0xb5, 0x62, 0x9d, 0x83, 0x50,
	0xbb, 0x03, 0x1b, 0xe5, 0x8e, 0xe1, 0x0c, 0x11, 0xcb, 0xd4, 0x6a, 0xa1, 0x6b, 0x38, 0x95, 0x3e,
	0x81, 0x4b, 0x59, 0xa5, 0xbd, 0x87, 0xc7, 0xf9, 0x0e, 0x0a, 0x51, 0xb9, 0x21, 0x2b, 0xee, 0x3d,
	0x3c, 0x56, 0xbb, 0x58, 0xf9, 0x61, 0x8a, 0x55, 0xb8, 0xf4, 0x61, 0x38, 0x3b, 0x7f, 0x36, 0x0f,
	0x4b, 0x07, 0xa1, 0x35, 0x52, 0xc6, 0x39, 0x13, 0xfb, 0x73, 0xd3, 0xc5, 0xfe, 0x6b, 0xb0, 0xcc,
	0x67, 0x89, 0x79, 0x12, 0x05, 0x23, 0x33, 0x53, 0xe6, 0x1b, 0x06, 0xae, 0x2b, 0xf7, 0xa3, 0x60,
	0x24, 0x22, 0x78, 0xae, 0x43, 0x4b, 0x6c, 0x77, 0x30, 0x55, 0x2f, 0x6d, 0x90, 0x40, 0x80, 0xf6,
	0x4e, 0xed, 0xb0, 0x2a, 0x28, 0x62, 0xbe, 0x32, 0x28, 0xe2, 0x2a, 0x00, 0xc6, 0x11, 0x99, 0x63,
	0xdf, 0x4d, 0xa4, 0x49, 0x11, 0x21, 0x8f, 0x7d, 0x37, 0xa7, 0x79, 0x2f, 0xe4, 0x35, 0x6f, 0xfe,
	0x06, 0x3f, 0x46, 0x12, 0xca, 0xa3, 0x08, 0x8b, 0xc8, 0x1d, 0x4b, 0x8e, 0x1f, 0x3f, 0xcc, 0xa0,
	0xda, 0x17, 0xd0, 0x2d, 0xe5, 0x13, 0x6e, 0x9c, 0x93, 0x4f, 0x78, 0xc9, 0xc9, 0x27, 0x0e, 0xbe,
	0x0e, 0x2d, 0xba, 0x49, 0x03, 0x67, 0x18, 0x25, 0xa6, 0x11, 0x20, 0x9c, 0x63, 0x5f, 0x40, 0xb7,
	0x10, 0x0a, 0x15, 0xf7, 0x00, 0xa5, 0xdf, 0x6a, 0xbf, 0xbc, 0xb5, 0x32, 0x96, 0xad, 0x1c, 0x2c,
	0x2e, 0x2b, 0xf7, 0xad, 0x0a, 0xe5, 0xfe, 0x3d, 0x68, 0xa9, 0x19, 0x9e, 0xdb, 0xd5, 0xb2, 0x07,
	0x4e, 0xb3, 0x54, 0xce, 0x6f, 0x83, 0x96, 0x9d, 0xd3, 0x48, 0x05, 0x64, 0x87, 0x62, 0xe3, 0xe4,
	0x39, 0x0d, 0x25, 0x28, 0x99, 0xbe, 0x12, 0x99, 0x72, 0x49, 0xfd, 0x4a, 0x34, 0x4f, 0xfc, 0xe7,
	0x0d, 0x68, 0x7e, 0x33, 0x0e, 0x12, 0x4b, 0xaa, 0x57, 0xf9, 0xbc, 0x6c, 0x24, 0xcf, 0x3a, 0xb9,
	0x64, 0x6c, 0x1c, 0x2d, 0x4d, 0x01, 0x2a, 0xb2, 0x1f, 0x0b, 0x01, 0xd2, 0xf1, 0x55, 0xbb, 0x25,
	0x5f, 0xee, 0x3d, 0xc5, 0xd7, 0x25, 0x76, 0x9a, 0x62, 0xcd, 0xec, 0xaa, 0x05, 0xb8, 0xcd, 0xe4,
	0xba, 0x3b, 0x09, 0x17, 0xb9, 0xdf, 0xae, 0x1b, 0x10, 0x65, 0x37, 0x90, 0x6f, 0xa4, 0x9c, 0x2e,
	0xd8, 0x49, 0x32, 0xf7, 0x4d, 0x68, 0xa7, 0xcb, 0x67, 0x68, 0x8d, 0x68, 0x02, 0xb5, 0xe4, 0xa2,
	0x1c, 0x5a, 0x23, 0x4e, 0xb3, 0x72, 0xd2, 0x7f, 0xb4, 0x00, 0xd5, 0x8d, 0x6e, 0x31, 0xb1, 0x3f,
	0xff, 0x3a, 0x2f, 0x18, 0xba, 0x76, 0x46, 0x84, 0x86, 0xf8, 0x3a, 0x82, 0x12, 0x11, 0xfa, 0xb0,
	0x5a, 0xb8, 0xc0, 0x96, 0x8b, 0x67, 0xba, 0xbf, 0x7e, 0x25, 0x77, 0x85, 0x2d, 0x97, 0xec, 0xfc,
	0x03, 0x95, 0x4e, 0xd0, 0x0d, 0xa9, 0x90, 0xbd, 0x5d, 0x7b, 0x03, 0xba, 0xc5, 0xbb, 0x9e, 0xb2,
	0x0b, 0x71, 0xf3, 0x77, 0x6e, 0x29, 0xa8, 0xf2, 0xe2, 0x1d, 0xe4, 0x9d, 0x0c, 0x35, 0xbd, 0xb4,
	0xe8, 0x2a, 0xc0, 0x60, 0x18, 0xca, 0x2f, 0x11, 0xe9, 0xb5, 0x9a, 0x83, 0x61, 0x48, 0x5f, 0x71,
	0x1d, 0x5a, 0x27, 0x5e, 0x60, 0x25, 0x98, 0x7e, 0x35, 0x24, 0xef, 0x09, 0x48, 0xd0, 0x41, 0xa8,
	0xdd, 0x86, 0xae, 0x82, 0x20, 0xc6, 0x50, 0x78, 0x52, 0x96, 0x32, 0x2c, 0x1c, 0xc1, 0x77, 0x61,
	0x35, 0x37, 0xdc, 0x22, 0x16, 0x83, 0x12, 0x70, 0x69, 0x6a, 0x91, 0x88, 0xbd, 0xe0, 0x14, 0xa4,
	0xc0, 0x10, 0x99, 0x11, 0x13, 0x67, 0xb1, 0xf0, 0xaa, 0xac, 0x88, 0x22, 0x4a, 0x29, 0x80, 0x53,
	0xf6, 0x93, 0x2c, 0x6b, 0x60, 0x29, 0x85, 0x32, 0x46, 0x87, 0x66, 0x39, 0x5d, 0x4b, 0xf9, 0xec,
	0xaf, 0x43, 0x2b, 0x0d, 0x7d, 0x77, 0x43, 0x8c, 0x0a, 0xad, 0x1b, 0x20, 0x41, 0x07, 0xa1, 0xb6,
	0x0d, 0xeb, 0x43, 0x2f, 0x18, 0x58, 0x5e, 0x9a, 0x8b, 0x83, 0x1c, 0xcd, 0x6b, 0x62, 0x05, 0x10,
	0x85, 0x94, 0x7a, 0x83, 0x9c, 0xd2, 0x1f, 0xc2, 0xe6, 0x94, 0x5b, 0x70, 0x31, 0x86, 0xb3, 0x6e,
	0xac, 0x57, 0x5e, 0x80, 0xab, 0x7d, 0x0e, 0x97, 0x72, 0x94, 0x3a, 0x55, 0xbd, 0xc0, 0x18, 0xad,
	0x59, 0x37, 0xb6, 0xbc, 0x69, 0x6e, 0x62, 0xf4, 0xfd, 0xa5, 0xb9, 0xff, 0x31, 0x32, 0xb3, 0x6e,
	0x34, 0xd3, 0x04, 0xff, 0x7c, 0x53, 0x47, 0xd2, 0x38, 0xc6, 0xf0, 0xcb, 0xba, 0x91, 0x3e, 0x63,
	0x0e, 0x90, 0x1c, 0xd3, 0x62, 0xd8, 0x65, 0xdd, 0xe8, 0xe4, 0xf8, 0xb5, 0x4a, 0x4d, 0xbb, 0x24,
	0xc6, 0x3c, 0xaf, 0xa6, 0xe9, 0x7b, 0xd0, 0xc9, 0x85, 0x0a, 0x68, 0x77, 0x60, 0xe9, 0x29, 0x3b,
	0x13, 0xb7, 0xe2, 0xa0, 0x4a, 0x46, 0x1a, 0x63, 0x27, 0x17, 0x52, 0x60, 0xb4, 0x9f, 0x2a, 0x4f,
	0xe8, 0x45, 0x78, 0xc4, 0x3c, 0x36, 0x62, 0x49, 0x74, 0x86, 0x6e, 0x66, 0x3c, 0x87, 0xb3, 0x0d,
	0x8d, 0x88, 0xc5, 0xc1, 0x38, 0xb2, 0x19, 0xb5, 0xb2, 0xd1, 0x4f, 0xd1, 0x0c, 0x2a, 0xe1, 0x98,
	0x46, 0x8a, 0x87, 0x02, 0x4f, 0x88, 0x46, 0x45, 0xc1, 0x05, 0x01, 0xc2, 0x55, 0xfb, 0x32, 0x34,
	0x09, 0x21, 0xd5, 0x08, 0x1a, 0x02, 0x70, 0x10, 0xea, 0x1f, 0xc2, 0xd6, 0x54, 0x2f, 0x82, 0xf4,
	0x1f, 0x20, 0x8f, 0x0a, 0x8d, 0x85, 0x6f, 0x9c, 0xf0, 0x7e, 0x42, 0x0f, 0x36, 0x8a, 0x5a, 0x0f,
	0xd6, 0x89, 0x35, 0x03, 0x36, 0xcb, 0x0b, 0x3d, 0xe3, 0x1a, 0x11, 0x7d, 0xd2, 0xa5, 0xfe, 0x54,
	0x7d, 0xc9, 0x58, 0xf7, 0xaa, 0x8a, 0xf4, 0x6d, 0x58, 0xca, 0x2f, 0x10, 0xda, 0x0d, 0xb8, 0x88,
	0x8c, 0x49, 0x6d, 0x02, 0x2d, 0x20, 0xe8, 0x1d, 0xc2, 0x02, 0xfd, 0x0e, 0x74, 0x8b, 0x19, 0xfd,
	0x8b, 0x27, 0x56, 0xc4, 0x37, 0x29, 0x27, 0x56, 0xf4, 0x3f, 0x98, 0x83, 0x95, 0x34, 0x1d, 0x7a,
	0x6a, 0xd5, 0x7b, 0x03, 0xba, 0x91, 0xd8, 0xa7, 0x67, 0x72, 0x8a, 0x82, 0xa4, 0xa2, 0xc2, 0x35,
	0xfe, 0x9f, 0xc1, 0xf2, 0x88, 0xd3, 0x90, 0xcf, 0x25, 0xc7, 0x4d, 0xbd, 0x02, 0x7c, 0x09, 0x45,
	0xda, 0xee, 0x4a, 0xb0, 0x4c, 0x32, 0xab, 0xc2, 0x72, 0x8e, 0xc7, 0x7a, 0xde, 0xf1, 0xc8, 0xb7,
	0x07, 0x43, 0x3f, 0x88, 0x98, 0x69, 0xd9, 0x1e, 0x6d, 0xb0, 0x9a, 0x02, 0xb2, 0x63, 0x7b, 0xfa,
	0x7f, 0x50, 0x83, 0xa5, 0xbc, 0xe1, 0x0f, 0x83, 0x33, 0x84, 0x72, 0xa2, 0x5a, 0xa0, 0x5a, 0x04,
	0x43, 0xa5, 0xac, 0x0b, 0x75, 0x2f, 0x18, 0x92, 0x6a, 0xc4, 0xff, 0x72, 0x05, 0xde, 0xf2, 0x58,
	0x94, 0x90, 0x2a, 0x24, 0x1e, 0xf8, 0xcb, 0xbf, 0x0b, 0x62, 0xd3, 0xca, 0xb9, 0x53, 0xbf, 0x0b,
	0x62, 0xf1, 0x46, 0x4c, 0x1f, 0x2d, 0x12, 0xcb, 0x97, 0xc8, 0x74, 0x91, 0xd2, 0x47, 0x0b, 0x82,
	0x16, 0x88, 0x95, 0xdb, 0xf0, 0x2e, 0xbc, 0x70, 0xc3, 0xcb, 0x15, 0x8c, 0xd8, 0x1d, 0x85, 0x1e,
	0x93, 0x3d, 0x11, 0x2e, 0xd8, 0xb6, 0x00, 0x52, 0x67, 0xf8, 0xae, 0x36, 0x0c, 0xbd, 0x34, 0x43,
	0x2f, 0x99, 0x21, 0xdb, 0x08, 0x94, 0xd7, 0xc1, 0x1e, 0x73, 0x6a, 0x79, 0xca, 0xa5, 0xef, 0x5c,
	0x41, 0x73, 0xce, 0x7c, 0x6b, 0xe4, 0xda, 0x64, 0x1a, 0x96, 0x8f, 0xda, 0xeb, 0xd0, 0xb0, 0x6c,
	0x4f, 0xac, 0x75, 0x35, 0x69, 0x6b, 0xb4, 0x3d, 0xc9, 0x1d, 0xc6, 0xa2, 0x25, 0x1e, 0xf4, 0xff,
	0xaf, 0x96, 0x66, 0xdd, 0x15, 0x97, 0x90, 0xe0, 0x0a, 0x9e, 0x58, 0xc9, 0x58, 0xba, 0xc1, 0xe8,
	0x89, 0xef, 0x9a, 0xc5, 0x3f, 0xb3, 0xec, 0x3e, 0x5a, 0x11, 0x25, 0x7b, 0x8a, 0x13, 0x49, 0x35,
	0x5a, 0xd5, 0x0b, 0x46, 0x2b, 0x3e, 0xbb, 0xe9, 0x7e, 0x34, 0x19, 0xdd, 0xd2, 0xa0, 0xbb, 0xd0,
	0xf0, 0x10, 0x43, 0xc8, 0xa2, 0xd8, 0x8d, 0x13, 0xbe, 0x6f, 0x33, 0xed, 0x20, 0x78, 0xea, 0xe6,
	0xb4, 0xf5, 0x75, 0xa5, 0x78, 0x17, 0x4b, 0x91, 0x2f, 0x44, 0x34, 0x13, 0x5d, 0x4a, 0x2c, 0xb2,
	0x14, 0x93, 0x96, 0xb1, 0x9c, 0xc1, 0x31, 0x1d, 0x31, 0x06, 0x10, 0x2a, 0xaf, 0x40, 0x33, 0x24,
	0x45, 0x70, 0x28, 0x70, 0x39, 0xfb, 0xd4, 0x48, 0x9b, 0x46, 0x55, 0xa4, 0x4d, 0x3e, 0x6d, 0xa2,
	0x7c, 0xe4, 0x83, 0x9a, 0x9a, 0xd2, 0x50, 0xcc, 0x09, 0x65, 0xa2, 0x2d, 0x81, 0xb8, 0x59, 0xf8,
	0xbd, 0x39, 0x68, 0xa6, 0x62, 0x80, 0xd3, 0x3e, 0xb7, 0x19, 0xa4, 0x27, 0x3e, 0xc7, 0x7c, 0xf6,
	0x3c, 0x31, 0x4f, 0x83, 0x90, 0x28, 0xbe, 0xc8, 0x9f, 0xf7, 0x83, 0x50, 0xfb, 0x12, 0xd6, 0x2a,
	0xbc, 0x9f, 0xd9, 0x16, 0xbb, 0xc2, 0x63, 0x6a, 0xac, 0xda, 0x15, 0x6e, 0x54, 0x1d, 0x3a, 0xf2,
	0x1d, 0xaa, 0x61, 0xb6, 0x45, 0x2f, 0x42, 0x7f, 0xc5, 0x3f, 0x9c, 0x83, 0xae, 0x1a, 0x18, 0x75,
	0x2e, 0xc3, 0xbc, 0x4b, 0x69, 0xca, 0xd5, 0x70, 0xc6, 0xb1, 0xb4, 0x12, 0x68, 0xc5, 0x78, 0xc6,
	0x71, 0x5c, 0xa4, 0x75, 0xbd, 0x44, 0x6b, 0x54, 0xce, 0x32, 0x7b, 0x03, 0x59, 0x8e, 0x27, 0x99,
	0xc1, 0x41, 0x87, 0x0e, 0x47, 0xc8, 0x98, 0xeb, 0x22, 0x45, 0xba, 0xb8, 0x74, 0xbc, 0xf3, 0xc0,
	0xe1, 0x83, 0x4f, 0x86, 0xdd, 0xac, 0x4f, 0x62, 0x7b, 0xb3, 0x9c, 0xc2, 0x45, 0x87, 0xf4, 0x2f,
	0xa0, 0x2d, 0x63, 0x68, 0x5e, 0x68, 0x88, 0xd5, 0x60, 0x5e, 0x59, 0xcb, 0xf0, 0xbf, 0xfe, 0x1b,
	0xf3, 0x8a, 0x77, 0x48, 0xb1, 0x8f, 0x6e, 0xc3, 0xba, 0xb0, 0x8f, 0x56, 0x5b, 0x59, 0x56, 0xb1,
	0xb0, 0x70, 0xd3, 0xc1, 0x6d, 0xe8, 0x8a, 0x3a, 0x25, 0x83, 0x8b, 0xb0, 0xb5, 0x66, 0x7e, 0xfa,
	0xb7, 0x60, 0xc5, 0x9a, 0x58, 0xae, 0x67, 0x0d, 0x5c, 0x8f, 0x33, 0xc5, 0xaf, 0x05, 0xbe, 0xf4,
	0x1c, 0x77, 0xd5, 0x82, 0x5f, 0x0c, 0x7c, 0x0c, 0x2c, 0x52, 0xce, 0xbc, 0x15, 0xfb, 0x23, 0x28,
	0xdc, 0xcb, 0x30, 0x0a, 0x9d, 0x7a, 0x1f, 0x9a, 0xb1, 0x6d, 0x79, 0xcc, 0x0c, 0xc6, 0x09, 0x05,
	0x39, 0xa6, 0x17, 0x49, 0x1e, 0xf3, 0x82, 0xaf, 0xc7, 0xd2, 0xc0, 0x4c, 0x4f, 0xda, 0x26, 0x2c,
	0xca, 0x6b, 0xca, 0x05, 0xd5, 0x17, 0x4e, 0xc5, 0xb5, 0xe4, 0x6f, 0xc2, 0x4a, 0x31, 0xdb, 0xb4,
	0x93, 0xc6, 0x55, 0xe5, 0xb2, 0x4c, 0x3b, 0xda, 0x9e, 0xea, 0x5e, 0xa3, 0x4d, 0x25, 0x17, 0x72,
	0x57, 0xfb, 0xe7, 0xd9, 0xb5, 0x14, 0xef, 0x1b, 0x6a, 0xaa, 0xaf, 0xc1, 0x32, 0xda, 0x9f, 0x15,
	0x8a, 0x8a, 0x29, 0x8c, 0x66, 0xe9, 0x8c, 0xa0, 0xef, 0xc1, 0x1a, 0xe2, 0x15, 0xa9, 0x03, 0x64,
	0xa9, 0x60, 0x27, 0x45, 0xba, 0x70, 0x4e, 0x1e, 0x27, 0x81, 0xdc, 0x77, 0xb5, 0x88, 0x93, 0xc7,
	0x49, 0x20, 0x36, 0x5d, 0xfa, 0x9f, 0xce, 0x81, 0x56, 0x5e, 0x5b, 0xb5, 0x57, 0xa0, 0x21, 0xad,
	0xf4, 0x64, 0x29, 0x50, 0x8c, 0xf4, 0x8b, 0x64, 0xa4, 0xd7, 0xde, 0x81, 0x96, 0xe2, 0x4d, 0xa2,
	0xb5, 0x3a, 0xef, 0x4b, 0x82, 0xcc, 0x97, 0x94, 0x77, 0x4d, 0xd5, 0x8b, 0xae, 0xa9, 0x77, 0xa0,
	0xa5, 0xf8, 0xf0, 0xc8, 0xae, 0x56, 0x68, 0x2c, 0xf3, 0xe0, 0xf1, 0x1e, 0x4a, 0x7f, 0x03, 0x0d,
	0xb8, 0xda, 0x43, 0x72, 0x37, 0xe4, 0x26, 0xca, 0x42, 0x7e, 0xa2, 0xe8, 0x7f, 0x38, 0x07, 0x1b,
	0x0f, 0x4a, 0xdb, 0x8c, 0xbf, 0xc8, 0xa5, 0x67, 0x03, 0x16, 0x9e, 0x31, 0x3e, 0x27, 0x48, 0x1f,
	0xa1, 0xa7, 0xa2, 0x7c, 0x99, 0x3f, 0x4f, 0x96, 0x5f, 0x7c, 0x81, 0x2c, 0x5f, 0xa8, 0x90, 0xe5,
	0x07, 0xb0, 0xfc, 0x38, 0x66, 0x91, 0x1a, 0x1b, 0xa9, 0x1e, 0x02, 0x9e, 0x2b, 0x1c, 0x02, 0x56,
	0x4f, 0x15, 0xd7, 0x0a, 0xd7, 0x04, 0xfe, 0x12, 0xac, 0x56, 0xdd, 0x0b, 0x74, 0x0f, 0xd6, 0xaa,
	0x0c, 0xaa, 0xa4, 0x50, 0xae, 0x56, 0xd8, 0x53, 0x0d, 0xad, 0x6c, 0x4e, 0xd5, 0x8f, 0x61, 0xbd,
	0x52, 0x43, 0x47, 0x21, 0x66, 0x25, 0xa7, 0x32, 0x44, 0x9a, 0xff, 0xcf, 0x59, 0x31, 0x9b, 0xc2,
	0x8a, 0x99, 0x66, 0x2c, 0xaa, 0x67, 0x19, 0x8b, 0xf4, 0x01, 0x6c, 0xc8, 0xe4, 0xff, 0xe4, 0x24,
	0x88, 0xed, 0x50, 0xaa, 0x29, 0xf2, 0xba, 0x00, 0xb2, 0x73, 0xd3, 0x23, 0x67, 0x4d, 0x4b, 0xe6,
	0x60, 0x95, 0x66, 0xee, 0x14, 0xc0, 0x35, 0x3d, 0xc7, 0x97, 0xf1, 0xb1, 0xfc, 0xaf, 0x7e, 0x17,
	0x34, 0x4e, 0xe1, 0x3d, 0x76, 0xe2, 0xfa, 0xcc, 0x79, 0x10, 0xa0, 0xa0, 0xe6, 0xed, 0x87, 0x56,
	0x92, 0xb0, 0x48, 0xba, 0x29, 0xe4, 0x63, 0xda, 0xcf, 0x9a, 0xd2, 0xcf, 0xbf, 0x57, 0x83, 0xb5,
	0x07, 0x05, 0xbb, 0xc6, 0xb9, 0xdc, 0x77, 0x9e, 0x07, 0x3c, 0xa7, 0xc9, 0xd4, 0x0b, 0x9a, 0xcc,
	0xbb, 0xb0, 0x1a, 0x0b, 0xf7, 0xa2, 0xa9, 0xa8, 0x15, 0x24, 0x54, 0x35, 0x2a, 0x3a, 0xca, 0x4a,
	0x5e, 0x1c, 0xd6, 0x7b, 0x8e, 0x6e, 0xb4, 0x70, 0x9e, 0x6e, 0x54, 0x3d, 0x81, 0x16, 0xa7, 0x4d,
	0xa0, 0xb2, 0x8d, 0x00, 0xe3, 0x90, 0x1b, 0x24, 0xef, 0x72, 0x93, 0x97, 0x97, 0xe8, 0x1f, 0x42,
	0x5b, 0xdd, 0x38, 0x72, 0x8d, 0x5c, 0xdc, 0xb8, 0x4a, 0x51, 0xdd, 0xf8, 0xc0, 0xc7, 0xf3, 0x29,
	0x3b, 0x23, 0x1a, 0xf2, 0xbf, 0xfa, 0x47, 0xd0, 0xca, 0x2c, 0xa5, 0xb1, 0xf6, 0x06, 0x2c, 0x0a,
	0xe2, 0x49, 0x0f, 0xc6, 0x72, 0x3f, 0x6f, 0x48, 0x35, 0x64, 0xb9, 0xfe, 0x97, 0x6a, 0xd0, 0x53,
	0x47, 0xf1, 0x01, 0x7e, 0x34, 0xc9, 0x91, 0x6d, 0x90, 0x07, 0x5d, 0xcd, 0xc4, 0x13, 0x76, 0x0b,
	0x0c, 0x66, 0x97, 0xeb, 0x2b, 0x15, 0x3e, 0xf2, 0xd0, 0x70, 0x81, 0x45, 0xe7, 0x8e, 0x72, 0x95,
	0x6a, 0x59, 0xaf, 0x56, 0x2d, 0x5f, 0x28, 0x63, 0xf8, 0xde, 0xde, 0x77, 0xb3, 0x3e, 0x71, 0x51,
	0x53, 0xc7, 0xfc, 0x9e, 0xbe, 0x9b, 0xf6, 0xe6, 0x25, 0x05, 0xce, 0x0f, 0xe1, 0x92, 0x7a, 0x09,
	0x17, 0x1d, 0x96, 0x39, 0x75, 0x43, 0xb9, 0x13, 0x2e, 0x44, 0x5c, 0xca, 0x8d, 0x99, 0x3e, 0x86,
	0xce, 0x13, 0x9f, 0xa8, 0x4e, 0x14, 0x6b, 0xbb, 0xa1, 0x35, 0x32, 0x5f, 0x40, 0xfe, 0x96, 0xab,
	0x8c, 0x56, 0xc1, 0x2a, 0x5a, 0x7b, 0xa1, 0x55, 0x54, 0xbf, 0x0f, 0x57, 0x65, 0x68, 0x53, 0x18,
	0x7a, 0x6e, 0xd9, 0xf1, 0xf4, 0x92, 0x61, 0x33, 0x3f, 0x80, 0x25, 0xd1, 0x89, 0x74, 0xdf, 0xa8,
	0x1a, 0xd8, 0xeb, 0x53, 0x0c, 0xec, 0xfa, 0x13, 0xb8, 0x74, 0xf7, 0xcb, 0x23, 0xcb, 0x92, 0xc6,
	0xfa, 0x7c, 0x08, 0xd3, 0x55, 0x00, 0x71, 0x49, 0x0b, 0x5a, 0xde, 0x05, 0xc1, 0x9a, 0x78, 0x33,
	0x0b, 0x5a, 0xdd, 0xb7, 0xa0, 0x81, 0xc5, 0xcc, 0x77, 0x64, 0xd8, 0x3a, 0x7f, 0xbe, 0xe7, 0x3b,
	0xfa, 0x6f, 0xce, 0x81, 0xc6, 0x09, 0xb5, 0xe7, 0xc7, 0xca, 0xb2, 0xa9, 0x7d, 0x05, 0x5b, 0x14,
	0xb2, 0x59, 0x61, 0x0a, 0x9e, 0xa3, 0x4b, 0x6f, 0x0a, 0x81, 0x88, 0xc6, 0x86, 0xa8, 0xb2, 0x57,
	0x34, 0x11, 0xff, 0x20, 0xbb, 0x11, 0x55, 0x69, 0x4d, 0x75, 0xb2, 0x4c, 0xd2, 0x80, 0x0e, 0x51,
	0x13, 0x0d, 0xc7, 0x5f, 0xc2, 0x6a, 0x85, 0x99, 0x9d, 0x0f, 0x9d, 0x62, 0x96, 0x4f, 0x47, 0x3b,
	0x43, 0xa5, 0x75, 0x3f, 0x7d, 0xe6, 0x0b, 0x52, 0xc5, 0x15, 0x2f, 0x98, 0xc4, 0x5f, 0xde, 0x09,
	0x43, 0x34, 0x6b, 0xc8, 0x5b, 0x5f, 0xb8, 0xca, 0x9a, 0x5d, 0x18, 0x43, 0xbb, 0x5f, 0x52, 0x59,
	0x25, 0x8e, 0xd8, 0xff, 0xea, 0x07, 0xb0, 0x51, 0x96, 0xeb, 0xa8, 0xa3, 0xbd, 0x0b, 0x0d, 0x3e,
	0x93, 0x52, 0x73, 0x0e, 0x5f, 0xe5, 0xca, 0xa8, 0x46, 0x8a, 0xa4, 0xff, 0xdf, 0x73, 0xd0, 0x9b,
	0x76, 0x15, 0x95, 0xb8, 0x31, 0x20, 0xf5, 0xec, 0x0a, 0xa7, 0x16, 0x7a, 0x58, 0x14, 0xe8, 0x41,
	0x88, 0x66, 0xc8, 0xd0, 0xcc, 0x89, 0x83, 0x86, 0x01, 0x6e, 0x78, 0xa4, 0x8a, 0x7d, 0x5c, 0x35,
	0xa5, 0x79, 0xaa, 0x61, 0x34, 0x68, 0x19, 0x0d, 0xb9, 0xb0, 0x95, 0x57, 0x65, 0x09, 0xe3, 0xe4,
	0x38, 0x62, 0x8e, 0x74, 0x2f, 0x53, 0xc9, 0x6e, 0x5a, 0x80, 0xb6, 0x30, 0xd1, 0x56, 0xaa, 0x54,
	0x35, 0x0c, 0x10, 0x20, 0x54, 0xa6, 0xde, 0x80, 0xae, 0xda, 0xe9, 0x54, 0x1a, 0x34, 0x8c, 0x65,
	0x05, 0x8e, 0x02, 0x61, 0x17, 0x2e, 0xdf, 0xf3, 0x6d, 0x2b, 0x8c, 0xc7, 0x1e, 0x9d, 0x00, 0x70,
	0x83, 0xc8, 0x4d, 0x23, 0xb2, 0x5f, 0x81, 0x0e, 0x53, 0x8b, 0x29, 0x46, 0x36, 0x0f, 0xd4, 0xff,
	0xf9, 0x39, 0xb8, 0x92, 0xbb, 0x88, 0xe7, 0x61, 0x66, 0xa4, 0x7f, 0xe9, 0xc9, 0x56, 0xe9, 0x98,
	0xa9, 0xbd, 0xbc, 0x63, 0x46, 0xff, 0xc7, 0xd9, 0x85, 0x78, 0x74, 0xf9, 0xac, 0xf6, 0x36, 0x06,
	0x63, 0xa6, 0x46, 0x6e, 0x72, 0x10, 0x50, 0x64, 0x42, 0x66, 0xe6, 0x26, 0x07, 0xc1, 0x75, 0x68,
	0x89, 0xbb, 0x0b, 0xd5, 0x59, 0x02, 0x02, 0x24, 0x0d, 0x06, 0xe9, 0x49, 0x78, 0x19, 0xb6, 0x4a,
	0xd1, 0x86, 0x12, 0x2e, 0x43, 0x57, 0x6f, 0x43, 0x17, 0xf7, 0xc6, 0xaa, 0x6b, 0x80, 0x5c, 0x6a,
	0x1c, 0xae, 0x5c, 0x2e, 0xfc, 0x39, 0x5c, 0x26, 0x1b, 0x0c, 0xf5, 0x2f, 0x16, 0xfe, 0x3c, 0xdb,
	0x73, 0x99, 0x2f, 0x47, 0xb7, 0x47, 0x28, 0xa2, 0xa7, 0xf1, 0xfd, 0x28, 0x18, 0xed, 0x62, 0x39,
	0xe7, 0x9d, 0x88, 0x4d, 0x58, 0x14, 0x33, 0x33, 0x62, 0x71, 0xe0, 0x8d, 0x71, 0x98, 0xc4, 0x68,
	0xaf, 0x50, 0x89, 0x91, 0x16, 0x68, 0x7d, 0x58, 0x4d, 0x17, 0x3a, 0x25, 0x54, 0x4a, 0xf8, 0x4c,
	0x56, 0xe4, 0x32, 0x97, 0xc5, 0x4a, 0x65, 0xe1, 0x5b, 0x41, 0xe4, 0x90, 0xcb, 0x24, 0x0d, 0xdf,
	0xfa, 0x9a, 0x83, 0xf4, 0x3e, 0x74, 0xb3, 0x18, 0x24, 0x0a, 0xd4, 0xb9, 0xa4, 0x04, 0xad, 0xcf,
	0x49, 0x63, 0x2c, 0xc5, 0xe7, 0xfc, 0x59, 0x1d, 0xba, 0x45, 0xf3, 0x17, 0xa7, 0x82, 0xef, 0xda,
	0x78, 0x73, 0x63, 0x9c, 0x30, 0x87, 0xa2, 0xf3, 0xf9, 0xb8, 0xf1, 0x15, 0x88, 0x04, 0x45, 0xcf,
	0x77, 0xed, 0x1d, 0xc2, 0x38, 0x94, 0x08, 0x4f, 0x3c, 0x4b, 0x98, 0xc3, 0xb8, 0x16, 0xf8, 0x6b,
	0x79, 0x11, 0xd7, 0x96, 0xc0, 0x87, 0x94, 0x43, 0xc7, 0x3f, 0x15, 0x1b, 0x49, 0xa1, 0x78, 0x2d,
	0xf8, 0xa7, 0xb8, 0x91, 0x7c, 0x15, 0x96, 0x7e, 0x3a, 0xf6, 0xdd, 0x50, 0x98, 0xec, 0xf9, 0x67,
	0x8a, 0xb9, 0xd7, 0x21, 0xe8, 0x3e, 0x02, 0xf1, 0x20, 0x94, 0x13, 0x66, 0x93, 0xae, 0x6e, 0x2c,
	0x8e, 0x9d, 0x50, 0xce, 0xb8, 0x92, 0x51, 0x70, 0xa1, 0xda, 0x76, 0xfa, 0x39, 0x74, 0x29, 0x30,
	0xc1, 0x3f, 0x95, 0xaf, 0x5b, 0x24, 0xe3, 0x69, 0x39, 0xe4, 0xde, 0x10, 0xb9, 0xbd, 0xed, 0x87,
	0xa7, 0xd4, 0x89, 0x3e, 0xac, 0xa6, 0x5f, 0xaa, 0x6c, 0x43, 0xc5, 0xb8, 0xac, 0xc8, 0xa2, 0x6c,
	0x2b, 0x5a, 0x9a, 0xc1, 0xb4, 0x61, 0xcd, 0x01, 0xf9, 0x86, 0x35, 0x6d, 0x55, 0xb5, 0x1d, 0xd3,
	0x86, 0x55, 0x96, 0x29, 0xa1, 0xfa, 0x1f, 0xc0, 0x46, 0xf5, 0x80, 0xd1, 0xde, 0x75, 0xad, 0x6a,
	0xac, 0xf4, 0xff, 0xb0, 0x06, 0x8d, 0x54, 0x2a, 0xa0, 0xd0, 0xb4, 0x46, 0x52, 0x59, 0xa4, 0xd8,
	0x41, 0x0e, 0xa2, 0x43, 0x6b, 0xaf, 0xc1, 0x32, 0x22, 0xf0, 0xf5, 0x8b, 0x90, 0xe8, 0x78, 0x9c,
	0x2b, 0x16, 0x4f, 0xc2, 0xfb, 0x54, 0xc1, 0x13, 0xeb, 0x1c, 0x19, 0xb3, 0x56, 0xfb, 0xe5, 0x55,
	0x36, 0xad, 0x2c, 0x16, 0xbd, 0x4a, 0x87, 0xf3, 0xfc, 0xf7, 0x70, 0x38, 0x17, 0x94, 0x9a, 0x8b,
	0x2f, 0x76, 0xf5, 0xbe, 0x09, 0x60, 0xbb, 0x4e, 0x64, 0x0e, 0xbc, 0xc0, 0x7e, 0x4a, 0x16, 0xe1,
	0x9c, 0x44, 0x6c, 0xf2, 0xe2, 0xbb, 0xbc, 0x54, 0xff, 0x10, 0x56, 0x7e, 0x3c, 0xf6, 0x83, 0x58,
	0x09, 0x17, 0xc0, 0x49, 0x99, 0x8b, 0x2d, 0xa0, 0x80, 0x8d, 0x58, 0x09, 0x29, 0x38, 0x86, 0x4e,
	0x2e, 0x68, 0x90, 0xcf, 0x90, 0xf1, 0x84, 0xe5, 0x4e, 0x3b, 0xe0, 0x0c, 0x19, 0x4f, 0x58, 0x6a,
	0xd2, 0xe3, 0x1a, 0xcd, 0x4f, 0xe3, 0xc0, 0x17, 0x6e, 0x1e, 0x19, 0x9d, 0xc3, 0x21, 0xa8, 0xa8,
	0xeb, 0xff, 0x9c, 0x88, 0x9e, 0x4f, 0x3d, 0x06, 0xd7, 0xa1, 0x85, 0xb1, 0x2c, 0xe4, 0x1b, 0x93,
	0xc1, 0x9f, 0x63, 0x8f, 0x91, 0x43, 0xec, 0x6d, 0xc0, 0x27, 0x3a, 0xd3, 0x5a, 0x23, 0x8f, 0x91,
	0x1a, 0x81, 0x6f, 0x60, 0x34, 0x8c, 0x38, 0xd6, 0x7a, 0x95, 0xb0, 0xf1, 0x9a, 0x48, 0x69, 0x77,
	0xe0, 0x10, 0x5c, 0x8b, 0xf5, 0xdf, 0x9a, 0x83, 0xae, 0x50, 0x5b, 0x51, 0x11, 0x88, 0x65, 0x0c,
	0x5d, 0x18, 0x05, 0xfc, 0x65, 0x39, 0x95, 0xa2, 0x4d, 0x40, 0xa1, 0x56, 0x6c, 0x67, 0x97, 0x6a,
	0x4b, 0x97, 0xb2, 0x40, 0x16, 0x6a, 0xd9, 0x6a, 0xde, 0xf9, 0x25, 0xea, 0xbc, 0x07, 0x6b, 0x05,
	0x37, 0xb0, 0xaa, 0xc5, 0x6b, 0x39, 0xbf, 0x1a, 0xd6, 0xd0, 0xef, 0xc1, 0x8a, 0xb0, 0xd5, 0xa8,
	0x06, 0xf7, 0xf7, 0xa0, 0x45, 0x57, 0xe9, 0xa1, 0x65, 0x5d, 0xea, 0x4d, 0xf9, 0x80, 0x6a, 0x03,
	0xc2, 0xf4, 0x59, 0xff, 0xb3, 0x1a, 0x6c, 0xd0, 0x68, 0x0b, 0xf7, 0xe0, 0xee, 0x29, 0xb3, 0x45,
	0xcc, 0xdb, 0x35, 0x00, 0x3c, 0x36, 0xfa, 0x38, 0x66, 0xb6, 0x3c, 0xcf, 0xa3, 0x40, 0x34, 0x1d,
	0xda, 0x14, 0x30, 0x2f, 0x30, 0x6a, 0x74, 0xe2, 0x47, 0x81, 0xf1, 0xad, 0xaf, 0xbc, 0x28, 0x47,
	0x2c, 0x5d, 0xf2, 0x31, 0x3b, 0xa1, 0x3a, 0x7f, 0xfe, 0x09, 0xd5, 0x8b, 0x2f, 0x71, 0x42, 0x75,
	0xa1, 0x74, 0x42, 0xf5, 0x4d, 0x58, 0x11, 0xee, 0x50, 0xd3, 0xe6, 0xdf, 0x93, 0x33, 0xa1, 0x9f,
	0x16, 0xbe, 0xb3, 0x70, 0x9a, 0xb5, 0x51, 0x3a, 0xcd, 0xaa, 0x9c, 0xfe, 0x6b, 0x4e, 0x3f, 0xac,
	0x0a, 0xe7, 0x1f, 0x56, 0x6d, 0x95, 0x0f, 0xab, 0xfe, 0xe1, 0x1c, 0xb4, 0x54, 0x85, 0xbc, 0xec,
	0x56, 0xa5, 0xdd, 0x45, 0xde, 0xad, 0xfa, 0x52, 0x31, 0x9a, 0xe5, 0xe0, 0x0a, 0xc1, 0xe1, 0x85,
	0xe0, 0x8a, 0xb7, 0xd3, 0xc8, 0x0e, 0x92, 0x44, 0x25, 0x7d, 0x89, 0xc2, 0x3c, 0x50, 0xf8, 0xbc,
	0x6c, 0x2c, 0xa7, 0x1e, 0x42, 0xb7, 0x78, 0xf6, 0x84, 0x6b, 0x47, 0x44, 0x36, 0x93, 0x6f, 0x3f,
	0x49, 0x15, 0x10, 0x6c, 0xd5, 0xa5, 0x92, 0x03, 0x5f, 0x6a, 0x02, 0xe7, 0x6d, 0x77, 0xa5, 0x29,
	0xbb, 0xae, 0x98, 0xb2, 0x7f, 0x09, 0x7a, 0xdf, 0x04, 0xf1, 0x81, 0x72, 0x50, 0x12, 0xa3, 0xbd,
	0x71, 0xb7, 0x4f, 0xfb, 0x7a, 0xf1, 0x2a, 0xfe, 0x97, 0x2f, 0x6b, 0x4a, 0x38, 0x27, 0x86, 0x8a,
	0x9b, 0xae, 0xdc, 0x37, 0xad, 0x9c, 0xe4, 0xdb, 0x38, 0x70, 0xf4, 0x1d, 0x58, 0x95, 0xa2, 0x48,
	0x9d, 0x6e, 0x6f, 0x42, 0x33, 0x1a, 0x58, 0xb6, 0x3a, 0xd9, 0x84, 0xbc, 0x49, 0xa7, 0x5a, 0x23,
	0xa2, 0x27, 0xfd, 0x53, 0xe8, 0xdd, 0xcf, 0x45, 0x3a, 0x28, 0xe1, 0x57, 0x85, 0x28, 0x22, 0x72,
	0xa1, 0x66, 0x51, 0x44, 0xfa, 0x6f, 0x65, 0x86, 0x7a, 0x19, 0x92, 0x81, 0x15, 0x3f, 0x82, 0x5e,
	0xc9, 0x94, 0x9e, 0x3f, 0xdb, 0xb5, 0x51, 0xb4, 0xa8, 0xd3, 0x89, 0x93, 0x5b, 0xd0, 0x49, 0x23,
	0x19, 0x30, 0x0e, 0x9e, 0x54, 0x18, 0x09, 0xc4, 0x48, 0xf8, 0x77, 0x40, 0x43, 0x3d, 0x8c, 0x29,
	0xc9, 0x31, 0x62, 0x9a, 0xc8, 0x2b, 0x54, 0x92, 0x6e, 0x90, 0x31, 0x2f, 0x85, 0x5c, 0x28, 0x88,
	0x1f, 0xdc, 0x5f, 0x13, 0xea, 0xb5, 0xe2, 0xaf, 0xd9, 0x22, 0x94, 0x27, 0x39, 0x0c, 0xfc, 0x9a,
	0xbd, 0xd2, 0xee, 0xfa, 0x62, 0xde, 0x6a, 0x5e, 0x79, 0xb6, 0xad, 0xb0, 0xf9, 0x46, 0xa7, 0xee,
	0xc8, 0x1a, 0xe6, 0xcc, 0x4e, 0x4d, 0x84, 0xc8, 0x13, 0x02, 0xb2, 0x93, 0xa8, 0x9b, 0x09, 0xa1,
	0x20, 0x57, 0x33, 0x54, 0xd0, 0x94, 0x73, 0xc0, 0x8d, 0xfc, 0x39, 0x60, 0xa5, 0x32, 0xf6, 0xaf,
	0x99, 0xab, 0x2c, 0xad, 0x74, 0x27, 0x9e, 0x35, 0x09, 0x22, 0x12, 0x08, 0xf4, 0xc4, 0xe7, 0x8e,
	0xac, 0x1a, 0xdb, 0x96, 0x97, 0xa9, 0x2e, 0x4b, 0x71, 0xe6, 0x8f, 0x70, 0xfd, 0xa1, 0x7a, 0xba,
	0x26, 0x9f, 0x66, 0x51, 0x9c, 0x74, 0x96, 0xa7, 0x6b, 0x54, 0x87, 0x8d, 0x7e, 0x08, 0xdd, 0xd2,
	0x8d, 0xe9, 0x1f, 0xc3, 0x4a, 0xe9, 0x26, 0xf6, 0x94, 0x49, 0x55, 0xb7, 0x91, 0xb1, 0x7c, 0x92,
	0xaf, 0xab, 0xff, 0xcd, 0x39, 0xd8, 0x9c, 0x72, 0x87, 0xab, 0xf6, 0xae, 0xb8, 0x5b, 0x17, 0xef,
	0x7d, 0xe5, 0xb3, 0xd6, 0x7c, 0xe6, 0xfa, 0x4e, 0xf0, 0x8c, 0x66, 0xd7, 0x0a, 0xdd, 0xf0, 0xca,
	0x27, 0xfd, 0xb7, 0x58, 0x20, 0xef, 0x0c, 0xc6, 0x0a, 0xea, 0x3a, 0xd8, 0x26, 0x54, 0xb1, 0x00,
	0xbe, 0x0f, 0xeb, 0x79, 0x2c, 0xb9, 0x21, 0xa7, 0x70, 0x4b, 0x15, 0x99, 0x36, 0xe5, 0xff, 0xc6,
	0x1c, 0x5c, 0x3e, 0xe7, 0x80, 0x18, 0x67, 0x04, 0x16, 0x9a, 0x72, 0x24, 0x29, 0x16, 0x9f, 0x85,
	0x4f, 0x68, 0x2c, 0x57, 0xe1, 0x22, 0x0b, 0xcd, 0x34, 0xa9, 0xc6, 0x3c, 0x0b, 0xc5, 0xb5, 0x70,
	0x2c, 0x54, 0xcf, 0x32, 0x2e, 0x30, 0x61, 0xac, 0xba, 0x0d, 0x4d, 0x96, 0x46, 0xc2, 0xce, 0x97,
	0xe5, 0x6e, 0x83, 0x51, 0xd4, 0xab, 0xfe, 0x9f, 0x70, 0xa9, 0x9e, 0xb9, 0xb2, 0xcf, 0x0f, 0xc1,
	0xfd, 0xf3, 0x85, 0x36, 0xe4, 0x4e, 0x46, 0xd5, 0x8b, 0x27, 0xa3, 0xbe, 0xf7, 0x51, 0x26, 0xfd,
	0x2e, 0x2c, 0x1d, 0x79, 0xe3, 0xa1, 0xeb, 0xd3, 0x49, 0xe9, 0x33, 0x12, 0xc3, 0xf8, 0x5f, 0xf1,
	0x28, 0x8a, 0xb2, 0xd4, 0x88, 0x5a, 0x53, 0x8c, 0xa8, 0xfa, 0x2f, 0xc1, 0xcd, 0xa9, 0x71, 0xc9,
	0xa9, 0x7d, 0xe7, 0x87, 0x30, 0xaf, 0xc8, 0xcc, 0x5b, 0xfd, 0x17, 0x47, 0x32, 0x1b, 0x58, 0x41,
	0xff, 0x49, 0x76, 0xc0, 0x81, 0x64, 0x02, 0xae, 0x89, 0xd8, 0xe8, 0x8f, 0xa0, 0x7b, 0x42, 0x65,
	0x69, 0x9c, 0x82, 0x78, 0xc1, 0x5a, 0xbf, 0xe2, 0xd8, 0x8a, 0xb1, 0x7c, 0x92, 0x07, 0xea, 0x47,
	0xa0, 0x95, 0xaf, 0xed, 0xd7, 0x3e, 0x81, 0x65, 0xe5, 0x96, 0x7f, 0xa5, 0xdb, 0x5a, 0xbf, 0x14,
	0xd5, 0x62, 0x74, 0x26, 0x2a, 0x48, 0xbf, 0x01, 0xa0, 0xb8, 0x8f, 0x34, 0x98, 0x8f, 0x02, 0x4f,
	0xea, 0xc2, 0xf8, 0x5f, 0xff, 0x14, 0xda, 0xa8, 0x39, 0xef, 0xf8, 0xe2, 0x78, 0xf1, 0x5b, 0xd0,
	0xb0, 0x7c, 0xc7, 0x54, 0xec, 0x49, 0xdd, 0x7e, 0xe1, 0x2c, 0x90, 0xb1, 0x68, 0x09, 0x64, 0xfd,
	0x27, 0xb0, 0x48, 0x11, 0xf4, 0x5c, 0x13, 0xc9, 0x79, 0xe6, 0xea, 0x99, 0x3b, 0xee, 0xbc, 0xa5,
	0x74, 0x4b, 0x71, 0x97, 0x51, 0x70, 0x0c, 0xf9, 0xc8, 0x74, 0x06, 0xcb, 0x85, 0x9b, 0xba, 0x85,
	0x0c, 0x1b, 0x8e, 0x98, 0x9f, 0x90, 0x7d, 0xca, 0xa1, 0x77, 0x2d, 0xa9, 0x60, 0xe1, 0xc3, 0x0e,
	0x4f, 0xcf, 0x62, 0x8c, 0x7e, 0x94, 0x9a, 0x42, 0x8d, 0x02, 0x18, 0x08, 0x2e, 0x55, 0x85, 0x7f,
	0x69, 0x0e, 0x9a, 0x69, 0xea, 0x97, 0x7f, 0xfa, 0x74, 0x2b, 0xb7, 0xa0, 0x43, 0x81, 0x77, 0xb9,
	0x7c, 0x2b, 0x6d, 0x01, 0x24, 0xa4, 0x1b, 0x70, 0x11, 0x0f, 0x31, 0x93, 0x9e, 0x03, 0xfd, 0xf4,
	0xfc, 0xba, 0x21, 0x0a, 0xb8, 0xd6, 0xbf, 0x94, 0xb7, 0x32, 0x72, 0x55, 0x52, 0xdd, 0xb1, 0xa9,
	0x7e, 0x83, 0xe5, 0x6c, 0x73, 0x86, 0x5b, 0x16, 0xed, 0x07, 0xb0, 0x59, 0xc2, 0x35, 0x07, 0x67,
	0x49, 0x9a, 0x69, 0x65, 0xad, 0x50, 0xe3, 0x2e, 0x2f, 0xd3, 0x6e, 0xe7, 0x37, 0x85, 0x8a, 0xeb,
	0x4a, 0xd9, 0xfe, 0xa1, 0xbd, 0x74, 0x02, 0x5b, 0xd3, 0xd4, 0x9c, 0x58, 0xfb, 0x05, 0xb8, 0xf2,
	0x5d, 0xc0, 0x15, 0x19, 0xb3, 0xa4, 0xdc, 0x28, 0x5e, 0xb8, 0xad, 0xfe, 0xb4, 0x16, 0x8c, 0xde,
	0x77, 0x53, 0x4a, 0xf4, 0x07, 0xd0, 0xcd, 0x49, 0x06, 0xae, 0x63, 0x7f, 0x04, 0xcb, 0x21, 0xc2,
	0x4c, 0x45, 0x44, 0xd0, 0x86, 0x23, 0x27, 0x45, 0x8c, 0xa5, 0x30, 0xf7, 0xac, 0xff, 0x00, 0x5a,
	0x62, 0xbb, 0x18, 0x91, 0x9f, 0x7b, 0x31, 0x88, 0x54, 0x96, 0xef, 0xf4, 0xd5, 0x39, 0x61, 0x2c,
	0x04, 0x88, 0xa7, 0xff, 0x42, 0xaa, 0x04, 0xa9, 0xbe, 0x7b, 0x8c, 0x12, 0x1f, 0x27, 0x01, 0x2e,
	0xab, 0x52, 0xed, 0x69, 0x72, 0x08, 0x62, 0x71, 0xce, 0xe0, 0x7b, 0x05, 0xb9, 0x96, 0xc6, 0xd9,
	0xf2, 0xf3, 0x5c, 0xae, 0xa1, 0xb1, 0x7e, 0x22, 0x0e, 0xba, 0xe6, 0xfd, 0x90, 0xda, 0x65, 0xa8,
	0x91, 0x09, 0xb6, 0x20, 0xed, 0x6b, 0x6e, 0xc8, 0xb5, 0xca, 0x91, 0x65, 0x4b, 0x6f, 0xd1, 0xc8,
	0xb2, 0x39, 0x9b, 0x4a, 0xaf, 0xa7, 0x62, 0xf6, 0x69, 0x11, 0x8c, 0xab, 0x16, 0x6f, 0xfe, 0x2a,
	0xb4, 0x0d, 0x16, 0x87, 0x81, 0x1f, 0x0b, 0xe1, 0xb2, 0x00, 0xb5, 0xaf, 0xbf, 0xea, 0x5e, 0xd0,
	0x96, 0x00, 0xee, 0x5a, 0x8e, 0xc1, 0xbe, 0x1b, 0xb3, 0x38, 0xe9, 0xce, 0x69, 0x1a, 0x2c, 0x71,
	0x25, 0x67, 0x88, 0x09, 0x4d, 0xa2, 0x28, 0x88, 0xba, 0x35, 0xad, 0x0d, 0x8d, 0x87, 0x41, 0x72,
	0x3f, 0x18, 0xfb, 0x4e, 0xb7, 0xae, 0x6d, 0x80, 0x76, 0x40, 0xf7, 0x14, 0x09, 0xd3, 0xc2, 0x3d,
	0x8e, 0x35, 0xbf, 0xfd, 0xbb, 0x73, 0xb0, 0x2c, 0x7d, 0xa6, 0x44, 0x2d, 0xed, 0x87, 0xb0, 0xb4,
	0x8b, 0x91, 0xf1, 0x5f, 0x47, 0x8f, 0x43, 0xc7, 0x4a, 0x98, 0xd6, 0xed, 0x4b, 0x1c, 0x7a, 0xe7,
	0xa5, 0x15, 0x05, 0x22, 0x3a, 0xf8, 0xde, 0x9c, 0xf6, 0x16, 0x2c, 0xec, 0x31, 0x8f, 0x25, 0x4c,
	0x5b, 0xea, 0x8b, 0x3f, 0x12, 0x7d, 0x39, 0x7d, 0x4e, 0x91, 0xdf, 0x80, 0x79, 0x1c, 0xce, 0x76,
	0x1f, 0x47, 0xed, 0x9c, 0x76, 0xef, 0x76, 0xff, 0xce, 0x9f, 0x5c, 0x9b, 0xfb, 0xd9, 0x9f, 0x5c,
	0x9b, 0xfb, 0xfb, 0x7f, 0x72, 0x6d, 0xee, 0x37, 0xff, 0xc1, 0xb5, 0x0b, 0x83, 0x05, 0x14, 0x49,
	0x77, 0xfe, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xcb, 0x0c, 0xac, 0x2c, 0x4d, 0x1b, 0x01, 0x00,
}
